var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(y, c, g) {
  y != Array.prototype && y != Object.prototype && (y[c] = g.value);
};
$jscomp.getGlobal = function(y) {
  return "undefined" != typeof window && window === y ? y : "undefined" != typeof global && null != global ? global : y;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var y = 0;
  return function(c) {
    return $jscomp.SYMBOL_PREFIX + (c || "") + y++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var y = $jscomp.global.Symbol.iterator;
  y || (y = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[y] && $jscomp.defineProperty(Array.prototype, y, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(y) {
  var c = 0;
  return $jscomp.iteratorPrototype(function() {
    return c < y.length ? {done:!1, value:y[c++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(y) {
  $jscomp.initSymbolIterator();
  y = {next:y};
  y[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return y;
};
$jscomp.makeIterator = function(y) {
  $jscomp.initSymbolIterator();
  var c = y[Symbol.iterator];
  return c ? c.call(y) : $jscomp.arrayIterator(y);
};
$jscomp.polyfill = function(y, c, g, n) {
  if (c) {
    g = $jscomp.global;
    y = y.split(".");
    for (n = 0; n < y.length - 1; n++) {
      var m = y[n];
      m in g || (g[m] = {});
      g = g[m];
    }
    y = y[y.length - 1];
    n = g[y];
    c = c(n);
    c != n && null != c && $jscomp.defineProperty(g, y, {configurable:!0, writable:!0, value:c});
  }
};
$jscomp.polyfill("Array.prototype.fill", function(y) {
  return y ? y : function(c, g, n) {
    var m = this.length || 0;
    0 > g && (g = Math.max(0, m + g));
    if (null == n || n > m) {
      n = m;
    }
    n = Number(n);
    0 > n && (n = Math.max(0, m + n));
    for (g = Number(g || 0); g < n; g++) {
      this[g] = c;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.iteratorFromArray = function(y, c) {
  $jscomp.initSymbolIterator();
  y instanceof String && (y += "");
  var g = 0, n = {next:function() {
    if (g < y.length) {
      var m = g++;
      return {value:c(m, y[m]), done:!1};
    }
    n.next = function() {
      return {done:!0, value:void 0};
    };
    return n.next();
  }};
  n[Symbol.iterator] = function() {
    return n;
  };
  return n;
};
$jscomp.polyfill("Array.prototype.values", function(y) {
  return y ? y : function() {
    return $jscomp.iteratorFromArray(this, function(c, g) {
      return g;
    });
  };
}, "es8", "es3");
$jscomp.polyfill("Array.prototype.keys", function(y) {
  return y ? y : function() {
    return $jscomp.iteratorFromArray(this, function(c) {
      return c;
    });
  };
}, "es6", "es3");
$jscomp.owns = function(y, c) {
  return Object.prototype.hasOwnProperty.call(y, c);
};
$jscomp.polyfill("Object.values", function(y) {
  return y ? y : function(c) {
    var g = [], n;
    for (n in c) {
      $jscomp.owns(c, n) && g.push(c[n]);
    }
    return g;
  };
}, "es8", "es3");
$jscomp.checkStringArgs = function(y, c, g) {
  if (null == y) {
    throw new TypeError("The 'this' value for String.prototype." + g + " must not be null or undefined");
  }
  if (c instanceof RegExp) {
    throw new TypeError("First argument to String.prototype." + g + " must not be a regular expression");
  }
  return y + "";
};
$jscomp.polyfill("String.prototype.startsWith", function(y) {
  return y ? y : function(c, g) {
    var n = $jscomp.checkStringArgs(this, c, "startsWith");
    c += "";
    var m = n.length, u = c.length;
    g = Math.max(0, Math.min(g | 0, n.length));
    for (var l = 0; l < u && g < m;) {
      if (n[g++] != c[l++]) {
        return !1;
      }
    }
    return l >= u;
  };
}, "es6", "es3");
$jscomp.findInternal = function(y, c, g) {
  y instanceof String && (y = String(y));
  for (var n = y.length, m = 0; m < n; m++) {
    var u = y[m];
    if (c.call(g, u, m, y)) {
      return {i:m, v:u};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill("Array.prototype.findIndex", function(y) {
  return y ? y : function(c, g) {
    return $jscomp.findInternal(this, c, g).i;
  };
}, "es6", "es3");
$jscomp.polyfill("Math.cbrt", function(y) {
  return y ? y : function(c) {
    if (0 === c) {
      return c;
    }
    c = Number(c);
    var g = Math.pow(Math.abs(c), 1 / 3);
    return 0 > c ? -g : g;
  };
}, "es6", "es3");
(function(y) {
  function c(a) {
    e.debug && console.log("Graph created");
    this.list_of_graphcanvas = null;
    this.clear();
    a && this.configure(a);
  }
  function g(a, b, d, f, h, e) {
    this.id = a;
    this.type = b;
    this.origin_id = d;
    this.origin_slot = f;
    this.target_id = h;
    this.target_slot = e;
    this._data = null;
    this._pos = new Float32Array(2);
  }
  function n(a) {
    this._ctor(a);
  }
  function m(a) {
    this._ctor(a);
  }
  function u(a, b) {
    this.offset = new Float32Array([0, 0]);
    this.scale = 1;
    this.max_scale = 10;
    this.min_scale = 0.1;
    this.onredraw = null;
    this.enabled = !0;
    this.last_mouse = [0, 0];
    this.element = null;
    this.visible_area = new Float32Array(4);
    a && (this.element = a, b || this.bindEvents(a));
  }
  function l(a, b, d) {
    this.options = d = d || {};
    this.background_image = l.DEFAULT_BACKGROUND_IMAGE;
    a && a.constructor === String && (a = document.querySelector(a));
    this.ds = new u;
    this.zoom_modify_alpha = !0;
    this.title_text_font = "" + e.NODE_TEXT_SIZE + "px Arial";
    this.inner_text_font = "normal " + e.NODE_SUBTEXT_SIZE + "px Arial";
    this.node_title_color = e.NODE_TITLE_COLOR;
    this.default_link_color = e.LINK_COLOR;
    this.default_connection_color = {input_off:"#778", input_on:"#7F7", output_off:"#778", output_on:"#7F7"};
    this.highquality_render = !0;
    this.use_gradients = !1;
    this.editor_alpha = 1;
    this.pause_rendering = !1;
    this.clear_background = !0;
    this.read_only = !1;
    this.render_only_selected = !0;
    this.live_mode = !1;
    this.allow_searchbox = this.allow_interaction = this.allow_dragnodes = this.allow_dragcanvas = this.show_info = !0;
    this.drag_mode = this.align_to_grid = this.allow_reconnect_links = !1;
    this.filter = this.dragging_rectangle = null;
    this.set_canvas_dirty_on_mouse_event = !0;
    this.always_render_background = !1;
    this.render_canvas_border = this.render_shadows = !0;
    this.render_connections_shadows = !1;
    this.render_connections_border = !0;
    this.render_connection_arrows = this.render_curved_connections = !1;
    this.render_collapsed_slots = !0;
    this.render_execution_order = !1;
    this.render_link_tooltip = this.render_title_colored = !0;
    this.links_render_mode = e.SPLINE_LINK;
    this.mouse = [0, 0];
    this.canvas_mouse = this.graph_mouse = [0, 0];
    this.onAfterChange = this.onBeforeChange = this.onConnectingChange = this.onSelectionChange = this.onNodeMoved = this.onDrawLinkTooltip = this.onDrawOverlay = this.onDrawForeground = this.onDrawBackground = this.onMouse = this.onSearchBoxSelection = this.onSearchBox = null;
    this.connections_width = 3;
    this.round_radius = 8;
    this.over_link_center = this.node_widget = this.current_node = null;
    this.last_mouse_position = [0, 0];
    this.visible_area = this.ds.visible_area;
    this.visible_links = [];
    this.viewport = d.viewport || null;
    b && b.attachCanvas(this);
    this.setCanvas(a, d.skip_events);
    this.clear();
    d.skip_render || this.startRendering();
    this.autoresize = d.autoresize;
  }
  function G(a, b) {
    return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));
  }
  function A(a, b, d, f, h, e) {
    return d < a && d + h > a && f < b && f + e > b ? !0 : !1;
  }
  function D(a, b) {
    var d = a[0] + a[2], f = a[1] + a[3], h = b[1] + b[3];
    return a[0] > b[0] + b[2] || a[1] > h || d < b[0] || f < b[1] ? !1 : !0;
  }
  function B(a, b) {
    function d(a) {
      var d = parseInt(e.style.top);
      e.style.top = (d + a.deltaY * b.scroll_speed).toFixed() + "px";
      a.preventDefault();
      return !0;
    }
    this.options = b = b || {};
    var f = this;
    b.parentMenu && (b.parentMenu.constructor !== this.constructor ? (console.error("parentMenu must be of class ContextMenu, ignoring it"), b.parentMenu = null) : (this.parentMenu = b.parentMenu, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this));
    var h = null;
    b.event && (h = b.event.constructor.name);
    "MouseEvent" !== h && "CustomEvent" !== h && "PointerEvent" !== h && (console.error("Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it."), b.event = null);
    var e = document.createElement("div");
    e.className = "litegraph litecontextmenu litemenubar-panel";
    b.className && (e.className += " " + b.className);
    e.style.minWidth = 100;
    e.style.minHeight = 100;
    e.style.pointerEvents = "none";
    setTimeout(function() {
      e.style.pointerEvents = "auto";
    }, 100);
    e.addEventListener("mouseup", function(a) {
      a.preventDefault();
      return !0;
    }, !0);
    e.addEventListener("contextmenu", function(a) {
      if (2 != a.button) {
        return !1;
      }
      a.preventDefault();
      return !1;
    }, !0);
    e.addEventListener("mousedown", function(a) {
      if (2 == a.button) {
        return f.close(), a.preventDefault(), !0;
      }
    }, !0);
    b.scroll_speed || (b.scroll_speed = 0.1);
    e.addEventListener("wheel", d, !0);
    e.addEventListener("mousewheel", d, !0);
    this.root = e;
    b.title && (h = document.createElement("div"), h.className = "litemenu-title", h.innerHTML = b.title, e.appendChild(h));
    for (var v = h = 0; v < a.length; v++) {
      var r = a.constructor == Array ? a[v] : v;
      null != r && r.constructor !== String && (r = void 0 === r.content ? String(r) : r.content);
      this.addItem(r, a[v], b);
      h++;
    }
    e.addEventListener("mouseleave", function(a) {
      f.lock || (e.closing_timer && clearTimeout(e.closing_timer), e.closing_timer = setTimeout(f.close.bind(f, a), 500));
    });
    e.addEventListener("mouseenter", function(a) {
      e.closing_timer && clearTimeout(e.closing_timer);
    });
    a = document;
    b.event && (a = b.event.target.ownerDocument);
    a || (a = document);
    a.fullscreenElement ? a.fullscreenElement.appendChild(e) : a.body.appendChild(e);
    h = b.left || 0;
    a = b.top || 0;
    b.event && (h = b.event.clientX - 10, a = b.event.clientY - 10, b.title && (a -= 20), b.parentMenu && (h = b.parentMenu.root.getBoundingClientRect(), h = h.left + h.width), v = document.body.getBoundingClientRect(), r = e.getBoundingClientRect(), 0 == v.height && console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }"), v.width && h > v.width - r.width - 10 && (h = v.width - r.width - 10), v.height && a > v.height - r.height - 10 && (a = v.height - r.height - 
    10));
    e.style.left = h + "px";
    e.style.top = a + "px";
    b.scale && (e.style.transform = "scale(" + b.scale + ")");
  }
  function F(a) {
    this.points = a;
    this.nearest = this.selected = -1;
    this.size = null;
    this.must_update = !0;
    this.margin = 5;
  }
  var e = y.LiteGraph = {VERSION:0.4, CANVAS_GRID_SIZE:10, NODE_TITLE_HEIGHT:30, NODE_TITLE_TEXT_Y:20, NODE_SLOT_HEIGHT:20, NODE_WIDGET_HEIGHT:20, NODE_WIDTH:140, NODE_MIN_WIDTH:50, NODE_COLLAPSED_RADIUS:10, NODE_COLLAPSED_WIDTH:80, NODE_TITLE_COLOR:"#999", NODE_SELECTED_TITLE_COLOR:"#FFF", NODE_TEXT_SIZE:14, NODE_TEXT_COLOR:"#AAA", NODE_SUBTEXT_SIZE:12, NODE_DEFAULT_COLOR:"#333", NODE_DEFAULT_BGCOLOR:"#353535", NODE_DEFAULT_BOXCOLOR:"#666", NODE_DEFAULT_SHAPE:"box", NODE_BOX_OUTLINE_COLOR:"#FFF", 
  DEFAULT_SHADOW_COLOR:"rgba(0,0,0,0.5)", DEFAULT_GROUP_FONT:24, WIDGET_BGCOLOR:"#222", WIDGET_OUTLINE_COLOR:"#666", WIDGET_TEXT_COLOR:"#DDD", WIDGET_SECONDARY_TEXT_COLOR:"#999", LINK_COLOR:"#9A9", EVENT_LINK_COLOR:"#A86", CONNECTING_LINK_COLOR:"#AFA", MAX_NUMBER_OF_NODES:1000, DEFAULT_POSITION:[100, 100], VALID_SHAPES:["default", "box", "round", "card"], BOX_SHAPE:1, ROUND_SHAPE:2, CIRCLE_SHAPE:3, CARD_SHAPE:4, ARROW_SHAPE:5, INPUT:1, OUTPUT:2, EVENT:-1, ACTION:-1, ALWAYS:0, ON_EVENT:1, NEVER:2, 
  ON_TRIGGER:3, UP:1, DOWN:2, LEFT:3, RIGHT:4, CENTER:5, STRAIGHT_LINK:0, LINEAR_LINK:1, SPLINE_LINK:2, NORMAL_TITLE:0, NO_TITLE:1, TRANSPARENT_TITLE:2, AUTOHIDE_TITLE:3, proxy:null, node_images_path:"", debug:!1, catch_exceptions:!0, throw_errors:!0, allow_scripts:!1, registered_node_types:{}, node_types_by_file_extension:{}, Nodes:{}, Globals:{}, searchbox_extras:{}, auto_sort_node_types:!1, registerNodeType:function(a, b) {
    if (!b.prototype) {
      throw "Cannot register a simple object, it must be a class with a prototype";
    }
    b.type = a;
    e.debug && console.log("Node registered: " + a);
    a.split("/");
    var d = b.name, f = a.lastIndexOf("/");
    b.category = a.substr(0, f);
    b.title || (b.title = d);
    if (b.prototype) {
      for (var h in n.prototype) {
        b.prototype[h] || (b.prototype[h] = n.prototype[h]);
      }
    }
    if (f = this.registered_node_types[a]) {
      console.log("replacing node type: " + a);
    } else {
      if (Object.hasOwnProperty(b.prototype, "shape") || Object.defineProperty(b.prototype, "shape", {set:function(a) {
        switch(a) {
          case "default":
            delete this._shape;
            break;
          case "box":
            this._shape = e.BOX_SHAPE;
            break;
          case "round":
            this._shape = e.ROUND_SHAPE;
            break;
          case "circle":
            this._shape = e.CIRCLE_SHAPE;
            break;
          case "card":
            this._shape = e.CARD_SHAPE;
            break;
          default:
            this._shape = a;
        }
      }, get:function(a) {
        return this._shape;
      }, enumerable:!0, configurable:!0}), b.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end"), b.supported_extensions) {
        for (h in b.supported_extensions) {
          var w = b.supported_extensions[h];
          w && w.constructor === String && (this.node_types_by_file_extension[w.toLowerCase()] = b);
        }
      }
    }
    this.registered_node_types[a] = b;
    b.constructor.name && (this.Nodes[d] = b);
    if (e.onNodeTypeRegistered) {
      e.onNodeTypeRegistered(a, b);
    }
    if (f && e.onNodeTypeReplaced) {
      e.onNodeTypeReplaced(a, b, f);
    }
    b.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end");
    if (b.supported_extensions) {
      for (h = 0; h < b.supported_extensions.length; h++) {
        (w = b.supported_extensions[h]) && w.constructor === String && (this.node_types_by_file_extension[w.toLowerCase()] = b);
      }
    }
  }, unregisterNodeType:function(a) {
    var b = a.constructor === String ? this.registered_node_types[a] : a;
    if (!b) {
      throw "node type not found: " + a;
    }
    delete this.registered_node_types[b.type];
    b.constructor.name && delete this.Nodes[b.constructor.name];
  }, wrapFunctionAsNode:function(a, b, d, f, h) {
    for (var w = Array(b.length), v = "", r = e.getParameterNames(b), c = 0; c < r.length; ++c) {
      v += "this.addInput('" + r[c] + "'," + (d && d[c] ? "'" + d[c] + "'" : "0") + ");\n";
    }
    v += "this.addOutput('out'," + (f ? "'" + f + "'" : 0) + ");\n";
    h && (v += "this.properties = " + JSON.stringify(h) + ";\n");
    d = Function(v);
    d.title = a.split("/").pop();
    d.desc = "Generated from " + b.name;
    d.prototype.onExecute = function() {
      for (var a = 0; a < w.length; ++a) {
        w[a] = this.getInputData(a);
      }
      a = b.apply(this, w);
      this.setOutputData(0, a);
    };
    this.registerNodeType(a, d);
  }, clearRegisteredTypes:function() {
    this.registered_node_types = {};
    this.node_types_by_file_extension = {};
    this.Nodes = {};
    this.searchbox_extras = {};
  }, addNodeMethod:function(a, b) {
    n.prototype[a] = b;
    for (var d in this.registered_node_types) {
      var f = this.registered_node_types[d];
      f.prototype[a] && (f.prototype["_" + a] = f.prototype[a]);
      f.prototype[a] = b;
    }
  }, createNode:function(a, b, d) {
    var f = this.registered_node_types[a];
    if (!f) {
      return e.debug && console.log('GraphNode type "' + a + '" not registered.'), null;
    }
    b = b || f.title || a;
    var h = null;
    if (e.catch_exceptions) {
      try {
        h = new f(b);
      } catch (v) {
        return console.error(v), null;
      }
    } else {
      h = new f(b);
    }
    h.type = a;
    !h.title && b && (h.title = b);
    h.properties || (h.properties = {});
    h.properties_info || (h.properties_info = []);
    h.flags || (h.flags = {});
    h.size || (h.size = h.computeSize());
    h.pos || (h.pos = e.DEFAULT_POSITION.concat());
    h.mode || (h.mode = e.ALWAYS);
    if (d) {
      for (var w in d) {
        h[w] = d[w];
      }
    }
    return h;
  }, getNodeType:function(a) {
    return this.registered_node_types[a];
  }, getNodeTypesInCategory:function(a, b) {
    var d = [], f;
    for (f in this.registered_node_types) {
      var h = this.registered_node_types[f];
      h.filter == b && ("" == a ? null == h.category && d.push(h) : h.category == a && d.push(h));
    }
    this.auto_sort_node_types && d.sort(function(a, b) {
      return a.title.localeCompare(b.title);
    });
    return d;
  }, getNodeTypesCategories:function(a) {
    var b = {"":1}, d;
    for (d in this.registered_node_types) {
      var f = this.registered_node_types[d];
      f.category && !f.skip_list && f.filter == a && (b[f.category] = 1);
    }
    a = [];
    for (d in b) {
      a.push(d);
    }
    return this.auto_sort_node_types ? a.sort() : a;
  }, reloadNodes:function(a) {
    for (var b = document.getElementsByTagName("script"), d = [], f = 0; f < b.length; f++) {
      d.push(b[f]);
    }
    b = document.getElementsByTagName("head")[0];
    a = document.location.href + a;
    for (f = 0; f < d.length; f++) {
      var h = d[f].src;
      if (h && h.substr(0, a.length) == a) {
        try {
          e.debug && console.log("Reloading: " + h);
          var w = document.createElement("script");
          w.type = "text/javascript";
          w.src = h;
          b.appendChild(w);
          b.removeChild(d[f]);
        } catch (v) {
          if (e.throw_errors) {
            throw v;
          }
          e.debug && console.log("Error while reloading " + h);
        }
      }
    }
    e.debug && console.log("Nodes reloaded");
  }, cloneObject:function(a, b) {
    if (null == a) {
      return null;
    }
    a = JSON.parse(JSON.stringify(a));
    if (!b) {
      return a;
    }
    for (var d in a) {
      b[d] = a[d];
    }
    return b;
  }, isValidConnection:function(a, b) {
    if (!a || !b || a == b || a == e.EVENT && b == e.ACTION) {
      return !0;
    }
    a = String(a);
    b = String(b);
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (-1 == a.indexOf(",") && -1 == b.indexOf(",")) {
      return a == b;
    }
    a = a.split(",");
    b = b.split(",");
    for (var d = 0; d < a.length; ++d) {
      for (var f = 0; f < b.length; ++f) {
        if (a[d] == b[f]) {
          return !0;
        }
      }
    }
    return !1;
  }, registerSearchboxExtra:function(a, b, d) {
    this.searchbox_extras[b.toLowerCase()] = {type:a, desc:b, data:d};
  }, fetchFile:function(a, b, d, f) {
    if (!a) {
      return null;
    }
    b = b || "text";
    if (a.constructor === String) {
      return "http" == a.substr(0, 4) && e.proxy && (a = e.proxy + a.substr(a.indexOf(":") + 3)), fetch(a).then(function(a) {
        if (!a.ok) {
          throw Error("File not found");
        }
        if ("arraybuffer" == b) {
          return a.arrayBuffer();
        }
        if ("text" == b || "string" == b) {
          return a.text();
        }
        if ("json" == b) {
          return a.json();
        }
        if ("blob" == b) {
          return a.blob();
        }
      }).then(function(a) {
        d && d(a);
      }).catch(function(b) {
        console.error("error fetching file:", a);
        f && f(b);
      });
    }
    if (a.constructor === File || a.constructor === Blob) {
      var h = new FileReader;
      h.onload = function(a) {
        a = a.target.result;
        "json" == b && (a = JSON.parse(a));
        d && d(a);
      };
      if ("arraybuffer" == b) {
        return h.readAsArrayBuffer(a);
      }
      if ("text" == b || "json" == b) {
        return h.readAsText(a);
      }
      if ("blob" == b) {
        return h.readAsBinaryString(a);
      }
    }
    return null;
  }};
  e.getTime = "undefined" != typeof performance ? performance.now.bind(performance) : "undefined" != typeof Date && Date.now ? Date.now.bind(Date) : "undefined" != typeof process ? function() {
    var a = process.hrtime();
    return 0.001 * a[0] + 1e-6 * a[1];
  } : function() {
    return (new Date).getTime();
  };
  y.LGraph = e.LGraph = c;
  c.supported_types = ["number", "string", "boolean"];
  c.prototype.getSupportedTypes = function() {
    return this.supported_types || c.supported_types;
  };
  c.STATUS_STOPPED = 1;
  c.STATUS_RUNNING = 2;
  c.prototype.clear = function() {
    this.stop();
    this.status = c.STATUS_STOPPED;
    this.last_link_id = this.last_node_id = 0;
    this._version = -1;
    if (this._nodes) {
      for (var a = 0; a < this._nodes.length; ++a) {
        var b = this._nodes[a];
        if (b.onRemoved) {
          b.onRemoved();
        }
      }
    }
    this._nodes = [];
    this._nodes_by_id = {};
    this._nodes_in_order = [];
    this._nodes_executable = null;
    this._groups = [];
    this.links = {};
    this.iteration = 0;
    this.config = {};
    this.vars = {};
    this.extra = {};
    this.fixedtime = this.runningtime = this.globaltime = 0;
    this.elapsed_time = this.fixedtime_lapse = 0.01;
    this.starttime = this.last_update_time = 0;
    this.catch_errors = !0;
    this.inputs = {};
    this.outputs = {};
    this.change();
    this.sendActionToCanvas("clear");
  };
  c.prototype.attachCanvas = function(a) {
    if (a.constructor != l) {
      throw "attachCanvas expects a LGraphCanvas instance";
    }
    a.graph && a.graph != this && a.graph.detachCanvas(a);
    a.graph = this;
    this.list_of_graphcanvas || (this.list_of_graphcanvas = []);
    this.list_of_graphcanvas.push(a);
  };
  c.prototype.detachCanvas = function(a) {
    if (this.list_of_graphcanvas) {
      var b = this.list_of_graphcanvas.indexOf(a);
      -1 != b && (a.graph = null, this.list_of_graphcanvas.splice(b, 1));
    }
  };
  c.prototype.start = function(a) {
    if (this.status != c.STATUS_RUNNING) {
      this.status = c.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.last_update_time = this.starttime = e.getTime();
      a = a || 0;
      var b = this;
      if (0 == a && "undefined" != typeof window && window.requestAnimationFrame) {
        var d = function() {
          if (-1 == b.execution_timer_id) {
            window.requestAnimationFrame(d);
            if (b.onBeforeStep) {
              b.onBeforeStep();
            }
            b.runStep(1, !b.catch_errors);
            if (b.onAfterStep) {
              b.onAfterStep();
            }
          }
        };
        this.execution_timer_id = -1;
        d();
      } else {
        this.execution_timer_id = setInterval(function() {
          if (b.onBeforeStep) {
            b.onBeforeStep();
          }
          b.runStep(1, !b.catch_errors);
          if (b.onAfterStep) {
            b.onAfterStep();
          }
        }, a);
      }
    }
  };
  c.prototype.stop = function() {
    if (this.status != c.STATUS_STOPPED) {
      this.status = c.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      null != this.execution_timer_id && (-1 != this.execution_timer_id && clearInterval(this.execution_timer_id), this.execution_timer_id = null);
      this.sendEventToAllNodes("onStop");
    }
  };
  c.prototype.runStep = function(a, b, d) {
    a = a || 1;
    var f = e.getTime();
    this.globaltime = 0.001 * (f - this.starttime);
    var h = this._nodes_executable ? this._nodes_executable : this._nodes;
    if (h) {
      d = d || h.length;
      if (b) {
        for (var w = 0; w < a; w++) {
          for (var v = 0; v < d; ++v) {
            var r = h[v];
            if (r.mode == e.ALWAYS && r.onExecute) {
              r.onExecute();
            }
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (w = 0; w < a; w++) {
            for (v = 0; v < d; ++v) {
              if (r = h[v], r.mode == e.ALWAYS && r.onExecute) {
                r.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = !1;
        } catch (N) {
          this.errors_in_execution = !0;
          if (e.throw_errors) {
            throw N;
          }
          e.debug && console.log("Error during execution: " + N);
          this.stop();
        }
      }
      a = e.getTime();
      f = a - f;
      0 == f && (f = 1);
      this.execution_time = 0.001 * f;
      this.globaltime += 0.001 * f;
      this.iteration += 1;
      this.elapsed_time = 0.001 * (a - this.last_update_time);
      this.last_update_time = a;
    }
  };
  c.prototype.updateExecutionOrder = function() {
    this._nodes_in_order = this.computeExecutionOrder(!1);
    this._nodes_executable = [];
    for (var a = 0; a < this._nodes_in_order.length; ++a) {
      this._nodes_in_order[a].onExecute && this._nodes_executable.push(this._nodes_in_order[a]);
    }
  };
  c.prototype.computeExecutionOrder = function(a, b) {
    for (var d = [], f = [], h = {}, w = {}, v = {}, r = 0, c = this._nodes.length; r < c; ++r) {
      var k = this._nodes[r];
      if (!a || k.onExecute) {
        h[k.id] = k;
        var t = 0;
        if (k.inputs) {
          for (var q = 0, J = k.inputs.length; q < J; q++) {
            k.inputs[q] && null != k.inputs[q].links && 0 != k.inputs[q].links.length && (t += 1);
          }
        }
        0 == t ? (f.push(k), b && (k._level = 1)) : (b && (k._level = 0), v[k.id] = t);
      }
    }
    for (; 0 != f.length;) {
      if (k = f.shift(), d.push(k), delete h[k.id], k.outputs) {
        for (r = 0; r < k.outputs.length; r++) {
          if (a = k.outputs[r], null != a && null != a.links && 0 != a.links.length) {
            for (q = 0; q < a.links.length; q++) {
              (c = this.links[a.links[q]]) && !w[c.id] && (t = this.getNodeById(c.target_id), null == t ? w[c.id] = !0 : (b && (!t._level || t._level <= k._level) && (t._level = k._level + 1), w[c.id] = !0, --v[t.id], 0 == v[t.id] && f.push(t)));
            }
          }
        }
      }
    }
    for (r in h) {
      d.push(h[r]);
    }
    d.length != this._nodes.length && e.debug && console.warn("something went wrong, nodes missing");
    c = d.length;
    for (r = 0; r < c; ++r) {
      d[r].order = r;
    }
    d = d.sort(function(a, b) {
      var d = a.constructor.priority || a.priority || 0, f = b.constructor.priority || b.priority || 0;
      return d == f ? a.order - b.order : d - f;
    });
    for (r = 0; r < c; ++r) {
      d[r].order = r;
    }
    return d;
  };
  c.prototype.getAncestors = function(a) {
    for (var b = [], d = [a], f = {}; d.length;) {
      var h = d.shift();
      if (h.inputs) {
        f[h.id] || h == a || (f[h.id] = !0, b.push(h));
        for (var e = 0; e < h.inputs.length; ++e) {
          var v = h.getInputNode(e);
          v && -1 == b.indexOf(v) && d.push(v);
        }
      }
    }
    b.sort(function(a, b) {
      return a.order - b.order;
    });
    return b;
  };
  c.prototype.arrange = function(a) {
    a = a || 100;
    for (var b = this.computeExecutionOrder(!1, !0), d = [], f = 0; f < b.length; ++f) {
      var h = b[f], w = h._level || 1;
      d[w] || (d[w] = []);
      d[w].push(h);
    }
    b = a;
    for (f = 0; f < d.length; ++f) {
      if (w = d[f]) {
        for (var v = 100, r = a + e.NODE_TITLE_HEIGHT, c = 0; c < w.length; ++c) {
          h = w[c], h.pos[0] = b, h.pos[1] = r, h.size[0] > v && (v = h.size[0]), r += h.size[1] + a + e.NODE_TITLE_HEIGHT;
        }
        b += v + a;
      }
    }
    this.setDirtyCanvas(!0, !0);
  };
  c.prototype.getTime = function() {
    return this.globaltime;
  };
  c.prototype.getFixedTime = function() {
    return this.fixedtime;
  };
  c.prototype.getElapsedTime = function() {
    return this.elapsed_time;
  };
  c.prototype.sendEventToAllNodes = function(a, b, d) {
    d = d || e.ALWAYS;
    var f = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (f) {
      for (var h = 0, w = f.length; h < w; ++h) {
        var v = f[h];
        if (v.constructor === e.Subgraph && "onExecute" != a) {
          v.mode == d && v.sendEventToAllNodes(a, b, d);
        } else {
          if (v[a] && v.mode == d) {
            if (void 0 === b) {
              v[a]();
            } else {
              if (b && b.constructor === Array) {
                v[a].apply(v, b);
              } else {
                v[a](b);
              }
            }
          }
        }
      }
    }
  };
  c.prototype.sendActionToCanvas = function(a, b) {
    if (this.list_of_graphcanvas) {
      for (var d = 0; d < this.list_of_graphcanvas.length; ++d) {
        var f = this.list_of_graphcanvas[d];
        f[a] && f[a].apply(f, b);
      }
    }
  };
  c.prototype.add = function(a, b) {
    if (a) {
      if (a.constructor === m) {
        this._groups.push(a), this.setDirtyCanvas(!0), this.change(), a.graph = this, this._version++;
      } else {
        -1 != a.id && null != this._nodes_by_id[a.id] && (console.warn("LiteGraph: there is already a node with this ID, changing it"), a.id = ++this.last_node_id);
        if (this._nodes.length >= e.MAX_NUMBER_OF_NODES) {
          throw "LiteGraph: max number of nodes in a graph reached";
        }
        null == a.id || -1 == a.id ? a.id = ++this.last_node_id : this.last_node_id < a.id && (this.last_node_id = a.id);
        a.graph = this;
        this._version++;
        this._nodes.push(a);
        this._nodes_by_id[a.id] = a;
        if (a.onAdded) {
          a.onAdded(this);
        }
        this.config.align_to_grid && a.alignToGrid();
        b || this.updateExecutionOrder();
        if (this.onNodeAdded) {
          this.onNodeAdded(a);
        }
        this.setDirtyCanvas(!0);
        this.change();
        return a;
      }
    }
  };
  c.prototype.remove = function(a) {
    if (a.constructor === e.LGraphGroup) {
      var b = this._groups.indexOf(a);
      -1 != b && this._groups.splice(b, 1);
      a.graph = null;
      this._version++;
      this.setDirtyCanvas(!0, !0);
      this.change();
    } else {
      if (null != this._nodes_by_id[a.id] && !a.ignore_remove) {
        this.beforeChange();
        if (a.inputs) {
          for (b = 0; b < a.inputs.length; b++) {
            var d = a.inputs[b];
            null != d.links && d.links.length && a.disconnectInput(b);
          }
        }
        if (a.outputs) {
          for (b = 0; b < a.outputs.length; b++) {
            d = a.outputs[b], null != d.links && d.links.length && a.disconnectOutput(b);
          }
        }
        if (a.onRemoved) {
          a.onRemoved();
        }
        a.graph = null;
        this._version++;
        if (this.list_of_graphcanvas) {
          for (b = 0; b < this.list_of_graphcanvas.length; ++b) {
            d = this.list_of_graphcanvas[b], d.selected_nodes[a.id] && delete d.selected_nodes[a.id], d.node_dragged == a && (d.node_dragged = null);
          }
        }
        b = this._nodes.indexOf(a);
        -1 != b && this._nodes.splice(b, 1);
        delete this._nodes_by_id[a.id];
        if (this.onNodeRemoved) {
          this.onNodeRemoved(a);
        }
        this.sendActionToCanvas("checkPanels");
        this.setDirtyCanvas(!0, !0);
        this.afterChange();
        this.change();
        this.updateExecutionOrder();
      }
    }
  };
  c.prototype.getNodeById = function(a) {
    return null == a ? null : this._nodes_by_id[a];
  };
  c.prototype.findNodesByClass = function(a, b) {
    b = b || [];
    for (var d = b.length = 0, f = this._nodes.length; d < f; ++d) {
      this._nodes[d].constructor === a && b.push(this._nodes[d]);
    }
    return b;
  };
  c.prototype.findNodesByType = function(a, b) {
    a = a.toLowerCase();
    b = b || [];
    for (var d = b.length = 0, f = this._nodes.length; d < f; ++d) {
      this._nodes[d].type.toLowerCase() == a && b.push(this._nodes[d]);
    }
    return b;
  };
  c.prototype.findNodeByTitle = function(a) {
    for (var b = 0, d = this._nodes.length; b < d; ++b) {
      if (this._nodes[b].title == a) {
        return this._nodes[b];
      }
    }
    return null;
  };
  c.prototype.findNodesByTitle = function(a) {
    for (var b = [], d = 0, f = this._nodes.length; d < f; ++d) {
      this._nodes[d].title == a && b.push(this._nodes[d]);
    }
    return b;
  };
  c.prototype.getNodeOnPos = function(a, b, d, f) {
    d = d || this._nodes;
    for (var h = d.length - 1; 0 <= h; h--) {
      var e = d[h];
      if (e.isPointInside(a, b, f)) {
        return e;
      }
    }
    return null;
  };
  c.prototype.getGroupOnPos = function(a, b) {
    for (var d = this._groups.length - 1; 0 <= d; d--) {
      var f = this._groups[d];
      if (f.isPointInside(a, b, 2, !0)) {
        return f;
      }
    }
    return null;
  };
  c.prototype.checkNodeTypes = function() {
    for (var a = 0; a < this._nodes.length; a++) {
      var b = this._nodes[a];
      if (b.constructor != e.registered_node_types[b.type]) {
        console.log("node being replaced by newer version: " + b.type);
        var d = e.createNode(b.type);
        this._nodes[a] = d;
        d.configure(b.serialize());
        d.graph = this;
        this._nodes_by_id[d.id] = d;
        b.inputs && (d.inputs = b.inputs.concat());
        b.outputs && (d.outputs = b.outputs.concat());
      }
    }
    this.updateExecutionOrder();
  };
  c.prototype.onAction = function(a, b) {
    this._input_nodes = this.findNodesByClass(e.GraphInput, this._input_nodes);
    for (var d = 0; d < this._input_nodes.length; ++d) {
      var f = this._input_nodes[d];
      if (f.properties.name == a) {
        f.onAction(a, b);
        break;
      }
    }
  };
  c.prototype.trigger = function(a, b) {
    if (this.onTrigger) {
      this.onTrigger(a, b);
    }
  };
  c.prototype.addInput = function(a, b, d) {
    if (!this.inputs[a]) {
      this.beforeChange();
      this.inputs[a] = {name:a, type:b, value:d};
      this._version++;
      this.afterChange();
      if (this.onInputAdded) {
        this.onInputAdded(a, b);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
  };
  c.prototype.setInputData = function(a, b) {
    if (a = this.inputs[a]) {
      a.value = b;
    }
  };
  c.prototype.getInputData = function(a) {
    return (a = this.inputs[a]) ? a.value : null;
  };
  c.prototype.renameInput = function(a, b) {
    if (b != a) {
      if (!this.inputs[a]) {
        return !1;
      }
      if (this.inputs[b]) {
        return console.error("there is already one input with that name"), !1;
      }
      this.inputs[b] = this.inputs[a];
      delete this.inputs[a];
      this._version++;
      if (this.onInputRenamed) {
        this.onInputRenamed(a, b);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
  };
  c.prototype.changeInputType = function(a, b) {
    if (!this.inputs[a]) {
      return !1;
    }
    if (!this.inputs[a].type || String(this.inputs[a].type).toLowerCase() != String(b).toLowerCase()) {
      if (this.inputs[a].type = b, this._version++, this.onInputTypeChanged) {
        this.onInputTypeChanged(a, b);
      }
    }
  };
  c.prototype.removeInput = function(a) {
    if (!this.inputs[a]) {
      return !1;
    }
    delete this.inputs[a];
    this._version++;
    if (this.onInputRemoved) {
      this.onInputRemoved(a);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
    return !0;
  };
  c.prototype.addOutput = function(a, b, d) {
    this.outputs[a] = {name:a, type:b, value:d};
    this._version++;
    if (this.onOutputAdded) {
      this.onOutputAdded(a, b);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
  };
  c.prototype.setOutputData = function(a, b) {
    if (a = this.outputs[a]) {
      a.value = b;
    }
  };
  c.prototype.getOutputData = function(a) {
    return (a = this.outputs[a]) ? a.value : null;
  };
  c.prototype.renameOutput = function(a, b) {
    if (!this.outputs[a]) {
      return !1;
    }
    if (this.outputs[b]) {
      return console.error("there is already one output with that name"), !1;
    }
    this.outputs[b] = this.outputs[a];
    delete this.outputs[a];
    this._version++;
    if (this.onOutputRenamed) {
      this.onOutputRenamed(a, b);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
  };
  c.prototype.changeOutputType = function(a, b) {
    if (!this.outputs[a]) {
      return !1;
    }
    if (!this.outputs[a].type || String(this.outputs[a].type).toLowerCase() != String(b).toLowerCase()) {
      if (this.outputs[a].type = b, this._version++, this.onOutputTypeChanged) {
        this.onOutputTypeChanged(a, b);
      }
    }
  };
  c.prototype.removeOutput = function(a) {
    if (!this.outputs[a]) {
      return !1;
    }
    delete this.outputs[a];
    this._version++;
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
    return !0;
  };
  c.prototype.triggerInput = function(a, b) {
    a = this.findNodesByTitle(a);
    for (var d = 0; d < a.length; ++d) {
      a[d].onTrigger(b);
    }
  };
  c.prototype.setCallback = function(a, b) {
    a = this.findNodesByTitle(a);
    for (var d = 0; d < a.length; ++d) {
      a[d].setTrigger(b);
    }
  };
  c.prototype.beforeChange = function(a) {
    if (this.onBeforeChange) {
      this.onBeforeChange(this, a);
    }
    this.sendActionToCanvas("onBeforeChange", this);
  };
  c.prototype.afterChange = function(a) {
    if (this.onAfterChange) {
      this.onAfterChange(this, a);
    }
    this.sendActionToCanvas("onAfterChange", this);
  };
  c.prototype.connectionChange = function(a, b) {
    this.updateExecutionOrder();
    if (this.onConnectionChange) {
      this.onConnectionChange(a);
    }
    this._version++;
    this.sendActionToCanvas("onConnectionChange");
  };
  c.prototype.isLive = function() {
    if (!this.list_of_graphcanvas) {
      return !1;
    }
    for (var a = 0; a < this.list_of_graphcanvas.length; ++a) {
      if (this.list_of_graphcanvas[a].live_mode) {
        return !0;
      }
    }
    return !1;
  };
  c.prototype.clearTriggeredSlots = function() {
    for (var a in this.links) {
      var b = this.links[a];
      b && b._last_time && (b._last_time = 0);
    }
  };
  c.prototype.change = function() {
    e.debug && console.log("Graph changed");
    this.sendActionToCanvas("setDirty", [!0, !0]);
    if (this.on_change) {
      this.on_change(this);
    }
  };
  c.prototype.setDirtyCanvas = function(a, b) {
    this.sendActionToCanvas("setDirty", [a, b]);
  };
  c.prototype.removeLink = function(a) {
    if (a = this.links[a]) {
      var b = this.getNodeById(a.target_id);
      b && b.disconnectInput(a.target_slot);
    }
  };
  c.prototype.serialize = function() {
    for (var a = [], b = 0, d = this._nodes.length; b < d; ++b) {
      a.push(this._nodes[b].serialize());
    }
    d = [];
    for (b in this.links) {
      var f = this.links[b];
      if (!f.serialize) {
        console.warn("weird LLink bug, link info is not a LLink but a regular object");
        var h = new g;
        for (w in f) {
          h[w] = f[w];
        }
        f = this.links[b] = h;
      }
      d.push(f.serialize());
    }
    var w = [];
    for (b = 0; b < this._groups.length; ++b) {
      w.push(this._groups[b].serialize());
    }
    a = {last_node_id:this.last_node_id, last_link_id:this.last_link_id, nodes:a, links:d, groups:w, config:this.config, extra:this.extra, version:e.VERSION};
    if (this.onSerialize) {
      this.onSerialize(a);
    }
    return a;
  };
  c.prototype.configure = function(a, b) {
    if (a) {
      b || this.clear();
      b = a.nodes;
      if (a.links && a.links.constructor === Array) {
        for (var d = [], f = 0; f < a.links.length; ++f) {
          var h = a.links[f];
          if (h) {
            var w = new g;
            w.configure(h);
            d[w.id] = w;
          } else {
            console.warn("serialized graph link data contains errors, skipping.");
          }
        }
        a.links = d;
      }
      for (f in a) {
        "nodes" != f && "groups" != f && (this[f] = a[f]);
      }
      d = !1;
      this._nodes = [];
      if (b) {
        f = 0;
        for (h = b.length; f < h; ++f) {
          w = b[f];
          var v = e.createNode(w.type, w.title);
          v || (e.debug && console.log("Node not found or has errors: " + w.type), v = new n, v.last_serialization = w, d = v.has_errors = !0);
          v.id = w.id;
          this.add(v, !0);
        }
        f = 0;
        for (h = b.length; f < h; ++f) {
          w = b[f], (v = this.getNodeById(w.id)) && v.configure(w);
        }
      }
      this._groups.length = 0;
      if (a.groups) {
        for (f = 0; f < a.groups.length; ++f) {
          b = new e.LGraphGroup, b.configure(a.groups[f]), this.add(b);
        }
      }
      this.updateExecutionOrder();
      this.extra = a.extra || {};
      if (this.onConfigure) {
        this.onConfigure(a);
      }
      this._version++;
      this.setDirtyCanvas(!0, !0);
      return d;
    }
  };
  c.prototype.load = function(a, b) {
    var d = this;
    if (a.constructor === File || a.constructor === Blob) {
      var f = new FileReader;
      f.addEventListener("load", function(a) {
        a = JSON.parse(a.target.result);
        d.configure(a);
        b && b();
      });
      f.readAsText(a);
    } else {
      var h = new XMLHttpRequest;
      h.open("GET", a, !0);
      h.send(null);
      h.onload = function(a) {
        200 !== h.status ? console.error("Error loading graph:", h.status, h.response) : (a = JSON.parse(h.response), d.configure(a), b && b());
      };
      h.onerror = function(a) {
        console.error("Error loading graph:", a);
      };
    }
  };
  c.prototype.onNodeTrace = function(a, b, d) {
  };
  g.prototype.configure = function(a) {
    a.constructor === Array ? (this.id = a[0], this.origin_id = a[1], this.origin_slot = a[2], this.target_id = a[3], this.target_slot = a[4], this.type = a[5]) : (this.id = a.id, this.type = a.type, this.origin_id = a.origin_id, this.origin_slot = a.origin_slot, this.target_id = a.target_id, this.target_slot = a.target_slot);
  };
  g.prototype.serialize = function() {
    return [this.id, this.origin_id, this.origin_slot, this.target_id, this.target_slot, this.type];
  };
  e.LLink = g;
  y.LGraphNode = e.LGraphNode = n;
  n.prototype._ctor = function(a) {
    this.title = a || "Unnamed";
    this.size = [e.NODE_WIDTH, 60];
    this.graph = null;
    this._pos = new Float32Array(10, 10);
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    this.id = -1;
    this.type = null;
    this.inputs = [];
    this.outputs = [];
    this.connections = [];
    this.properties = {};
    this.properties_info = [];
    this.flags = {};
  };
  n.prototype.configure = function(a) {
    this.graph && this.graph._version++;
    for (var b in a) {
      if ("properties" == b) {
        for (var d in a.properties) {
          if (this.properties[d] = a.properties[d], this.onPropertyChanged) {
            this.onPropertyChanged(d, a.properties[d]);
          }
        }
      } else {
        null != a[b] && ("object" == typeof a[b] ? this[b] && this[b].configure ? this[b].configure(a[b]) : this[b] = e.cloneObject(a[b], this[b]) : this[b] = a[b]);
      }
    }
    a.title || (this.title = this.constructor.title);
    if (this.onConnectionsChange) {
      if (this.inputs) {
        for (d = 0; d < this.inputs.length; ++d) {
          var f = this.inputs[d];
          if (f.links) {
            for (b = 0; b < f.links.length; ++b) {
              var h = this.graph ? this.graph.links[f.links[b]] : null;
              this.onConnectionsChange(e.INPUT, d, !0, h, f);
            }
          }
        }
      }
      if (this.outputs) {
        for (d = 0; d < this.outputs.length; ++d) {
          if (f = this.outputs[d], f.links) {
            for (b = 0; b < f.links.length; ++b) {
              h = this.graph ? this.graph.links[f.links[b]] : null, this.onConnectionsChange(e.OUTPUT, d, !0, h, f);
            }
          }
        }
      }
    }
    if (this.widgets) {
      for (d = 0; d < this.widgets.length; ++d) {
        (b = this.widgets[d]) && b.options && b.options.property && this.properties[b.options.property] && (b.value = JSON.parse(JSON.stringify(this.properties[b.options.property])));
      }
      if (a.widgets_values) {
        for (d = 0; d < a.widgets_values.length; ++d) {
          this.widgets[d] && (this.widgets[d].value = a.widgets_values[d]);
        }
      }
    }
    if (this.onConfigure) {
      this.onConfigure(a);
    }
  };
  n.prototype.serialize = function() {
    var a = {id:this.id, type:this.type, pos:this.pos, size:this.size, flags:e.cloneObject(this.flags), order:this.order, mode:this.mode};
    if (this.constructor === n && this.last_serialization) {
      return this.last_serialization;
    }
    this.inputs && (a.inputs = this.inputs);
    if (this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        delete this.outputs[b]._data;
      }
      a.outputs = this.outputs;
    }
    this.title && this.title != this.constructor.title && (a.title = this.title);
    this.properties && (a.properties = e.cloneObject(this.properties));
    if (this.widgets && this.serialize_widgets) {
      for (a.widgets_values = [], b = 0; b < this.widgets.length; ++b) {
        a.widgets_values[b] = this.widgets[b] ? this.widgets[b].value : null;
      }
    }
    a.type || (a.type = this.constructor.type);
    this.color && (a.color = this.color);
    this.bgcolor && (a.bgcolor = this.bgcolor);
    this.boxcolor && (a.boxcolor = this.boxcolor);
    this.shape && (a.shape = this.shape);
    this.onSerialize && this.onSerialize(a) && console.warn("node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter");
    return a;
  };
  n.prototype.clone = function() {
    var a = e.createNode(this.type);
    if (!a) {
      return null;
    }
    var b = e.cloneObject(this.serialize());
    if (b.inputs) {
      for (var d = 0; d < b.inputs.length; ++d) {
        b.inputs[d].links && (b.inputs[d].links.length = 0);
      }
    }
    if (b.outputs) {
      for (d = 0; d < b.outputs.length; ++d) {
        b.outputs[d].links && (b.outputs[d].links.length = 0);
      }
    }
    delete b.id;
    a.configure(b);
    return a;
  };
  n.prototype.toString = function() {
    return JSON.stringify(this.serialize());
  };
  n.prototype.getTitle = function() {
    return this.title || this.constructor.title;
  };
  n.prototype.setProperty = function(a, b) {
    this.properties || (this.properties = {});
    if (b !== this.properties[a]) {
      var d = this.properties[a];
      this.properties[a] = b;
      this.onPropertyChanged && !1 === this.onPropertyChanged(a, b, d) && (this.properties[a] = d);
      if (this.widgets) {
        for (d = 0; d < this.widgets.length; ++d) {
          var f = this.widgets[d];
          if (f && f.options.property == a) {
            f.value = b;
            break;
          }
        }
      }
    }
  };
  n.prototype.setOutputData = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var d = this.outputs[a];
      if (d && (d._data = b, this.outputs[a].links)) {
        for (d = 0; d < this.outputs[a].links.length; d++) {
          var f = this.graph.links[this.outputs[a].links[d]];
          f && (f.data = b);
        }
      }
    }
  };
  n.prototype.setOutputDataType = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var d = this.outputs[a];
      if (d && (d.type = b, this.outputs[a].links)) {
        for (d = 0; d < this.outputs[a].links.length; d++) {
          this.graph.links[this.outputs[a].links[d]].type = b;
        }
      }
    }
  };
  n.prototype.getInputData = function(a, b) {
    if (this.inputs && !(a >= this.inputs.length || null == this.inputs[a].links || 0 == this.inputs[a].links.length)) {
      var d = [];
      a = this.inputs[a].links;
      for (var f = 0; f < a.length; f++) {
        var h = this.graph.links[a[f]];
        if (!h) {
          return null;
        }
        if (!b) {
          return h.data;
        }
        var e = this.graph.getNodeById(h.origin_id);
        if (e) {
          if (d.push(h.data), e.updateOutputData) {
            e.updateOutputData(h.origin_slot);
          } else {
            if (e.onExecute) {
              e.onExecute();
            }
          }
        }
      }
      return d;
    }
  };
  n.prototype.getInputDataType = function(a) {
    if (!this.inputs || a >= this.inputs.length || null == this.inputs[a].links || 0 == this.inputs[a].links.length) {
      return null;
    }
    a = this.graph.links[this.inputs[a].links[0]];
    if (!a) {
      return null;
    }
    var b = this.graph.getNodeById(a.origin_id);
    return b ? (a = b.outputs[a.origin_slot]) ? a.type : null : a.type;
  };
  n.prototype.getInputDataByName = function(a, b) {
    a = this.findInputSlot(a);
    return -1 == a ? null : this.getInputData(a, b);
  };
  n.prototype.isInputConnected = function(a) {
    return this.inputs ? a < this.inputs.length && null != this.inputs[a].links && 0 != this.inputs[a].links.length : !1;
  };
  n.prototype.getInputInfo = function(a) {
    return this.inputs ? a < this.inputs.length ? this.inputs[a] : null : null;
  };
  n.prototype.getInputLinks = function(a) {
    if (!this.inputs) {
      return null;
    }
    if (a < this.inputs.length) {
      var b = [];
      a = $jscomp.makeIterator(this.inputs[a].links);
      for (var d = a.next(); !d.done; d = a.next()) {
        b.push(this.graph.links[d.value]);
      }
      return b;
    }
    return null;
  };
  n.prototype.getInputNodes = function(a) {
    if (!this.inputs || a >= this.inputs.length) {
      return null;
    }
    a = this.inputs[a];
    if (!a || null === a.links) {
      return null;
    }
    for (var b = [], d = 0; d < a.links.length; d++) {
      var f = this.graph.links[a.links[d]];
      f && b.push(this.graph.getNodeById(f.origin_id));
    }
    return b;
  };
  n.prototype.getInputOrProperty = function(a) {
    if (!this.inputs || !this.inputs.length) {
      return this.properties ? this.properties[a] : null;
    }
    for (var b = 0, d = this.inputs.length; b < d; b++) {
      var f = this.inputs[b];
      if (a == f.name && null != f.links) {
        return this.getInputData(a);
      }
    }
    return this.properties[a];
  };
  n.prototype.getOutputData = function(a) {
    return !this.outputs || a >= this.outputs.length ? null : this.outputs[a]._data;
  };
  n.prototype.getOutputInfo = function(a) {
    return this.outputs ? a < this.outputs.length ? this.outputs[a] : null : null;
  };
  n.prototype.isOutputConnected = function(a) {
    return this.outputs ? a < this.outputs.length && this.outputs[a].links && this.outputs[a].links.length : !1;
  };
  n.prototype.isAnyOutputConnected = function() {
    if (!this.outputs) {
      return !1;
    }
    for (var a = 0; a < this.outputs.length; ++a) {
      if (this.outputs[a].links && this.outputs[a].links.length) {
        return !0;
      }
    }
    return !1;
  };
  n.prototype.getOutputNodes = function(a) {
    if (!this.outputs || 0 == this.outputs.length || a >= this.outputs.length) {
      return null;
    }
    a = this.outputs[a];
    if (!a.links || 0 == a.links.length) {
      return null;
    }
    for (var b = [], d = 0; d < a.links.length; d++) {
      var f = this.graph.links[a.links[d]];
      f && (f = this.graph.getNodeById(f.target_id)) && b.push(f);
    }
    return b;
  };
  n.prototype.trigger = function(a, b) {
    if (this.outputs && this.outputs.length) {
      this.graph && (this.graph._last_trigger_time = e.getTime());
      for (var d = 0; d < this.outputs.length; ++d) {
        var f = this.outputs[d];
        !f || f.type !== e.EVENT || a && f.name != a || this.triggerSlot(d, b);
      }
    }
  };
  n.prototype.triggerSlot = function(a, b, d) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      this.graph && (this.graph._last_trigger_time = e.getTime());
      for (var f = 0; f < a.length; ++f) {
        var h = a[f];
        if (null == d || d == h) {
          var w = this.graph.links[a[f]];
          if (w && (w._last_time = e.getTime(), h = this.graph.getNodeById(w.target_id))) {
            if (w = h.inputs[w.target_slot], h.mode === e.ON_TRIGGER) {
              if (h.onExecute) {
                h.onExecute(b);
              }
            } else {
              if (h.onAction) {
                h.onAction(w.name, b);
              }
            }
          }
        }
      }
    }
  };
  n.prototype.clearTriggeredSlot = function(a, b) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      for (var d = 0; d < a.length; ++d) {
        var f = a[d];
        if (null == b || b == f) {
          if (f = this.graph.links[a[d]]) {
            f._last_time = 0;
          }
        }
      }
    }
  };
  n.prototype.setSize = function(a) {
    this.size = a;
    if (this.onResize) {
      this.onResize(this.size);
    }
  };
  n.prototype.addProperty = function(a, b, d, f) {
    d = {name:a, type:d, default_value:b};
    if (f) {
      for (var h in f) {
        d[h] = f[h];
      }
    }
    this.properties_info || (this.properties_info = []);
    this.properties_info.push(d);
    this.properties || (this.properties = {});
    this.properties[a] = b;
    return d;
  };
  n.prototype.addOutput = function(a, b, d) {
    a = {name:a, type:b, links:null};
    if (d) {
      for (var f in d) {
        a[f] = d[f];
      }
    }
    this.outputs || (this.outputs = []);
    this.outputs.push(a);
    if (this.onOutputAdded) {
      this.onOutputAdded(a);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  n.prototype.addOutputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var d = a[b], f = {name:d[0], type:d[1], link:null};
      if (a[2]) {
        for (var h in d[2]) {
          f[h] = d[2][h];
        }
      }
      this.outputs || (this.outputs = []);
      this.outputs.push(f);
      if (this.onOutputAdded) {
        this.onOutputAdded(f);
      }
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(!0, !0);
  };
  n.prototype.removeOutput = function(a) {
    this.disconnectOutput(a);
    this.outputs.splice(a, 1);
    for (var b = a; b < this.outputs.length; ++b) {
      if (this.outputs[b] && this.outputs[b].links) {
        for (var d = this.outputs[b].links, f = 0; f < d.length; ++f) {
          var h = this.graph.links[d[f]];
          h && --h.origin_slot;
        }
      }
    }
    this.setSize(this.computeSize());
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    this.setDirtyCanvas(!0, !0);
  };
  n.prototype.addInput = function(a, b, d) {
    a = {name:a, type:b || 0, link:null};
    if (d) {
      for (var f in d) {
        a[f] = d[f];
      }
    }
    this.inputs || (this.inputs = []);
    this.inputs.push(a);
    this.setSize(this.computeSize());
    if (this.onInputAdded) {
      this.onInputAdded(a);
    }
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  n.prototype.addInputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var d = a[b], f = {name:d[0], type:d[1], link:null};
      if (a[2]) {
        for (var h in d[2]) {
          f[h] = d[2][h];
        }
      }
      this.inputs || (this.inputs = []);
      this.inputs.push(f);
      if (this.onInputAdded) {
        this.onInputAdded(f);
      }
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(!0, !0);
  };
  n.prototype.removeInput = function(a) {
    this.disconnectInput(a);
    for (var b = this.inputs.splice(a, 1), d = a; d < this.inputs.length; ++d) {
      if (this.inputs[d]) {
        for (var f = this.inputs[d].links, h = 0; h < f.length; h++) {
          var e = this.graph.links[f[h]];
          e && --e.target_slot;
        }
      }
    }
    this.setSize(this.computeSize());
    if (this.onInputRemoved) {
      this.onInputRemoved(a, b[0]);
    }
    this.setDirtyCanvas(!0, !0);
  };
  n.prototype.addConnection = function(a, b, d, f) {
    a = {name:a, type:b, pos:d, direction:f, links:null};
    this.connections.push(a);
    return a;
  };
  n.prototype.computeSize = function(a) {
    function b(a) {
      return a ? f * a.length * 0.6 : 0;
    }
    if (this.constructor.size) {
      return this.constructor.size.concat();
    }
    var d = Math.max(this.inputs ? this.inputs.length : 1, this.outputs ? this.outputs.length : 1);
    a = a || new Float32Array([0, 0]);
    d = Math.max(d, 1);
    var f = e.NODE_TEXT_SIZE, h = b(this.title), w = 0, v = 0;
    if (this.inputs) {
      for (var r = 0, c = this.inputs.length; r < c; ++r) {
        var k = this.inputs[r];
        k = k.label || k.name || "";
        k = b(k);
        w < k && (w = k);
      }
    }
    if (this.outputs) {
      for (r = 0, c = this.outputs.length; r < c; ++r) {
        k = this.outputs[r], k = k.label || k.name || "", k = b(k), v < k && (v = k);
      }
    }
    a[0] = Math.max(w + v + 10, h);
    a[0] = Math.max(a[0], e.NODE_WIDTH);
    this.widgets && this.widgets.length && (a[0] = Math.max(a[0], 1.5 * e.NODE_WIDTH));
    a[1] = (this.constructor.slot_start_y || 0) + d * e.NODE_SLOT_HEIGHT;
    d = 0;
    if (this.widgets && this.widgets.length) {
      r = 0;
      for (c = this.widgets.length; r < c; ++r) {
        d = this.widgets[r].computeSize ? d + (this.widgets[r].computeSize(a[0])[1] + 4) : d + (e.NODE_WIDGET_HEIGHT + 4);
      }
      d += 8;
    }
    a[1] = this.widgets_up ? Math.max(a[1], d) : null != this.widgets_start_y ? Math.max(a[1], d + this.widgets_start_y) : a[1] + d;
    this.constructor.min_height && a[1] < this.constructor.min_height && (a[1] = this.constructor.min_height);
    a[1] += 6;
    return a;
  };
  n.prototype.getPropertyInfo = function(a) {
    var b = null;
    if (this.properties_info) {
      for (var d = 0; d < this.properties_info.length; ++d) {
        if (this.properties_info[d].name == a) {
          b = this.properties_info[d];
          break;
        }
      }
    }
    this.constructor["@" + a] && (b = this.constructor["@" + a]);
    this.constructor.widgets_info && this.constructor.widgets_info[a] && (b = this.constructor.widgets_info[a]);
    !b && this.onGetPropertyInfo && (b = this.onGetPropertyInfo(a));
    b || (b = {});
    b.type || (b.type = typeof this.properties[a]);
    "combo" == b.widget && (b.type = "enum");
    return b;
  };
  n.prototype.addWidget = function(a, b, d, f, h) {
    this.widgets || (this.widgets = []);
    !h && f && f.constructor === Object && (h = f, f = null);
    h && h.constructor === String && (h = {property:h});
    f && f.constructor === String && (h || (h = {}), h.property = f, f = null);
    f && f.constructor !== Function && (console.warn("addWidget: callback must be a function"), f = null);
    b = {type:a.toLowerCase(), name:b, value:d, callback:f, options:h || {}};
    void 0 !== b.options.y && (b.y = b.options.y);
    f || b.options.callback || b.options.property || console.warn("LiteGraph addWidget(...) without a callback or property assigned");
    if ("combo" == a && !b.options.values) {
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
    }
    this.widgets.push(b);
    this.setSize(this.computeSize());
    return b;
  };
  n.prototype.addCustomWidget = function(a) {
    this.widgets || (this.widgets = []);
    this.widgets.push(a);
    return a;
  };
  n.prototype.getBounding = function(a) {
    a = a || new Float32Array(4);
    a[0] = this.pos[0] - 4;
    a[1] = this.pos[1] - e.NODE_TITLE_HEIGHT;
    a[2] = this.size[0] + 4;
    a[3] = this.flags.collapsed ? e.NODE_TITLE_HEIGHT : this.size[1] + e.NODE_TITLE_HEIGHT;
    if (this.onBounding) {
      this.onBounding(a);
    }
    return a;
  };
  n.prototype.isPointInside = function(a, b, d, f) {
    d = d || 0;
    var h = this.graph && this.graph.isLive() ? 0 : e.NODE_TITLE_HEIGHT;
    f && (h = 0);
    if (this.flags && this.flags.collapsed) {
      if (A(a, b, this.pos[0] - d, this.pos[1] - e.NODE_TITLE_HEIGHT - d, (this._collapsed_width || e.NODE_COLLAPSED_WIDTH) + 2 * d, e.NODE_TITLE_HEIGHT + 2 * d)) {
        return !0;
      }
    } else {
      if (this.pos[0] - 4 - d < a && this.pos[0] + this.size[0] + 4 + d > a && this.pos[1] - h - d < b && this.pos[1] + this.size[1] + d > b) {
        return !0;
      }
    }
    return !1;
  };
  n.prototype.getSlotInPosition = function(a, b) {
    var d = new Float32Array(2);
    if (this.inputs) {
      for (var f = 0, h = this.inputs.length; f < h; ++f) {
        var e = this.inputs[f];
        this.getConnectionPos(!0, f, d);
        if (A(a, b, d[0] - 10, d[1] - 5, 20, 10)) {
          return {input:e, slot:f, link_pos:d};
        }
      }
    }
    if (this.outputs) {
      for (f = 0, h = this.outputs.length; f < h; ++f) {
        if (e = this.outputs[f], this.getConnectionPos(!1, f, d), A(a, b, d[0] - 10, d[1] - 5, 20, 10)) {
          return {output:e, slot:f, link_pos:d};
        }
      }
    }
    return null;
  };
  n.prototype.findInputSlot = function(a) {
    if (!this.inputs) {
      return -1;
    }
    for (var b = 0, d = this.inputs.length; b < d; ++b) {
      if (a == this.inputs[b].name) {
        return b;
      }
    }
    return -1;
  };
  n.prototype.findOutputSlot = function(a) {
    if (!this.outputs) {
      return -1;
    }
    for (var b = 0, d = this.outputs.length; b < d; ++b) {
      if (a == this.outputs[b].name) {
        return b;
      }
    }
    return -1;
  };
  n.prototype.connect = function(a, b, d) {
    d = d || 0;
    if (!this.graph) {
      return console.log("Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."), null;
    }
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return e.debug && console.log("Connect: Error, no slot of name " + a), null;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return e.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    b && b.constructor === Number && (b = this.graph.getNodeById(b));
    if (!b) {
      throw "target node is null";
    }
    if (b == this) {
      return null;
    }
    if (d.constructor === String) {
      if (d = b.findInputSlot(d), -1 == d) {
        return e.debug && console.log("Connect: Error, no slot of name " + d), null;
      }
    } else {
      if (d === e.EVENT) {
        return null;
      }
      if (!b.inputs || d >= b.inputs.length) {
        return e.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    var f = this.outputs[a];
    if (b.onConnectInput && !1 === b.onConnectInput(d, f.type, f, this, a)) {
      return null;
    }
    var h = b.inputs[d];
    if (!e.isValidConnection(f.type, h.type)) {
      return this.setDirtyCanvas(!1, !0), null;
    }
    this.graph.beforeChange();
    var w = new g(++this.graph.last_link_id, h.type, this.id, a, b.id, d);
    this.graph.links[w.id] = w;
    null == f.links && (f.links = []);
    f.links.push(w.id);
    null == b.inputs[d].links && (b.inputs[d].links = []);
    b.inputs[d].links.push(w.id);
    this.graph && this.graph._version++;
    if (this.onConnectionsChange) {
      this.onConnectionsChange(e.OUTPUT, a, !0, w, f);
    }
    if (b.onConnectionsChange) {
      b.onConnectionsChange(e.INPUT, d, !0, w, h);
    }
    this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(e.INPUT, b, d, this, a), this.graph.onNodeConnectionChange(e.OUTPUT, this, a, b, d));
    this.setDirtyCanvas(!1, !0);
    this.graph.afterChange();
    this.graph.connectionChange(this, w);
    return w;
  };
  n.prototype.disconnectOutput = function(a, b) {
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return e.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return e.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var d = this.outputs[a];
    if (!d || !d.links || 0 == d.links.length) {
      return !1;
    }
    if (b) {
      b.constructor === Number && (b = this.graph.getNodeById(b));
      if (!b) {
        throw "Target Node not found";
      }
      for (var f = 0, h = d.links.length; f < h; f++) {
        var w = d.links[f], c = this.graph.links[w];
        if (c.target_id == b.id) {
          d.links.splice(f, 1);
          var r = b.inputs[c.target_slot];
          if (!r || !r.links || 0 == r.links.length) {
            return !1;
          }
          f = 0;
          for (h = r.links.length; f < h; f++) {
            if (r.links[f] == w) {
              r.links.splice(f, 1);
              break;
            }
          }
          delete this.graph.links[w];
          this.graph && this.graph._version++;
          if (b.onConnectionsChange) {
            b.onConnectionsChange(e.INPUT, c.target_slot, !1, c, r);
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(e.OUTPUT, a, !1, c, d);
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(e.OUTPUT, this, a);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(e.OUTPUT, this, a), this.graph.onNodeConnectionChange(e.INPUT, b, c.target_slot));
          break;
        }
      }
    } else {
      f = 0;
      for (h = d.links.length; f < h; f++) {
        if (w = d.links[f], c = this.graph.links[w]) {
          b = this.graph.getNodeById(c.target_id);
          this.graph && this.graph._version++;
          if (b) {
            r = b.inputs[c.target_slot];
            for (var k = 0, t = r.links.length; k < t; k++) {
              if (r.links[k] == w) {
                r.links.splice(k, 1);
                break;
              }
            }
            if (b.onConnectionsChange) {
              b.onConnectionsChange(e.INPUT, c.target_slot, !1, c, r);
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(e.INPUT, b, c.target_slot);
            }
          }
          delete this.graph.links[w];
          if (this.onConnectionsChange) {
            this.onConnectionsChange(e.OUTPUT, a, !1, c, d);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(e.OUTPUT, this, a), this.graph.onNodeConnectionChange(e.INPUT, b, c.target_slot));
        }
      }
      d.links = null;
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  n.prototype.disconnectInput = function(a) {
    if (a.constructor === String) {
      if (a = this.findInputSlot(a), -1 == a) {
        return e.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.inputs || a >= this.inputs.length) {
        return e.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var b = this.inputs[a];
    if (!b || !b.links || 0 == b.links.length) {
      return !1;
    }
    for (var d = 0, f; 1 > d; d++) {
      var h = b.links[d];
      if (null != h) {
        b.links.splice(d, 1);
        var c = this.graph.links[h];
        if (c) {
          var v = this.graph.getNodeById(c.origin_id);
          if (!v) {
            return !1;
          }
          var r = v.outputs[c.origin_slot];
          if (!r || !r.links || 0 == r.links.length) {
            return !1;
          }
          d = 0;
          for (f = r.links.length; d < f; d++) {
            if (r.links[d] == h) {
              r.links.splice(d, 1);
              break;
            }
          }
          delete this.graph.links[h];
          this.graph && this.graph._version++;
          if (this.onConnectionsChange) {
            this.onConnectionsChange(e.INPUT, a, !1, c, b);
          }
          if (v.onConnectionsChange) {
            v.onConnectionsChange(e.OUTPUT, d, !1, c, r);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(e.OUTPUT, v, d), this.graph.onNodeConnectionChange(e.INPUT, this, a));
        }
      }
    }
    this.setDirtyCanvas(!1, !0);
    this.graph && this.graph.connectionChange(this);
    return !0;
  };
  n.prototype.getConnectionPos = function(a, b, d) {
    d = d || new Float32Array(2);
    var f = 0;
    a && this.inputs && (f = this.inputs.length);
    !a && this.outputs && (f = this.outputs.length);
    var h = 0.5 * e.NODE_SLOT_HEIGHT;
    if (this.flags.collapsed) {
      return b = this._collapsed_width || e.NODE_COLLAPSED_WIDTH, this.horizontal ? (d[0] = this.pos[0] + 0.5 * b, d[1] = a ? this.pos[1] - e.NODE_TITLE_HEIGHT : this.pos[1]) : (d[0] = a ? this.pos[0] : this.pos[0] + b, d[1] = this.pos[1] - 0.5 * e.NODE_TITLE_HEIGHT), d;
    }
    if (a && -1 == b) {
      return d[0] = this.pos[0] + 0.5 * e.NODE_TITLE_HEIGHT, d[1] = this.pos[1] + 0.5 * e.NODE_TITLE_HEIGHT, d;
    }
    if (a && f > b && this.inputs[b].pos) {
      return d[0] = this.pos[0] + this.inputs[b].pos[0], d[1] = this.pos[1] + this.inputs[b].pos[1], d;
    }
    if (!a && f > b && this.outputs[b].pos) {
      return d[0] = this.pos[0] + this.outputs[b].pos[0], d[1] = this.pos[1] + this.outputs[b].pos[1], d;
    }
    if (this.horizontal) {
      return d[0] = this.pos[0] + this.size[0] / f * (b + 0.5), d[1] = a ? this.pos[1] - e.NODE_TITLE_HEIGHT : this.pos[1] + this.size[1], d;
    }
    d[0] = a ? this.pos[0] + h : this.pos[0] + this.size[0] + 1 - h;
    d[1] = this.pos[1] + (b + 0.7) * e.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
    return d;
  };
  n.prototype.alignToGrid = function() {
    this.pos[0] = e.CANVAS_GRID_SIZE * Math.round(this.pos[0] / e.CANVAS_GRID_SIZE);
    this.pos[1] = e.CANVAS_GRID_SIZE * Math.round(this.pos[1] / e.CANVAS_GRID_SIZE);
  };
  n.prototype.trace = function(a) {
    this.console || (this.console = []);
    this.console.push(a);
    this.console.length > n.MAX_CONSOLE && this.console.shift();
    if (this.graph.onNodeTrace) {
      this.graph.onNodeTrace(this, a);
    }
  };
  n.prototype.setDirtyCanvas = function(a, b) {
    this.graph && this.graph.sendActionToCanvas("setDirty", [a, b]);
  };
  n.prototype.loadImage = function(a) {
    var b = new Image;
    b.src = e.node_images_path + a;
    b.ready = !1;
    var d = this;
    b.onload = function() {
      this.ready = !0;
      d.setDirtyCanvas(!0);
    };
    return b;
  };
  n.prototype.captureInput = function(a) {
    if (this.graph && this.graph.list_of_graphcanvas) {
      for (var b = this.graph.list_of_graphcanvas, d = 0; d < b.length; ++d) {
        var f = b[d];
        if (a || f.node_capturing_input == this) {
          f.node_capturing_input = a ? this : null;
        }
      }
    }
  };
  n.prototype.collapse = function(a) {
    this.graph._version++;
    if (!1 !== this.constructor.collapsable || a) {
      this.flags.collapsed = this.flags.collapsed ? !1 : !0, this.setDirtyCanvas(!0, !0);
    }
  };
  n.prototype.pin = function(a) {
    this.graph._version++;
    this.flags.pinned = void 0 === a ? !this.flags.pinned : a;
  };
  n.prototype.localToScreen = function(a, b, d) {
    return [(a + this.pos[0]) * d.scale + d.offset[0], (b + this.pos[1]) * d.scale + d.offset[1]];
  };
  y.LGraphGroup = e.LGraphGroup = m;
  m.prototype._ctor = function(a) {
    this.title = a || "Group";
    this.font_size = 24;
    this.color = l.node_colors.pale_blue ? l.node_colors.pale_blue.groupcolor : "#AAA";
    this._bounding = new Float32Array([10, 10, 140, 80]);
    this._pos = this._bounding.subarray(0, 2);
    this._size = this._bounding.subarray(2, 4);
    this._nodes = [];
    this.graph = null;
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    Object.defineProperty(this, "size", {set:function(a) {
      !a || 2 > a.length || (this._size[0] = Math.max(140, a[0]), this._size[1] = Math.max(80, a[1]));
    }, get:function() {
      return this._size;
    }, enumerable:!0});
  };
  m.prototype.configure = function(a) {
    this.title = a.title;
    this._bounding.set(a.bounding);
    this.color = a.color;
    this.font = a.font;
  };
  m.prototype.serialize = function() {
    var a = this._bounding;
    return {title:this.title, bounding:[Math.round(a[0]), Math.round(a[1]), Math.round(a[2]), Math.round(a[3])], color:this.color, font:this.font};
  };
  m.prototype.move = function(a, b, d) {
    this._pos[0] += a;
    this._pos[1] += b;
    if (!d) {
      for (d = 0; d < this._nodes.length; ++d) {
        var f = this._nodes[d];
        f.pos[0] += a;
        f.pos[1] += b;
      }
    }
  };
  m.prototype.recomputeInsideNodes = function() {
    this._nodes.length = 0;
    for (var a = this.graph._nodes, b = new Float32Array(4), d = 0; d < a.length; ++d) {
      var f = a[d];
      f.getBounding(b);
      D(this._bounding, b) && this._nodes.push(f);
    }
  };
  m.prototype.isPointInside = n.prototype.isPointInside;
  m.prototype.setDirtyCanvas = n.prototype.setDirtyCanvas;
  e.DragAndScale = u;
  u.prototype.bindEvents = function(a) {
    this.last_mouse = new Float32Array(2);
    this._binded_mouse_callback = this.onMouse.bind(this);
    a.addEventListener("mousedown", this._binded_mouse_callback);
    a.addEventListener("mousemove", this._binded_mouse_callback);
    a.addEventListener("mousewheel", this._binded_mouse_callback, !1);
    a.addEventListener("wheel", this._binded_mouse_callback, !1);
  };
  u.prototype.computeVisibleArea = function(a) {
    if (this.element) {
      var b = this.element.width, d = this.element.height, f = -this.offset[0], h = -this.offset[1];
      a && (f += a[0] / this.scale, h += a[1] / this.scale, b = a[2], d = a[3]);
      a = f + b / this.scale;
      d = h + d / this.scale;
      this.visible_area[0] = f;
      this.visible_area[1] = h;
      this.visible_area[2] = a - f;
      this.visible_area[3] = d - h;
    } else {
      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
    }
  };
  u.prototype.onMouse = function(a) {
    if (this.enabled) {
      var b = this.element, d = b.getBoundingClientRect(), f = a.clientX - d.left;
      d = a.clientY - d.top;
      a.canvasx = f;
      a.canvasy = d;
      a.dragging = this.dragging;
      var h = !this.viewport || this.viewport && f >= this.viewport[0] && f < this.viewport[0] + this.viewport[2] && d >= this.viewport[1] && d < this.viewport[1] + this.viewport[3], e = !1;
      this.onmouse && (e = this.onmouse(a));
      "mousedown" == a.type && h ? (this.dragging = !0, b.removeEventListener("mousemove", this._binded_mouse_callback), document.body.addEventListener("mousemove", this._binded_mouse_callback), document.body.addEventListener("mouseup", this._binded_mouse_callback)) : "mousemove" == a.type ? e || (b = f - this.last_mouse[0], e = d - this.last_mouse[1], this.dragging && this.mouseDrag(b, e)) : "mouseup" == a.type ? (this.dragging = !1, document.body.removeEventListener("mousemove", this._binded_mouse_callback), 
      document.body.removeEventListener("mouseup", this._binded_mouse_callback), b.addEventListener("mousemove", this._binded_mouse_callback)) : !h || "mousewheel" != a.type && "wheel" != a.type && "DOMMouseScroll" != a.type || (a.eventType = "mousewheel", a.wheel = "wheel" == a.type ? -a.deltaY : null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail, a.delta = a.wheelDelta ? a.wheelDelta / 40 : a.deltaY ? -a.deltaY / 3 : 0, this.changeDeltaScale(1.0 + 0.05 * a.delta));
      this.last_mouse[0] = f;
      this.last_mouse[1] = d;
      if (h) {
        return a.preventDefault(), a.stopPropagation(), !1;
      }
    }
  };
  u.prototype.toCanvasContext = function(a) {
    a.scale(this.scale, this.scale);
    a.translate(this.offset[0], this.offset[1]);
  };
  u.prototype.convertOffsetToCanvas = function(a) {
    return [(a[0] + this.offset[0]) * this.scale, (a[1] + this.offset[1]) * this.scale];
  };
  u.prototype.convertCanvasToOffset = function(a, b) {
    b = b || [0, 0];
    b[0] = a[0] / this.scale - this.offset[0];
    b[1] = a[1] / this.scale - this.offset[1];
    return b;
  };
  u.prototype.mouseDrag = function(a, b) {
    this.offset[0] += a / this.scale;
    this.offset[1] += b / this.scale;
    if (this.onredraw) {
      this.onredraw(this);
    }
  };
  u.prototype.changeScale = function(a, b) {
    a < this.min_scale ? a = this.min_scale : a > this.max_scale && (a = this.max_scale);
    if (a != this.scale && this.element) {
      var d = this.element.getBoundingClientRect();
      if (d && (b = b || [0.5 * d.width, 0.5 * d.height], d = this.convertCanvasToOffset(b), this.scale = a, 0.01 > Math.abs(this.scale - 1) && (this.scale = 1), a = this.convertCanvasToOffset(b), a = [a[0] - d[0], a[1] - d[1]], this.offset[0] += a[0], this.offset[1] += a[1], this.onredraw)) {
        this.onredraw(this);
      }
    }
  };
  u.prototype.changeDeltaScale = function(a, b) {
    this.changeScale(this.scale * a, b);
  };
  u.prototype.reset = function() {
    this.scale = 1;
    this.offset[0] = 0;
    this.offset[1] = 0;
  };
  y.LGraphCanvas = e.LGraphCanvas = l;
  l.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
  l.link_type_colors = {"-1":e.EVENT_LINK_COLOR, number:"#AAA", node:"#DCA"};
  l.gradients = {};
  l.prototype.clear = function() {
    this.fps = this.render_time = this.last_draw_time = this.frame = 0;
    this.dragging_rectangle = null;
    this.selected_nodes = {};
    this.selected_group = null;
    this.visible_nodes = [];
    this.connecting_node = this.node_capturing_input = this.node_over = this.node_dragged = null;
    this.highlighted_links = {};
    this.dragging_canvas = !1;
    this.dirty_bgcanvas = this.dirty_canvas = !0;
    this.node_widget = this.node_in_panel = this.dirty_area = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    this.visible_area.set([0, 0, 0, 0]);
    if (this.onClear) {
      this.onClear();
    }
  };
  l.prototype.setGraph = function(a, b) {
    this.graph != a && (b || this.clear(), !a && this.graph ? this.graph.detachCanvas(this) : (a.attachCanvas(this), this._graph_stack && (this._graph_stack = null), this.setDirty(!0, !0)));
  };
  l.prototype.getTopGraph = function() {
    return this._graph_stack.length ? this._graph_stack[0] : this.graph;
  };
  l.prototype.openSubgraph = function(a) {
    if (!a) {
      throw "graph cannot be null";
    }
    if (this.graph == a) {
      throw "graph cannot be the same";
    }
    this.clear();
    this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph));
    a.attachCanvas(this);
    this.checkPanels();
    this.setDirty(!0, !0);
  };
  l.prototype.closeSubgraph = function() {
    if (this._graph_stack && 0 != this._graph_stack.length) {
      var a = this.graph._subgraph_node, b = this._graph_stack.pop();
      this.selected_nodes = {};
      this.highlighted_links = {};
      b.attachCanvas(this);
      this.setDirty(!0, !0);
      a && (this.centerOnNode(a), this.selectNodes([a]));
    }
  };
  l.prototype.getCurrentGraph = function() {
    return this.graph;
  };
  l.prototype.setCanvas = function(a, b) {
    if (a && a.constructor === String && (a = document.getElementById(a), !a)) {
      throw "Error creating LiteGraph canvas: Canvas not found";
    }
    if (a !== this.canvas && (!a && this.canvas && (b || this.unbindEvents()), this.canvas = a, this.ds.element = a)) {
      a.className += " lgraphcanvas";
      a.data = this;
      a.tabindex = "1";
      this.bgcanvas = null;
      this.bgcanvas || (this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height);
      if (null == a.getContext) {
        if ("canvas" != a.localName) {
          throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + a.localName;
        }
        throw "This browser doesn't support Canvas";
      }
      null == (this.ctx = a.getContext("2d")) && (a.webgl_enabled || console.warn("This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL());
      this._mousemove_callback = this.processMouseMove.bind(this);
      this._mouseup_callback = this.processMouseUp.bind(this);
      b || this.bindEvents();
    }
  };
  l.prototype._doNothing = function(a) {
    a.preventDefault();
    return !1;
  };
  l.prototype._doReturnTrue = function(a) {
    a.preventDefault();
    return !0;
  };
  l.prototype.bindEvents = function() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
    } else {
      var a = this.canvas, b = this.getCanvasWindow().document;
      this._mousedown_callback = this.processMouseDown.bind(this);
      this._mousewheel_callback = this.processMouseWheel.bind(this);
      this._touch_callback = this.touchHandler.bind(this);
      a.addEventListener("mousedown", this._mousedown_callback, !0);
      a.addEventListener("mousemove", this._mousemove_callback);
      a.addEventListener("mousewheel", this._mousewheel_callback, !1);
      a.addEventListener("contextmenu", this._doNothing);
      a.addEventListener("DOMMouseScroll", this._mousewheel_callback, !1);
      a.addEventListener("touchstart", this._touch_callback, !0);
      a.addEventListener("touchmove", this._touch_callback, !0);
      a.addEventListener("touchend", this._touch_callback, !0);
      a.addEventListener("touchcancel", this._touch_callback, !0);
      this._key_callback = this.processKey.bind(this);
      a.addEventListener("keydown", this._key_callback, !0);
      b.addEventListener("keyup", this._key_callback, !0);
      this._ondrop_callback = this.processDrop.bind(this);
      a.addEventListener("dragover", this._doNothing, !1);
      a.addEventListener("dragend", this._doNothing, !1);
      a.addEventListener("drop", this._ondrop_callback, !1);
      a.addEventListener("dragenter", this._doReturnTrue, !1);
      this._events_binded = !0;
    }
  };
  l.prototype.unbindEvents = function() {
    if (this._events_binded) {
      var a = this.getCanvasWindow().document;
      this.canvas.removeEventListener("mousedown", this._mousedown_callback);
      this.canvas.removeEventListener("mousewheel", this._mousewheel_callback);
      this.canvas.removeEventListener("DOMMouseScroll", this._mousewheel_callback);
      this.canvas.removeEventListener("keydown", this._key_callback);
      a.removeEventListener("keyup", this._key_callback);
      this.canvas.removeEventListener("contextmenu", this._doNothing);
      this.canvas.removeEventListener("drop", this._ondrop_callback);
      this.canvas.removeEventListener("dragenter", this._doReturnTrue);
      this.canvas.removeEventListener("touchstart", this._touch_callback);
      this.canvas.removeEventListener("touchmove", this._touch_callback);
      this.canvas.removeEventListener("touchend", this._touch_callback);
      this.canvas.removeEventListener("touchcancel", this._touch_callback);
      this._ondrop_callback = this._key_callback = this._mousewheel_callback = this._mousedown_callback = null;
      this._events_binded = !1;
    } else {
      console.warn("LGraphCanvas: no events binded");
    }
  };
  l.getFileExtension = function(a) {
    var b = a.indexOf("?");
    -1 != b && (a = a.substr(0, b));
    b = a.lastIndexOf(".");
    return -1 == b ? "" : a.substr(b + 1).toLowerCase();
  };
  l.prototype.enableWebGL = function() {
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = !0;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
    this.canvas.webgl_enabled = !0;
  };
  l.prototype.setDirty = function(a, b) {
    a && (this.dirty_canvas = !0);
    b && (this.dirty_bgcanvas = !0);
  };
  l.prototype.getCanvasWindow = function() {
    if (!this.canvas) {
      return window;
    }
    var a = this.canvas.ownerDocument;
    return a.defaultView || a.parentWindow;
  };
  l.prototype.startRendering = function() {
    function a() {
      this.pause_rendering || this.draw();
      var b = this.getCanvasWindow();
      this.is_rendering && b.requestAnimationFrame(a.bind(this));
    }
    this.is_rendering || (this.is_rendering = !0, a.call(this));
  };
  l.prototype.stopRendering = function() {
    this.is_rendering = !1;
  };
  l.prototype.blockClick = function() {
    this.block_click = !0;
    this.last_mouseclick = 0;
  };
  l.prototype.processMouseDown = function(a) {
    this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0);
    if (this.graph) {
      this.adjustMouseEvent(a);
      var b = this.getCanvasWindow();
      l.active_canvas = this;
      var d = this, f = a.localX, h = a.localY;
      this.ds.viewport = this.viewport;
      f = !this.viewport || this.viewport && f >= this.viewport[0] && f < this.viewport[0] + this.viewport[2] && h >= this.viewport[1] && h < this.viewport[1] + this.viewport[3];
      this.options.skip_events || (this.canvas.removeEventListener("mousemove", this._mousemove_callback), b.document.addEventListener("mousemove", this._mousemove_callback, !0), b.document.addEventListener("mouseup", this._mouseup_callback, !0));
      if (f) {
        var c = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes, 5);
        f = !1;
        h = 300 > e.getTime() - this.last_mouseclick;
        this.mouse[0] = a.localX;
        this.mouse[1] = a.localY;
        this.graph_mouse[0] = a.canvasX;
        this.graph_mouse[1] = a.canvasY;
        this.last_click_position = [this.mouse[0], this.mouse[1]];
        this.canvas.focus();
        e.closeAllContextMenus(b);
        if (!this.onMouse || 1 != this.onMouse(a)) {
          if (1 == a.which) {
            a.ctrlKey && (this.dragging_rectangle = new Float32Array(4), this.dragging_rectangle[0] = a.canvasX, this.dragging_rectangle[1] = a.canvasY, this.dragging_rectangle[2] = 1, this.dragging_rectangle[3] = 1, f = !0);
            var v = !1;
            if (c && this.allow_interaction && !f && !this.read_only) {
              this.live_mode || c.flags.pinned || this.bringToFront(c);
              if (!this.connecting_node && !c.flags.collapsed && !this.live_mode) {
                if (!f && !1 !== c.resizable && A(a.canvasX, a.canvasY, c.pos[0] + c.size[0] - 5, c.pos[1] + c.size[1] - 5, 10, 10)) {
                  this.graph.beforeChange(), this.resizing_node = c, this.canvas.style.cursor = "se-resize", f = !0;
                } else {
                  if (c.outputs) {
                    for (var r = 0, k = c.outputs.length; r < k; ++r) {
                      var t = c.outputs[r], q = c.getConnectionPos(!1, r);
                      if (A(a.canvasX, a.canvasY, q[0] - 15, q[1] - 10, 30, 20)) {
                        this.connecting_node = c;
                        this.connecting_output = t;
                        this.connecting_pos = c.getConnectionPos(!1, r);
                        this.connecting_slot = r;
                        a.shiftKey && c.disconnectOutput(r);
                        if (h) {
                          if (c.onOutputDblClick) {
                            c.onOutputDblClick(r, a);
                          }
                        } else {
                          if (c.onOutputClick) {
                            c.onOutputClick(r, a);
                          }
                        }
                        f = !0;
                        break;
                      }
                    }
                  }
                  if (c.inputs) {
                    for (r = 0, k = c.inputs.length; r < k; ++r) {
                      if (q = c.getConnectionPos(!0, r), A(a.canvasX, a.canvasY, q[0] - 15, q[1] - 10, 30, 20)) {
                        if (h) {
                          if (c.onInputDblClick) {
                            c.onInputDblClick(r, a);
                          }
                        } else {
                          if (c.onInputClick) {
                            c.onInputClick(r, a);
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (!f) {
                r = !1;
                k = [a.canvasX - c.pos[0], a.canvasY - c.pos[1]];
                if (t = this.processNodeWidgets(c, this.graph_mouse, a)) {
                  r = !0, this.node_widget = [c, t];
                }
                if (h && this.selected_nodes[c.id]) {
                  if (c.onDblClick) {
                    c.onDblClick(a, k, this);
                  }
                  this.processNodeDblClicked(c);
                  r = !0;
                }
                c.onMouseDown && c.onMouseDown(a, k, this) ? r = !0 : (c.subgraph && !c.skip_subgraph_button && !c.flags.collapsed && k[0] > c.size[0] - e.NODE_TITLE_HEIGHT && 0 > k[1] && (d = this, setTimeout(function() {
                  d.openSubgraph(c.subgraph);
                }, 10)), this.live_mode && (r = v = !0));
                r || (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = c), this.selected_nodes[c.id] || this.processNodeSelected(c, a));
                this.dirty_canvas = !0;
              }
            } else {
              if (!this.read_only) {
                for (r = 0; r < this.visible_links.length; ++r) {
                  if (v = this.visible_links[r], k = v._pos, !(!k || a.canvasX < k[0] - 4 || a.canvasX > k[0] + 4 || a.canvasY < k[1] - 4 || a.canvasY > k[1] + 4)) {
                    this.showLinkMenu(v, a);
                    this.over_link_center = null;
                    break;
                  }
                }
              }
              this.selected_group = this.graph.getGroupOnPos(a.canvasX, a.canvasY);
              this.selected_group_resizing = !1;
              this.selected_group && !this.read_only && (a.ctrlKey && (this.dragging_rectangle = null), 10 > G([a.canvasX, a.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]) * this.ds.scale ? this.selected_group_resizing = !0 : this.selected_group.recomputeInsideNodes());
              h && !this.read_only && this.allow_searchbox && this.showSearchBox(a);
              v = !0;
            }
            !f && v && this.allow_dragcanvas && (this.dragging_canvas = !0);
          } else {
            2 != a.which && 3 == a.which && (this.read_only || this.processContextMenu(c, a));
          }
          this.last_mouse[0] = a.localX;
          this.last_mouse[1] = a.localY;
          this.last_mouseclick = e.getTime();
          this.last_mouse_dragging = !0;
          this.graph.change();
          (!b.document.activeElement || "input" != b.document.activeElement.nodeName.toLowerCase() && "textarea" != b.document.activeElement.nodeName.toLowerCase()) && a.preventDefault();
          a.stopPropagation();
          if (this.onMouseDown) {
            this.onMouseDown(a);
          }
          return !1;
        }
      }
    }
  };
  l.prototype.processMouseMove = function(a) {
    this.autoresize && this.resize();
    this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0);
    if (this.graph) {
      l.active_canvas = this;
      this.adjustMouseEvent(a);
      var b = [a.localX, a.localY];
      this.mouse[0] = b[0];
      this.mouse[1] = b[1];
      var d = [b[0] - this.last_mouse[0], b[1] - this.last_mouse[1]];
      this.last_mouse = b;
      this.graph_mouse[0] = a.canvasX;
      this.graph_mouse[1] = a.canvasY;
      if (this.block_click) {
        return a.preventDefault(), !1;
      }
      a.dragging = this.last_mouse_dragging;
      this.node_widget && (this.processNodeWidgets(this.node_widget[0], this.graph_mouse, a, this.node_widget[1]), this.dirty_canvas = !0);
      if (this.dragging_rectangle) {
        this.dragging_rectangle[2] = a.canvasX - this.dragging_rectangle[0], this.dragging_rectangle[3] = a.canvasY - this.dragging_rectangle[1], this.dirty_canvas = !0;
      } else {
        if (this.selected_group && !this.read_only) {
          this.selected_group_resizing ? this.selected_group.size = [a.canvasX - this.selected_group.pos[0], a.canvasY - this.selected_group.pos[1]] : (this.selected_group.move(d[0] / this.ds.scale, d[1] / this.ds.scale, a.ctrlKey), this.selected_group._nodes.length && (this.dirty_canvas = !0)), this.dirty_bgcanvas = !0;
        } else {
          if (this.dragging_canvas) {
            this.ds.offset[0] += d[0] / this.ds.scale, this.ds.offset[1] += d[1] / this.ds.scale, this.dirty_bgcanvas = this.dirty_canvas = !0;
          } else {
            if (this.allow_interaction && !this.read_only) {
              this.connecting_node && (this.dirty_canvas = !0);
              var f = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
              b = 0;
              for (var h = this.graph._nodes.length; b < h; ++b) {
                if (this.graph._nodes[b].mouseOver && f != this.graph._nodes[b]) {
                  this.graph._nodes[b].mouseOver = !1;
                  if (this.node_over && this.node_over.onMouseLeave) {
                    this.node_over.onMouseLeave(a);
                  }
                  this.node_over = null;
                  this.dirty_canvas = !0;
                }
              }
              if (f) {
                f.redraw_on_mouse && (this.dirty_canvas = !0);
                if (!f.mouseOver && (f.mouseOver = !0, this.node_over = f, this.dirty_canvas = !0, f.onMouseEnter)) {
                  f.onMouseEnter(a);
                }
                if (f.onMouseMove) {
                  f.onMouseMove(a, [a.canvasX - f.pos[0], a.canvasY - f.pos[1]], this);
                }
                if (this.connecting_node && (h = this._highlight_input || [0, 0], !this.isOverNodeBox(f, a.canvasX, a.canvasY))) {
                  var c = this.isOverNodeInput(f, a.canvasX, a.canvasY, h);
                  -1 != c && f.inputs[c] ? e.isValidConnection(this.connecting_output.type, f.inputs[c].type) && (this._highlight_input = h, this._highlight_input_slot = f.inputs[c]) : this._highlight_input_slot = this._highlight_input = null;
                }
                this.canvas && (A(a.canvasX, a.canvasY, f.pos[0] + f.size[0] - 5, f.pos[1] + f.size[1] - 5, 5, 5) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = "crosshair");
              } else {
                h = null;
                for (b = 0; b < this.visible_links.length; ++b) {
                  c = this.visible_links[b];
                  var v = c._pos;
                  if (!(!v || a.canvasX < v[0] - 4 || a.canvasX > v[0] + 4 || a.canvasY < v[1] - 4 || a.canvasY > v[1] + 4)) {
                    h = c;
                    break;
                  }
                }
                h != this.over_link_center && (this.over_link_center = h, this.dirty_canvas = !0);
                this.canvas && (this.canvas.style.cursor = "");
              }
              if (this.node_capturing_input && this.node_capturing_input != f && this.node_capturing_input.onMouseMove) {
                this.node_capturing_input.onMouseMove(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]], this);
              }
              if (this.node_dragged && !this.live_mode) {
                for (b in this.selected_nodes) {
                  f = this.selected_nodes[b], f.pos[0] += d[0] / this.ds.scale, f.pos[1] += d[1] / this.ds.scale;
                }
                this.dirty_bgcanvas = this.dirty_canvas = !0;
              }
              this.resizing_node && !this.live_mode && (d = [a.canvasX - this.resizing_node.pos[0], a.canvasY - this.resizing_node.pos[1]], b = this.resizing_node.computeSize(), d[0] = Math.max(b[0], d[0]), d[1] = Math.max(b[1], d[1]), this.resizing_node.setSize(d), this.canvas.style.cursor = "se-resize", this.dirty_bgcanvas = this.dirty_canvas = !0);
            }
          }
        }
      }
      a.preventDefault();
      return !1;
    }
  };
  l.prototype.processMouseUp = function(a) {
    this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0);
    if (this.graph) {
      var b = this.getCanvasWindow().document;
      l.active_canvas = this;
      this.options.skip_events || (b.removeEventListener("mousemove", this._mousemove_callback, !0), this.canvas.addEventListener("mousemove", this._mousemove_callback, !0), b.removeEventListener("mouseup", this._mouseup_callback, !0));
      this.adjustMouseEvent(a);
      b = e.getTime();
      a.click_time = b - this.last_mouseclick;
      this.last_mouse_dragging = !1;
      this.last_click_position = null;
      this.block_click && (console.log("foo"), this.block_click = !1);
      if (1 == a.which) {
        if (this.node_widget && this.processNodeWidgets(this.node_widget[0], this.graph_mouse, a), this.node_widget = null, this.selected_group && (this.selected_group.move(this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]), a.ctrlKey), this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]), this.selected_group._nodes.length && (this.dirty_canvas = 
        !0), this.selected_group = null), this.selected_group_resizing = !1, this.dragging_rectangle) {
          if (this.graph) {
            b = this.graph._nodes;
            var d = new Float32Array(4);
            this.deselectAllNodes();
            var f = Math.abs(this.dragging_rectangle[2]), h = Math.abs(this.dragging_rectangle[3]), c = 0 > this.dragging_rectangle[3] ? this.dragging_rectangle[1] - h : this.dragging_rectangle[1];
            this.dragging_rectangle[0] = 0 > this.dragging_rectangle[2] ? this.dragging_rectangle[0] - f : this.dragging_rectangle[0];
            this.dragging_rectangle[1] = c;
            this.dragging_rectangle[2] = f;
            this.dragging_rectangle[3] = h;
            h = [];
            for (c = 0; c < b.length; ++c) {
              f = b[c], f.getBounding(d), D(this.dragging_rectangle, d) && h.push(f);
            }
            h.length && this.selectNodes(h);
          }
          this.dragging_rectangle = null;
        } else {
          if (this.connecting_node) {
            this.dirty_bgcanvas = this.dirty_canvas = !0;
            if (f = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes)) {
              this.connecting_output.type == e.EVENT && this.isOverNodeBox(f, a.canvasX, a.canvasY) ? this.connecting_node.connect(this.connecting_slot, f, e.EVENT) : (b = this.isOverNodeInput(f, a.canvasX, a.canvasY), -1 != b ? this.connecting_node.connect(this.connecting_slot, f, b) : (b = f.getInputInfo(0), this.connecting_output.type == e.EVENT ? this.connecting_node.connect(this.connecting_slot, f, e.EVENT) : b && !b.links && e.isValidConnection(b.type && this.connecting_output.type) && this.connecting_node.connect(this.connecting_slot, 
              f, 0)));
            }
            this.connecting_node = this.connecting_pos = this.connecting_output = null;
            this.connecting_slot = -1;
          } else {
            if (this.resizing_node) {
              this.dirty_bgcanvas = this.dirty_canvas = !0, this.graph.afterChange(this.resizing_node), this.resizing_node = null;
            } else {
              if (this.node_dragged) {
                (f = this.node_dragged) && 300 > a.click_time && A(a.canvasX, a.canvasY, f.pos[0], f.pos[1] - e.NODE_TITLE_HEIGHT, e.NODE_TITLE_HEIGHT, e.NODE_TITLE_HEIGHT) && f.collapse();
                this.dirty_bgcanvas = this.dirty_canvas = !0;
                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
                (this.graph.config.align_to_grid || this.align_to_grid) && this.node_dragged.alignToGrid();
                if (this.onNodeMoved) {
                  this.onNodeMoved(this.node_dragged);
                }
                this.graph.afterChange(this.node_dragged);
                this.node_dragged = null;
              } else {
                f = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
                !f && 300 > a.click_time && this.deselectAllNodes();
                this.dirty_canvas = !0;
                this.dragging_canvas = !1;
                if (this.node_over && this.node_over.onMouseUp) {
                  this.node_over.onMouseUp(a, [a.canvasX - this.node_over.pos[0], a.canvasY - this.node_over.pos[1]], this);
                }
                if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
                  this.node_capturing_input.onMouseUp(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]]);
                }
              }
            }
          }
        }
      } else {
        2 == a.which ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : 3 == a.which && (this.dirty_canvas = !0, this.dragging_canvas = !1);
      }
      this.graph.change();
      a.stopPropagation();
      a.preventDefault();
      return !1;
    }
  };
  l.prototype.processMouseWheel = function(a) {
    if (this.graph && this.allow_dragcanvas) {
      var b = null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail;
      this.adjustMouseEvent(a);
      var d = a.localX, f = a.localY;
      if (!this.viewport || this.viewport && d >= this.viewport[0] && d < this.viewport[0] + this.viewport[2] && f >= this.viewport[1] && f < this.viewport[1] + this.viewport[3]) {
        return d = this.ds.scale, 0 < b ? d *= 1.1 : 0 > b && (d *= 1 / 1.1), this.ds.changeScale(d, [a.localX, a.localY]), this.graph.change(), a.preventDefault(), !1;
      }
    }
  };
  l.prototype.isOverNodeBox = function(a, b, d) {
    var f = e.NODE_TITLE_HEIGHT;
    return A(b, d, a.pos[0] + 2, a.pos[1] + 2 - f, f - 4, f - 4) ? !0 : !1;
  };
  l.prototype.isOverNodeInput = function(a, b, d, f) {
    if (a.inputs) {
      for (var h = 0, e = a.inputs.length; h < e; ++h) {
        var c = a.getConnectionPos(!0, h);
        if (a.horizontal ? A(b, d, c[0] - 5, c[1] - 10, 10, 20) : A(b, d, c[0] - 10, c[1] - 5, 40, 10)) {
          return f && (f[0] = c[0], f[1] = c[1]), h;
        }
      }
    }
    return -1;
  };
  l.prototype.processKey = function(a) {
    if (this.graph) {
      var b = !1;
      if ("input" != a.target.localName) {
        if ("keydown" == a.type) {
          if (32 == a.keyCode && (b = this.dragging_canvas = !0), 65 == a.keyCode && a.ctrlKey && (this.selectNodes(), b = !0), "KeyC" == a.code && (a.metaKey || a.ctrlKey) && !a.shiftKey && this.selected_nodes && (this.copyToClipboard(), b = !0), "KeyV" != a.code || !a.metaKey && !a.ctrlKey || a.shiftKey || this.pasteFromClipboard(), 46 != a.keyCode && 8 != a.keyCode || "input" == a.target.localName || "textarea" == a.target.localName || (this.deleteSelectedNodes(), b = !0), this.selected_nodes) {
            for (var d in this.selected_nodes) {
              if (this.selected_nodes[d].onKeyDown) {
                this.selected_nodes[d].onKeyDown(a);
              }
            }
          }
        } else {
          if ("keyup" == a.type && (32 == a.keyCode && (this.dragging_canvas = !1), this.selected_nodes)) {
            for (d in this.selected_nodes) {
              if (this.selected_nodes[d].onKeyUp) {
                this.selected_nodes[d].onKeyUp(a);
              }
            }
          }
        }
        this.graph.change();
        if (b) {
          return a.preventDefault(), a.stopImmediatePropagation(), !1;
        }
      }
    }
  };
  l.prototype.copyToClipboard = function() {
    var a = {nodes:[], links:[]}, b = 0, d = [], f;
    for (f in this.selected_nodes) {
      var h = this.selected_nodes[f];
      h._relative_id = b;
      d.push(h);
      b += 1;
    }
    for (f = 0; f < d.length; ++f) {
      if (h = d[f], b = h.clone()) {
        if (a.nodes.push(b.serialize()), h.inputs && h.inputs.length) {
          for (b = 0; b < h.inputs.length; ++b) {
            var e = h.inputs[b];
            if (e && null != e.links) {
              for (var c = 0; c < e.links.length; c++) {
                var r = this.graph.links[e.links[c]];
                if (r) {
                  var k = this.graph.getNodeById(r.origin_id);
                  k && this.selected_nodes[k.id] && a.links.push([k._relative_id, r.origin_slot, h._relative_id, r.target_slot]);
                }
              }
            }
          }
        }
      } else {
        console.warn("node type not found: " + h.type);
      }
    }
    localStorage.setItem("litegrapheditor_clipboard", JSON.stringify(a));
  };
  l.prototype.pasteFromClipboard = function() {
    var a = localStorage.getItem("litegrapheditor_clipboard");
    if (a) {
      this.graph.beforeChange();
      a = JSON.parse(a);
      for (var b = [], d = 0; d < a.nodes.length; ++d) {
        var f = a.nodes[d], h = e.createNode(f.type);
        h && (h.configure(f), h.pos[0] += 5, h.pos[1] += 5, this.graph.add(h), b.push(h));
      }
      for (d = 0; d < a.links.length; ++d) {
        f = a.links[d];
        h = b[f[0]];
        var c = b[f[2]];
        h && c ? h.connect(f[1], c, f[3]) : console.warn("Warning, nodes missing on pasting");
      }
      this.selectNodes(b);
      this.graph.afterChange();
    }
  };
  l.prototype.processDrop = function(a) {
    a.preventDefault();
    this.adjustMouseEvent(a);
    var b = a.localX, d = a.localY;
    if (!this.viewport || this.viewport && b >= this.viewport[0] && b < this.viewport[0] + this.viewport[2] && d >= this.viewport[1] && d < this.viewport[1] + this.viewport[3]) {
      b = [a.canvasX, a.canvasY];
      var f = this.graph ? this.graph.getNodeOnPos(b[0], b[1]) : null;
      if (f) {
        if ((f.onDropFile || f.onDropData) && (b = a.dataTransfer.files) && b.length) {
          for (d = 0; d < b.length; d++) {
            var h = a.dataTransfer.files[0], e = h.name;
            l.getFileExtension(e);
            if (f.onDropFile) {
              f.onDropFile(h);
            }
            if (f.onDropData) {
              var c = new FileReader;
              c.onload = function(a) {
                f.onDropData(a.target.result, e, h);
              };
              var r = h.type.split("/")[0];
              "text" == r || "" == r ? c.readAsText(h) : "image" == r ? c.readAsDataURL(h) : c.readAsArrayBuffer(h);
            }
          }
        }
        return f.onDropItem && f.onDropItem(event) ? !0 : this.onDropItem ? this.onDropItem(event) : !1;
      }
      b = null;
      this.onDropItem && (b = this.onDropItem(event));
      b || this.checkDropItem(a);
    }
  };
  l.prototype.checkDropItem = function(a) {
    if (a.dataTransfer.files.length) {
      var b = a.dataTransfer.files[0], d = l.getFileExtension(b.name).toLowerCase();
      if (d = e.node_types_by_file_extension[d]) {
        this.graph.beforeChange();
        d = e.createNode(d.type);
        d.pos = [a.canvasX, a.canvasY];
        this.graph.add(d);
        if (d.onDropFile) {
          d.onDropFile(b);
        }
        this.graph.afterChange();
      }
    }
  };
  l.prototype.processNodeDblClicked = function(a) {
    if (this.onShowNodePanel) {
      this.onShowNodePanel(a);
    } else {
      this.showShowNodePanel(a);
    }
    if (this.onNodeDblClicked) {
      this.onNodeDblClicked(a);
    }
    this.setDirty(!0);
  };
  l.prototype.processNodeSelected = function(a, b) {
    this.selectNode(a, b && b.shiftKey);
    if (this.onNodeSelected) {
      this.onNodeSelected(a);
    }
  };
  l.prototype.selectNode = function(a, b) {
    null == a ? this.deselectAllNodes() : this.selectNodes([a], b);
  };
  l.prototype.selectNodes = function(a, b) {
    b || this.deselectAllNodes();
    a = a || this.graph._nodes;
    for (b = 0; b < a.length; ++b) {
      var d = a[b];
      if (!d.is_selected) {
        if (!d.is_selected && d.onSelected) {
          d.onSelected();
        }
        d.is_selected = !0;
        this.selected_nodes[d.id] = d;
        if (d.inputs) {
          for (var f = 0; f < d.inputs.length; ++f) {
            this.highlighted_links[d.inputs[f].link] = !0;
          }
        }
        if (d.outputs) {
          for (f = 0; f < d.outputs.length; ++f) {
            var h = d.outputs[f];
            if (h.links) {
              for (var e = 0; e < h.links.length; ++e) {
                this.highlighted_links[h.links[e]] = !0;
              }
            }
          }
        }
      }
    }
    if (this.onSelectionChange) {
      this.onSelectionChange(this.selected_nodes);
    }
    this.setDirty(!0);
  };
  l.prototype.deselectNode = function(a) {
    if (a.is_selected) {
      if (a.onDeselected) {
        a.onDeselected();
      }
      a.is_selected = !1;
      if (this.onNodeDeselected) {
        this.onNodeDeselected(a);
      }
      if (a.inputs) {
        for (var b = 0; b < a.inputs.length; ++b) {
          var d = a.inputs[b];
          if (d.links) {
            for (var f = 0; f < d.links.length; ++f) {
              delete this.highlighted_links[d.links[f]];
            }
          }
        }
      }
      if (a.outputs) {
        for (b = 0; b < a.outputs.length; ++b) {
          if (d = a.outputs[b], d.links) {
            for (f = 0; f < d.links.length; ++f) {
              delete this.highlighted_links[d.links[f]];
            }
          }
        }
      }
    }
  };
  l.prototype.deselectAllNodes = function() {
    if (this.graph) {
      for (var a = this.graph._nodes, b = 0, d = a.length; b < d; ++b) {
        var f = a[b];
        if (f.is_selected) {
          if (f.onDeselected) {
            f.onDeselected();
          }
          f.is_selected = !1;
          if (this.onNodeDeselected) {
            this.onNodeDeselected(f);
          }
        }
      }
      this.selected_nodes = {};
      this.current_node = null;
      this.highlighted_links = {};
      if (this.onSelectionChange) {
        this.onSelectionChange(this.selected_nodes);
      }
      this.setDirty(!0);
    }
  };
  l.prototype.deleteSelectedNodes = function() {
    this.graph.beforeChange();
    for (var a in this.selected_nodes) {
      var b = this.selected_nodes[a];
      if (!b.block_delete) {
        if (b.inputs && b.inputs.length && b.outputs && b.outputs.length && e.isValidConnection(b.inputs[0].type, b.outputs[0].type) && b.inputs[0].links && b.outputs[0].links && b.outputs[0].links.length) {
          var d = b.graph.links[b.inputs[0].links[0]], f = b.graph.links[b.outputs[0].links[0]], h = b.getInputNode(0), c = b.getOutputNodes(0)[0];
          h && c && h.connect(d.origin_slot, c, f.target_slot);
        }
        this.graph.remove(b);
        if (this.onNodeDeselected) {
          this.onNodeDeselected(b);
        }
      }
    }
    this.selected_nodes = {};
    this.current_node = null;
    this.highlighted_links = {};
    this.setDirty(!0);
    this.graph.afterChange();
  };
  l.prototype.centerOnNode = function(a) {
    this.ds.offset[0] = -a.pos[0] - 0.5 * a.size[0] + 0.5 * this.canvas.width / this.ds.scale;
    this.ds.offset[1] = -a.pos[1] - 0.5 * a.size[1] + 0.5 * this.canvas.height / this.ds.scale;
    this.setDirty(!0, !0);
  };
  l.prototype.adjustMouseEvent = function(a) {
    if (this.canvas) {
      var b = this.canvas.getBoundingClientRect();
      a.localX = a.clientX - b.left;
      a.localY = a.clientY - b.top;
    } else {
      a.localX = a.clientX, a.localY = a.clientY;
    }
    a.deltaX = a.localX - this.last_mouse_position[0];
    a.deltaY = a.localY - this.last_mouse_position[1];
    this.last_mouse_position[0] = a.localX;
    this.last_mouse_position[1] = a.localY;
    a.canvasX = a.localX / this.ds.scale - this.ds.offset[0];
    a.canvasY = a.localY / this.ds.scale - this.ds.offset[1];
  };
  l.prototype.setZoom = function(a, b) {
    this.ds.changeScale(a, b);
    this.dirty_bgcanvas = this.dirty_canvas = !0;
  };
  l.prototype.convertOffsetToCanvas = function(a, b) {
    return this.ds.convertOffsetToCanvas(a, b);
  };
  l.prototype.convertCanvasToOffset = function(a, b) {
    return this.ds.convertCanvasToOffset(a, b);
  };
  l.prototype.convertEventToCanvasOffset = function(a) {
    var b = this.canvas.getBoundingClientRect();
    return this.convertCanvasToOffset([a.clientX - b.left, a.clientY - b.top]);
  };
  l.prototype.bringToFront = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.push(a));
  };
  l.prototype.sendToBack = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.unshift(a));
  };
  var z = new Float32Array(4);
  l.prototype.computeVisibleNodes = function(a, b) {
    b = b || [];
    b.length = 0;
    a = a || this.graph._nodes;
    for (var d = 0, f = a.length; d < f; ++d) {
      var h = a[d];
      (!this.live_mode || h.onDrawBackground || h.onDrawForeground) && D(this.visible_area, h.getBounding(z)) && b.push(h);
    }
    return b;
  };
  l.prototype.draw = function(a, b) {
    if (this.canvas && 0 != this.canvas.width && 0 != this.canvas.height) {
      var d = e.getTime();
      this.render_time = 0.001 * (d - this.last_draw_time);
      this.last_draw_time = d;
      this.graph && this.ds.computeVisibleArea(this.viewport);
      (this.dirty_bgcanvas || b || this.always_render_background || this.graph && this.graph._last_trigger_time && 1000 > d - this.graph._last_trigger_time) && this.drawBackCanvas();
      (this.dirty_canvas || a) && this.drawFrontCanvas();
      this.fps = this.render_time ? 1.0 / this.render_time : 0;
      this.frame += 1;
    }
  };
  l.prototype.drawFrontCanvas = function() {
    this.dirty_canvas = !1;
    this.ctx || (this.ctx = this.bgcanvas.getContext("2d"));
    var a = this.ctx;
    if (a) {
      var b = this.canvas;
      a.start2D && !this.viewport && (a.start2D(), a.restore(), a.setTransform(1, 0, 0, 1, 0, 0));
      var d = this.viewport || this.dirty_area;
      d && (a.save(), a.beginPath(), a.rect(d[0], d[1], d[2], d[3]), a.clip());
      this.clear_background && (d ? a.clearRect(d[0], d[1], d[2], d[3]) : a.clearRect(0, 0, b.width, b.height));
      this.bgcanvas == this.canvas ? this.drawBackCanvas() : a.drawImage(this.bgcanvas, 0, 0);
      if (this.onRender) {
        this.onRender(b, a);
      }
      this.show_info && this.renderInfo(a, d ? d[0] : 0, d ? d[1] : 0);
      if (this.graph) {
        a.save();
        this.ds.toCanvasContext(a);
        b = this.computeVisibleNodes(null, this.visible_nodes);
        for (var f = 0; f < b.length; ++f) {
          var h = b[f];
          a.save();
          a.translate(h.pos[0], h.pos[1]);
          this.drawNode(h, a);
          a.restore();
        }
        this.render_execution_order && this.drawExecutionOrder(a);
        this.graph.config.links_ontop && (this.live_mode || this.drawConnections(a));
        if (null != this.connecting_pos) {
          a.lineWidth = this.connections_width;
          switch(this.connecting_output.type) {
            case e.EVENT:
              b = e.EVENT_LINK_COLOR;
              break;
            default:
              b = e.CONNECTING_LINK_COLOR;
          }
          this.renderLink(a, this.connecting_pos, [this.graph_mouse[0], this.graph_mouse[1]], null, !1, null, b, this.connecting_output.dir || (this.connecting_node.horizontal ? e.DOWN : e.RIGHT), e.CENTER);
          a.beginPath();
          this.connecting_output.type === e.EVENT || this.connecting_output.shape === e.BOX_SHAPE ? a.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10) : this.connecting_output.shape === e.ARROW_SHAPE ? (a.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5), a.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5), a.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5), a.closePath()) : a.arc(this.connecting_pos[0], this.connecting_pos[1], 
          4, 0, 2 * Math.PI);
          a.fill();
          a.fillStyle = "#ffcc00";
          this._highlight_input && (a.beginPath(), this._highlight_input_slot.shape === e.ARROW_SHAPE ? (a.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5), a.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5), a.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5), a.closePath()) : a.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, 2 * Math.PI), a.fill());
        }
        this.dragging_rectangle && (a.strokeStyle = "#FFF", a.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3]));
        if (this.over_link_center && this.render_link_tooltip) {
          this.drawLinkTooltip(a, this.over_link_center);
        } else {
          if (this.onDrawLinkTooltip) {
            this.onDrawLinkTooltip(a, null);
          }
        }
        if (this.onDrawForeground) {
          this.onDrawForeground(a, this.visible_rect);
        }
        a.restore();
      }
      this._graph_stack && this._graph_stack.length && this.drawSubgraphPanel(a);
      if (this.onDrawOverlay) {
        this.onDrawOverlay(a);
      }
      d && a.restore();
      a.finish2D && a.finish2D();
    }
  };
  l.prototype.drawSubgraphPanel = function(a) {
    var b = this.graph, d = b._subgraph_node;
    if (d) {
      var f = d.inputs ? d.inputs.length : 0, h = Math.floor(1.6 * e.NODE_SLOT_HEIGHT);
      a.fillStyle = "#111";
      a.globalAlpha = 0.8;
      a.beginPath();
      a.roundRect(10, 10, 300, (f + 1) * h + 50, 8);
      a.fill();
      a.globalAlpha = 1;
      a.fillStyle = "#888";
      a.font = "14px Arial";
      a.textAlign = "left";
      a.fillText("Graph Inputs", 20, 34);
      if (this.drawButton(280, 20, 20, 20, "X", "#151515")) {
        this.closeSubgraph();
      } else {
        f = 50;
        a.font = "20px Arial";
        if (d.inputs) {
          for (var c = 0; c < d.inputs.length; ++c) {
            var v = d.inputs[c];
            if (!v.not_subgraph_input) {
              if (this.drawButton(20, f + 2, 280, h - 2)) {
                var r = d.constructor.input_node_type || "graph/input";
                this.graph.beforeChange();
                var k = e.createNode(r);
                k ? (b.add(k), this.block_click = !1, this.last_click_position = null, this.selectNodes([k]), this.node_dragged = k, this.dragging_canvas = !1, k.setProperty("name", v.name), k.setProperty("type", v.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : console.error("graph input node not found:", r);
              }
              a.fillStyle = "#9C9";
              a.beginPath();
              a.arc(284, f + 0.5 * h, 5, 0, 2 * Math.PI);
              a.fill();
              a.fillStyle = "#AAA";
              a.fillText(v.name, 50, f + 0.75 * h);
              r = a.measureText(v.name);
              a.fillStyle = "#777";
              a.fillText(v.type, 50 + r.width + 10, f + 0.75 * h);
              f += h;
            }
          }
        }
        this.drawButton(20, f + 2, 280, h - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialog(d);
      }
    } else {
      console.warn("subgraph without subnode");
    }
  };
  l.prototype.drawButton = function(a, b, d, f, h, c, v, r) {
    var k = this.ctx;
    c = c || e.NODE_DEFAULT_COLOR;
    v = v || "#555";
    r = r || e.NODE_TEXT_COLOR;
    var w = this.mouse, t = e.isInsideRectangle(w[0], w[1], a, b, d, f);
    w = (w = this.last_click_position) && e.isInsideRectangle(w[0], w[1], a, b, d, f);
    k.fillStyle = t ? v : c;
    w && (k.fillStyle = "#AAA");
    k.beginPath();
    k.roundRect(a, b, d, f, 4);
    k.fill();
    null != h && h.constructor == String && (k.fillStyle = r, k.textAlign = "center", k.font = (0.65 * f | 0) + "px Arial", k.fillText(h, a + 0.5 * d, b + 0.75 * f), k.textAlign = "left");
    a = w && !this.block_click;
    w && this.blockClick();
    return a;
  };
  l.prototype.isAreaClicked = function(a, b, d, f, h) {
    var c = this.mouse;
    e.isInsideRectangle(c[0], c[1], a, b, d, f);
    b = (a = (c = this.last_click_position) && e.isInsideRectangle(c[0], c[1], a, b, d, f)) && !this.block_click;
    a && h && this.blockClick();
    return b;
  };
  l.prototype.renderInfo = function(a, b, d) {
    b = b || 10;
    d = d || this.canvas.height - 80;
    a.save();
    a.translate(b, d);
    a.font = "10px Arial";
    a.fillStyle = "#888";
    a.textAlign = "left";
    this.graph ? (a.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), a.fillText("I: " + this.graph.iteration, 5, 26), a.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 39), a.fillText("V: " + this.graph._version, 5, 52), a.fillText("FPS:" + this.fps.toFixed(2), 5, 65)) : a.fillText("No graph selected", 5, 13);
    a.restore();
  };
  l.prototype.drawBackCanvas = function() {
    var a = this.bgcanvas;
    if (a.width != this.canvas.width || a.height != this.canvas.height) {
      a.width = this.canvas.width, a.height = this.canvas.height;
    }
    this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d"));
    var b = this.bgctx;
    b.start && b.start();
    var d = this.viewport || [0, 0, b.canvas.width, b.canvas.height];
    this.clear_background && b.clearRect(d[0], d[1], d[2], d[3]);
    if (this._graph_stack && this._graph_stack.length) {
      b.save();
      d = this.graph._subgraph_node;
      b.strokeStyle = d.bgcolor;
      b.lineWidth = 10;
      b.strokeRect(1, 1, a.width - 2, a.height - 2);
      b.lineWidth = 1;
      b.font = "40px Arial";
      b.textAlign = "center";
      b.fillStyle = d.bgcolor || "#AAA";
      for (var f = "", h = 1; h < this._graph_stack.length; ++h) {
        f += this._graph_stack[h]._subgraph_node.getTitle() + " >> ";
      }
      b.fillText(f + d.getTitle(), 0.5 * a.width, 40);
      b.restore();
    }
    d = !1;
    this.onRenderBackground && (d = this.onRenderBackground(a, b));
    this.viewport || (b.restore(), b.setTransform(1, 0, 0, 1, 0, 0));
    this.visible_links.length = 0;
    if (this.graph) {
      b.save();
      this.ds.toCanvasContext(b);
      if (this.background_image && 0.5 < this.ds.scale && !d) {
        b.globalAlpha = this.zoom_modify_alpha ? (1.0 - 0.5 / this.ds.scale) * this.editor_alpha : this.editor_alpha;
        b.imageSmoothingEnabled = b.mozImageSmoothingEnabled = b.imageSmoothingEnabled = !1;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image;
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          var e = this;
          this._bg_img.onload = function() {
            e.draw(!0, !0);
          };
        }
        d = null;
        null == this._pattern && 0 < this._bg_img.width ? (d = b.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = d) : d = this._pattern;
        d && (b.fillStyle = d, b.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]), b.fillStyle = "transparent");
        b.globalAlpha = 1.0;
        b.imageSmoothingEnabled = b.mozImageSmoothingEnabled = b.imageSmoothingEnabled = !0;
      }
      this.graph._groups.length && !this.live_mode && this.drawGroups(a, b);
      if (this.onDrawBackground) {
        this.onDrawBackground(b, this.visible_area);
      }
      this.onBackgroundRender && (console.error("WARNING! onBackgroundRender deprecated, now is named onDrawBackground "), this.onBackgroundRender = null);
      this.render_canvas_border && (b.strokeStyle = "#235", b.strokeRect(0, 0, a.width, a.height));
      this.render_connections_shadows ? (b.shadowColor = "#000", b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = 6) : b.shadowColor = "rgba(0,0,0,0)";
      this.live_mode || this.drawConnections(b);
      b.shadowColor = "rgba(0,0,0,0)";
      b.restore();
    }
    b.finish && b.finish();
    this.dirty_bgcanvas = !1;
    this.dirty_canvas = !0;
  };
  var H = new Float32Array(2);
  l.prototype.drawNode = function(a, b) {
    this.current_node = a;
    var d = a.color || a.constructor.color || e.NODE_DEFAULT_COLOR, f = a.bgcolor || a.constructor.bgcolor || e.NODE_DEFAULT_BGCOLOR, h = 0.6 > this.ds.scale;
    if (this.live_mode) {
      if (!a.flags.collapsed && (b.shadowColor = "transparent", a.onDrawForeground)) {
        a.onDrawForeground(b, this, this.canvas);
      }
    } else {
      var c = this.editor_alpha;
      b.globalAlpha = c;
      this.render_shadows && !h ? (b.shadowColor = e.DEFAULT_SHADOW_COLOR, b.shadowOffsetX = 2 * this.ds.scale, b.shadowOffsetY = 2 * this.ds.scale, b.shadowBlur = 3 * this.ds.scale) : b.shadowColor = "transparent";
      if (!a.flags.collapsed || !a.onDrawCollapsed || 1 != a.onDrawCollapsed(b, this)) {
        var k = a._shape || e.BOX_SHAPE;
        H.set(a.size);
        var r = a.horizontal;
        if (a.flags.collapsed) {
          b.font = this.inner_text_font;
          var t = a.getTitle ? a.getTitle() : a.title;
          null != t && (a._collapsed_width = Math.min(a.size[0], b.measureText(t).width + 2 * e.NODE_TITLE_HEIGHT), H[0] = a._collapsed_width, H[1] = 0);
        }
        a.clip_area && (b.save(), b.beginPath(), k == e.BOX_SHAPE ? b.rect(0, 0, H[0], H[1]) : k == e.ROUND_SHAPE ? b.roundRect(0, 0, H[0], H[1], 10) : k == e.CIRCLE_SHAPE && b.arc(0.5 * H[0], 0.5 * H[1], 0.5 * H[0], 0, 2 * Math.PI), b.clip());
        a.has_errors && (f = "red");
        this.drawNodeShape(a, b, H, d, f, a.is_selected, a.mouseOver);
        b.shadowColor = "transparent";
        if (a.onDrawForeground) {
          a.onDrawForeground(b, this, this.canvas);
        }
        b.textAlign = r ? "center" : "left";
        b.font = this.inner_text_font;
        f = !h;
        k = this.connecting_output;
        b.lineWidth = 1;
        t = 0;
        var q = new Float32Array(2);
        if (!a.flags.collapsed) {
          if (a.inputs) {
            for (d = 0; d < a.inputs.length; d++) {
              var l = a.inputs[d];
              b.globalAlpha = c;
              this.connecting_node && !e.isValidConnection(l.type, k.type) && (b.globalAlpha = 0.4 * c);
              b.fillStyle = null != l.links ? l.color_on || this.default_connection_color.input_on : l.color_off || this.default_connection_color.input_off;
              var C = a.getConnectionPos(!0, d, q);
              C[0] -= a.pos[0];
              C[1] -= a.pos[1];
              t < C[1] + 0.5 * e.NODE_SLOT_HEIGHT && (t = C[1] + 0.5 * e.NODE_SLOT_HEIGHT);
              b.beginPath();
              l.type === e.EVENT || l.shape === e.BOX_SHAPE ? r ? b.rect(C[0] - 5 + 0.5, C[1] - 8 + 0.5, 10, 14) : b.rect(C[0] - 6 + 0.5, C[1] - 5 + 0.5, 14, 10) : l.shape === e.ARROW_SHAPE ? (b.moveTo(C[0] + 8, C[1] + 0.5), b.lineTo(C[0] - 4, C[1] + 6 + 0.5), b.lineTo(C[0] - 4, C[1] - 6 + 0.5), b.closePath()) : h ? b.rect(C[0] - 4, C[1] - 4, 8, 8) : b.arc(C[0], C[1], 4, 0, 2 * Math.PI);
              b.fill();
              if (f) {
                var J = null != l.label ? l.label : l.name;
                J && (b.fillStyle = e.NODE_TEXT_COLOR, r || l.dir == e.UP ? b.fillText(J, C[0], C[1] - 10) : b.fillText(J, C[0] + 10, C[1] + 5));
              }
            }
          }
          this.connecting_node && (b.globalAlpha = 0.4 * c);
          b.textAlign = r ? "center" : "right";
          b.strokeStyle = "black";
          if (a.outputs) {
            for (d = 0; d < a.outputs.length; d++) {
              if (l = a.outputs[d], C = a.getConnectionPos(!1, d, q), C[0] -= a.pos[0], C[1] -= a.pos[1], t < C[1] + 0.5 * e.NODE_SLOT_HEIGHT && (t = C[1] + 0.5 * e.NODE_SLOT_HEIGHT), b.fillStyle = l.links && l.links.length ? l.color_on || this.default_connection_color.output_on : l.color_off || this.default_connection_color.output_off, b.beginPath(), l.type === e.EVENT || l.shape === e.BOX_SHAPE ? r ? b.rect(C[0] - 5 + 0.5, C[1] - 8 + 0.5, 10, 14) : b.rect(C[0] - 6 + 0.5, C[1] - 5 + 0.5, 14, 10) : 
              l.shape === e.ARROW_SHAPE ? (b.moveTo(C[0] + 8, C[1] + 0.5), b.lineTo(C[0] - 4, C[1] + 6 + 0.5), b.lineTo(C[0] - 4, C[1] - 6 + 0.5), b.closePath()) : h ? b.rect(C[0] - 4, C[1] - 4, 8, 8) : b.arc(C[0], C[1], 4, 0, 2 * Math.PI), b.fill(), h || b.stroke(), f && (J = null != l.label ? l.label : l.name)) {
                b.fillStyle = e.NODE_TEXT_COLOR, r || l.dir == e.DOWN ? b.fillText(J, C[0], C[1] - 8) : b.fillText(J, C[0] - 10, C[1] + 5);
              }
            }
          }
          b.textAlign = "left";
          b.globalAlpha = 1;
          if (a.widgets) {
            l = t;
            if (r || a.widgets_up) {
              l = 2;
            }
            null != a.widgets_start_y && (l = a.widgets_start_y);
            this.drawNodeWidgets(a, l, b, this.node_widget && this.node_widget[0] == a ? this.node_widget[1] : null);
          }
        } else {
          if (this.render_collapsed_slots) {
            h = c = null;
            if (a.inputs) {
              for (d = 0; d < a.inputs.length; d++) {
                if (l = a.inputs[d], null != l.links) {
                  c = l;
                  break;
                }
              }
            }
            if (a.outputs) {
              for (d = 0; d < a.outputs.length; d++) {
                l = a.outputs[d], l.links && l.links.length && (h = l);
              }
            }
            c && (c = 0, d = -0.5 * e.NODE_TITLE_HEIGHT, r && (c = 0.5 * a._collapsed_width, d = -e.NODE_TITLE_HEIGHT), b.fillStyle = "#686", b.beginPath(), l.type === e.EVENT || l.shape === e.BOX_SHAPE ? b.rect(c - 7 + 0.5, d - 4, 14, 8) : l.shape === e.ARROW_SHAPE ? (b.moveTo(c + 8, d), b.lineTo(c + -4, d - 4), b.lineTo(c + -4, d + 4), b.closePath()) : b.arc(c, d, 4, 0, 2 * Math.PI), b.fill());
            h && (c = a._collapsed_width, d = -0.5 * e.NODE_TITLE_HEIGHT, r && (c = 0.5 * a._collapsed_width, d = 0), b.fillStyle = "#686", b.strokeStyle = "black", b.beginPath(), l.type === e.EVENT || l.shape === e.BOX_SHAPE ? b.rect(c - 7 + 0.5, d - 4, 14, 8) : l.shape === e.ARROW_SHAPE ? (b.moveTo(c + 6, d), b.lineTo(c - 6, d - 4), b.lineTo(c - 6, d + 4), b.closePath()) : b.arc(c, d, 4, 0, 2 * Math.PI), b.fill());
          }
        }
        a.clip_area && b.restore();
        b.globalAlpha = 1.0;
      }
    }
  };
  l.prototype.drawLinkTooltip = function(a, b) {
    var d = b._pos;
    a.fillStyle = "black";
    a.beginPath();
    a.arc(d[0], d[1], 3, 0, 2 * Math.PI);
    a.fill();
    if (null != b.data && (!this.onDrawLinkTooltip || 1 != this.onDrawLinkTooltip(a, b, this)) && (b = b.data, b = b.constructor === Number ? b.toFixed(2) : b.constructor === String ? '"' + b + '"' : b.constructor === Boolean ? String(b) : b.toToolTip ? b.toToolTip() : "[" + b.constructor.name + "]", null != b)) {
      b = b.substr(0, 30);
      a.font = "14px Courier New";
      var f = a.measureText(b).width + 20;
      a.shadowColor = "black";
      a.shadowOffsetX = 2;
      a.shadowOffsetY = 2;
      a.shadowBlur = 3;
      a.fillStyle = "#454";
      a.beginPath();
      a.roundRect(d[0] - 0.5 * f, d[1] - 15 - 24, f, 24, 3, 3);
      a.moveTo(d[0] - 10, d[1] - 15);
      a.lineTo(d[0] + 10, d[1] - 15);
      a.lineTo(d[0], d[1] - 5);
      a.fill();
      a.shadowColor = "transparent";
      a.textAlign = "center";
      a.fillStyle = "#CEC";
      a.fillText(b, d[0], d[1] - 15 - 24 * 0.3);
    }
  };
  var x = new Float32Array(4);
  l.prototype.drawNodeShape = function(a, b, d, f, h, c, k) {
    b.strokeStyle = f;
    b.fillStyle = h;
    h = e.NODE_TITLE_HEIGHT;
    var r = 0.5 > this.ds.scale, v = a._shape || a.constructor.shape || e.ROUND_SHAPE, t = a.constructor.title_mode, w = !0;
    t == e.TRANSPARENT_TITLE ? w = !1 : t == e.AUTOHIDE_TITLE && k && (w = !0);
    x[0] = 0;
    x[1] = w ? -h : 0;
    x[2] = d[0] + 1;
    x[3] = w ? d[1] + h : d[1];
    k = b.globalAlpha;
    b.beginPath();
    v == e.BOX_SHAPE || r ? b.fillRect(x[0], x[1], x[2], x[3]) : v == e.ROUND_SHAPE || v == e.CARD_SHAPE ? b.roundRect(x[0], x[1], x[2], x[3], this.round_radius, v == e.CARD_SHAPE ? 0 : this.round_radius) : v == e.CIRCLE_SHAPE && b.arc(0.5 * d[0], 0.5 * d[1], 0.5 * d[0], 0, 2 * Math.PI);
    b.fill();
    a.flags.collapsed || (b.shadowColor = "transparent", b.fillStyle = "rgba(0,0,0,0.2)", b.fillRect(0, -1, x[2], 2));
    b.shadowColor = "transparent";
    if (a.onDrawBackground) {
      a.onDrawBackground(b, this, this.canvas, this.graph_mouse);
    }
    if (w || t == e.TRANSPARENT_TITLE) {
      if (a.onDrawTitleBar) {
        a.onDrawTitleBar(b, h, d, this.ds.scale, f);
      } else {
        if (t != e.TRANSPARENT_TITLE && (a.constructor.title_color || this.render_title_colored)) {
          w = a.constructor.title_color || f;
          a.flags.collapsed && (b.shadowColor = e.DEFAULT_SHADOW_COLOR);
          if (this.use_gradients) {
            var q = l.gradients[w];
            q || (q = l.gradients[w] = b.createLinearGradient(0, 0, 400, 0), q.addColorStop(0, w), q.addColorStop(1, "#000"));
            b.fillStyle = q;
          } else {
            b.fillStyle = w;
          }
          b.beginPath();
          v == e.BOX_SHAPE || r ? b.rect(0, -h, d[0] + 1, h) : (v == e.ROUND_SHAPE || v == e.CARD_SHAPE) && b.roundRect(0, -h, d[0] + 1, h, this.round_radius, a.flags.collapsed ? this.round_radius : 0);
          b.fill();
          b.shadowColor = "transparent";
        }
      }
      if (a.onDrawTitleBox) {
        a.onDrawTitleBox(b, h, d, this.ds.scale);
      } else {
        v == e.ROUND_SHAPE || v == e.CIRCLE_SHAPE || v == e.CARD_SHAPE ? (r && (b.fillStyle = "black", b.beginPath(), b.arc(0.5 * h, -0.5 * h, 6, 0, 2 * Math.PI), b.fill()), b.fillStyle = a.boxcolor || e.NODE_DEFAULT_BOXCOLOR, r ? b.fillRect(0.5 * h - 5, -0.5 * h - 5, 10, 10) : (b.beginPath(), b.arc(0.5 * h, -0.5 * h, 5, 0, 2 * Math.PI), b.fill())) : (r && (b.fillStyle = "black", b.fillRect(0.5 * (h - 10) - 1, -0.5 * (h + 10) - 1, 12, 12)), b.fillStyle = a.boxcolor || e.NODE_DEFAULT_BOXCOLOR, b.fillRect(0.5 * 
        (h - 10), -0.5 * (h + 10), 10, 10));
      }
      b.globalAlpha = k;
      if (a.onDrawTitleText) {
        a.onDrawTitleText(b, h, d, this.ds.scale, this.title_text_font, c);
      }
      !r && (b.font = this.title_text_font, k = String(a.getTitle())) && (b.fillStyle = c ? e.NODE_SELECTED_TITLE_COLOR : a.constructor.title_text_color || this.node_title_color, a.flags.collapsed ? (b.textAlign = "left", b.measureText(k), b.fillText(k.substr(0, 20), h, e.NODE_TITLE_TEXT_Y - h), b.textAlign = "left") : (b.textAlign = "left", b.fillText(k, h, e.NODE_TITLE_TEXT_Y - h)));
      a.flags.collapsed || !a.subgraph || a.skip_subgraph_button || (k = e.NODE_TITLE_HEIGHT, w = a.size[0] - k, q = e.isInsideRectangle(this.graph_mouse[0] - a.pos[0], this.graph_mouse[1] - a.pos[1], w + 2, -k + 2, k - 4, k - 4), b.fillStyle = q ? "#888" : "#555", v == e.BOX_SHAPE || r ? b.fillRect(w + 2, -k + 2, k - 4, k - 4) : (b.beginPath(), b.roundRect(w + 2, -k + 2, k - 4, k - 4, 4), b.fill()), b.fillStyle = "#333", b.beginPath(), b.moveTo(w + 0.2 * k, 0.6 * -k), b.lineTo(w + 0.8 * k, 0.6 * 
      -k), b.lineTo(w + 0.5 * k, 0.3 * -k), b.fill());
      if (a.onDrawTitle) {
        a.onDrawTitle(b);
      }
    }
    if (c) {
      if (a.onBounding) {
        a.onBounding(x);
      }
      t == e.TRANSPARENT_TITLE && (x[1] -= h, x[3] += h);
      b.lineWidth = 1;
      b.globalAlpha = 0.8;
      b.beginPath();
      v == e.BOX_SHAPE ? b.rect(-6 + x[0], -6 + x[1], 12 + x[2], 12 + x[3]) : v == e.ROUND_SHAPE || v == e.CARD_SHAPE && a.flags.collapsed ? b.roundRect(-6 + x[0], -6 + x[1], 12 + x[2], 12 + x[3], 2 * this.round_radius) : v == e.CARD_SHAPE ? b.roundRect(-6 + x[0], -6 + x[1], 12 + x[2], 12 + x[3], 2 * this.round_radius, 2) : v == e.CIRCLE_SHAPE && b.arc(0.5 * d[0], 0.5 * d[1], 0.5 * d[0] + 6, 0, 2 * Math.PI);
      b.strokeStyle = e.NODE_BOX_OUTLINE_COLOR;
      b.stroke();
      b.strokeStyle = f;
      b.globalAlpha = 1;
    }
  };
  var K = new Float32Array(4), k = new Float32Array(4), q = new Float32Array(2), t = new Float32Array(2);
  l.prototype.drawConnections = function(a) {
    var b = e.getTime(), d = this.visible_area;
    K[0] = d[0] - 20;
    K[1] = d[1] - 20;
    K[2] = d[2] + 40;
    K[3] = d[3] + 40;
    a.lineWidth = this.connections_width;
    a.fillStyle = "#AAA";
    a.strokeStyle = "#AAA";
    a.globalAlpha = this.editor_alpha;
    d = this.graph._nodes;
    for (var f = 0, h = d.length; f < h; ++f) {
      var c = d[f];
      if (c.inputs && c.inputs.length) {
        for (var v = 0; v < c.inputs.length; ++v) {
          var r = c.inputs[v];
          if (r && null != r.links) {
            for (var l = 0; l < r.links.length; l++) {
              var g = this.graph.links[r.links[l]];
              if (g) {
                var z = this.graph.getNodeById(g.origin_id);
                if (null != z) {
                  var C = g.origin_slot;
                  var J = -1 == C ? [z.pos[0] + 10, z.pos[1] + 10] : z.getConnectionPos(!1, C, q);
                  var E = c.getConnectionPos(!0, v, t);
                  k[0] = J[0];
                  k[1] = J[1];
                  k[2] = E[0] - J[0];
                  k[3] = E[1] - J[1];
                  0 > k[2] && (k[0] += k[2], k[2] = Math.abs(k[2]));
                  0 > k[3] && (k[1] += k[3], k[3] = Math.abs(k[3]));
                  if (D(k, K)) {
                    var I = z.outputs[C];
                    C = c.inputs[v];
                    if (I && C && (z = I.dir || (z.horizontal ? e.DOWN : e.RIGHT), C = C.dir || (c.horizontal ? e.UP : e.LEFT), this.renderLink(a, J, E, g, !1, 0, null, z, C), g && g._last_time && 1000 > b - g._last_time)) {
                      I = 2.0 - 0.002 * (b - g._last_time);
                      var P = a.globalAlpha;
                      a.globalAlpha = P * I;
                      this.renderLink(a, J, E, g, !0, I, "white", z, C);
                      a.globalAlpha = P;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    a.globalAlpha = 1;
  };
  l.prototype.renderLink = function(a, b, d, f, h, c, k, r, t, q) {
    f && this.visible_links.push(f);
    !k && f && (k = f.color || l.link_type_colors[f.type]);
    k || (k = this.default_link_color);
    null != f && this.highlighted_links[f.id] && (k = "#FFF");
    r = r || e.RIGHT;
    t = t || e.LEFT;
    var v = G(b, d);
    this.render_connections_border && 0.6 < this.ds.scale && (a.lineWidth = this.connections_width + 4);
    a.lineJoin = "round";
    q = q || 1;
    1 < q && (a.lineWidth = 0.5);
    a.beginPath();
    for (var w = 0; w < q; w += 1) {
      var J = 5 * (w - 0.5 * (q - 1));
      if (this.links_render_mode == e.SPLINE_LINK) {
        a.moveTo(b[0], b[1] + J);
        var E = 0, I = 0, g = 0, N = 0;
        switch(r) {
          case e.LEFT:
            E = -0.25 * v;
            break;
          case e.RIGHT:
            E = 0.25 * v;
            break;
          case e.UP:
            I = -0.25 * v;
            break;
          case e.DOWN:
            I = 0.25 * v;
        }
        switch(t) {
          case e.LEFT:
            g = -0.25 * v;
            break;
          case e.RIGHT:
            g = 0.25 * v;
            break;
          case e.UP:
            N = -0.25 * v;
            break;
          case e.DOWN:
            N = 0.25 * v;
        }
        a.bezierCurveTo(b[0] + E, b[1] + I + J, d[0] + g, d[1] + N + J, d[0], d[1] + J);
      } else {
        if (this.links_render_mode == e.LINEAR_LINK) {
          a.moveTo(b[0], b[1] + J);
          N = g = I = E = 0;
          switch(r) {
            case e.LEFT:
              E = -1;
              break;
            case e.RIGHT:
              E = 1;
              break;
            case e.UP:
              I = -1;
              break;
            case e.DOWN:
              I = 1;
          }
          switch(t) {
            case e.LEFT:
              g = -1;
              break;
            case e.RIGHT:
              g = 1;
              break;
            case e.UP:
              N = -1;
              break;
            case e.DOWN:
              N = 1;
          }
          a.lineTo(b[0] + 15 * E, b[1] + 15 * I + J);
          a.lineTo(d[0] + 15 * g, d[1] + 15 * N + J);
          a.lineTo(d[0], d[1] + J);
        } else {
          if (this.links_render_mode == e.STRAIGHT_LINK) {
            a.moveTo(b[0], b[1]), J = b[0], E = b[1], I = d[0], g = d[1], r == e.RIGHT ? J += 10 : E += 10, t == e.LEFT ? I -= 10 : g -= 10, a.lineTo(J, E), a.lineTo(0.5 * (J + I), E), a.lineTo(0.5 * (J + I), g), a.lineTo(I, g), a.lineTo(d[0], d[1]);
          } else {
            return;
          }
        }
      }
    }
    this.render_connections_border && 0.6 < this.ds.scale && !h && (a.strokeStyle = "rgba(0,0,0,0.5)", a.stroke());
    a.lineWidth = this.connections_width;
    a.fillStyle = a.strokeStyle = k;
    a.stroke();
    h = this.computeConnectionPoint(b, d, 0.5, r, t);
    f && f._pos && (f._pos[0] = h[0], f._pos[1] = h[1]);
    0.6 <= this.ds.scale && this.highquality_render && t != e.CENTER && (this.render_connection_arrows && (w = this.computeConnectionPoint(b, d, 0.25, r, t), v = this.computeConnectionPoint(b, d, 0.26, r, t), f = this.computeConnectionPoint(b, d, 0.75, r, t), q = this.computeConnectionPoint(b, d, 0.76, r, t), this.render_curved_connections ? (v = -Math.atan2(v[0] - w[0], v[1] - w[1]), q = -Math.atan2(q[0] - f[0], q[1] - f[1])) : q = v = d[1] > b[1] ? 0 : Math.PI, a.save(), a.translate(w[0], w[1]), 
    a.rotate(v), a.beginPath(), a.moveTo(-5, -3), a.lineTo(0, 7), a.lineTo(5, -3), a.fill(), a.restore(), a.save(), a.translate(f[0], f[1]), a.rotate(q), a.beginPath(), a.moveTo(-5, -3), a.lineTo(0, 7), a.lineTo(5, -3), a.fill(), a.restore()), a.beginPath(), a.arc(h[0], h[1], 5, 0, 2 * Math.PI), a.fill());
    if (c) {
      for (a.fillStyle = k, w = 0; 5 > w; ++w) {
        c = (0.001 * e.getTime() + 0.2 * w) % 1, h = this.computeConnectionPoint(b, d, c, r, t), a.beginPath(), a.arc(h[0], h[1], 5, 0, 2 * Math.PI), a.fill();
      }
    }
  };
  l.prototype.computeConnectionPoint = function(a, b, d, f, h) {
    f = f || e.RIGHT;
    h = h || e.LEFT;
    var c = G(a, b), k = [a[0], a[1]], r = [b[0], b[1]];
    switch(f) {
      case e.LEFT:
        k[0] += -0.25 * c;
        break;
      case e.RIGHT:
        k[0] += 0.25 * c;
        break;
      case e.UP:
        k[1] += -0.25 * c;
        break;
      case e.DOWN:
        k[1] += 0.25 * c;
    }
    switch(h) {
      case e.LEFT:
        r[0] += -0.25 * c;
        break;
      case e.RIGHT:
        r[0] += 0.25 * c;
        break;
      case e.UP:
        r[1] += -0.25 * c;
        break;
      case e.DOWN:
        r[1] += 0.25 * c;
    }
    f = (1 - d) * (1 - d) * (1 - d);
    h = 3 * (1 - d) * (1 - d) * d;
    c = 3 * (1 - d) * d * d;
    d *= d * d;
    return [f * a[0] + h * k[0] + c * r[0] + d * b[0], f * a[1] + h * k[1] + c * r[1] + d * b[1]];
  };
  l.prototype.drawExecutionOrder = function(a) {
    a.shadowColor = "transparent";
    a.globalAlpha = 0.25;
    a.textAlign = "center";
    a.strokeStyle = "white";
    a.globalAlpha = 0.75;
    for (var b = this.visible_nodes, d = 0; d < b.length; ++d) {
      var f = b[d];
      a.fillStyle = "black";
      a.fillRect(f.pos[0] - e.NODE_TITLE_HEIGHT, f.pos[1] - e.NODE_TITLE_HEIGHT, e.NODE_TITLE_HEIGHT, e.NODE_TITLE_HEIGHT);
      0 == f.order && a.strokeRect(f.pos[0] - e.NODE_TITLE_HEIGHT + 0.5, f.pos[1] - e.NODE_TITLE_HEIGHT + 0.5, e.NODE_TITLE_HEIGHT, e.NODE_TITLE_HEIGHT);
      a.fillStyle = "#FFF";
      a.fillText(f.order, f.pos[0] + -0.5 * e.NODE_TITLE_HEIGHT, f.pos[1] - 6);
    }
    a.globalAlpha = 1;
  };
  l.prototype.drawNodeWidgets = function(a, b, d, f) {
    if (!a.widgets || !a.widgets.length) {
      return 0;
    }
    var h = a.size[0], c = a.widgets;
    b += 2;
    var k = e.NODE_WIDGET_HEIGHT, r = 0.5 < this.ds.scale;
    d.save();
    d.globalAlpha = this.editor_alpha;
    for (var t = e.WIDGET_OUTLINE_COLOR, q = e.WIDGET_BGCOLOR, l = e.WIDGET_TEXT_COLOR, g = e.WIDGET_SECONDARY_TEXT_COLOR, J = 0; J < c.length; ++J) {
      var E = c[J], I = b;
      E.y && (I = E.y);
      E.last_y = I;
      d.strokeStyle = t;
      d.fillStyle = "#222";
      d.textAlign = "left";
      E.disabled && (d.globalAlpha *= 0.5);
      var z = E.width || h;
      switch(E.type) {
        case "button":
          E.clicked && (d.fillStyle = "#AAA", E.clicked = !1, this.dirty_canvas = !0);
          d.fillRect(15, I, z - 30, k);
          r && !E.disabled && d.strokeRect(15, I, z - 30, k);
          r && (d.textAlign = "center", d.fillStyle = l, d.fillText(E.name, 0.5 * z, I + 0.7 * k));
          break;
        case "toggle":
          d.textAlign = "left";
          d.strokeStyle = t;
          d.fillStyle = q;
          d.beginPath();
          r ? d.roundRect(15, b, z - 30, k, 0.5 * k) : d.rect(15, b, z - 30, k);
          d.fill();
          r && !E.disabled && d.stroke();
          d.fillStyle = E.value ? "#89A" : "#333";
          d.beginPath();
          d.arc(z - 30, I + 0.5 * k, 0.36 * k, 0, 2 * Math.PI);
          d.fill();
          r && (d.fillStyle = g, null != E.name && d.fillText(E.name, 30, I + 0.7 * k), d.fillStyle = E.value ? l : g, d.textAlign = "right", d.fillText(E.value ? E.options.on || "true" : E.options.off || "false", z - 40, I + 0.7 * k));
          break;
        case "slider":
          d.fillStyle = q;
          d.fillRect(15, I, z - 30, k);
          var m = E.options.max - E.options.min, n = (E.value - E.options.min) / m;
          d.fillStyle = f == E ? "#89A" : "#678";
          d.fillRect(15, I, n * (z - 30), k);
          r && !E.disabled && d.strokeRect(15, I, z - 30, k);
          E.marker && (m = (E.marker - E.options.min) / m, d.fillStyle = "#AA9", d.fillRect(15 + m * (z - 30), I, 2, k));
          r && (d.textAlign = "center", d.fillStyle = l, d.fillText(E.name + "  " + Number(E.value).toFixed(3), 0.5 * z, I + 0.7 * k));
          break;
        case "number":
        case "combo":
          d.textAlign = "left";
          d.strokeStyle = t;
          d.fillStyle = q;
          d.beginPath();
          r ? d.roundRect(15, b, z - 30, k, 0.5 * k) : d.rect(15, b, z - 30, k);
          d.fill();
          r && (E.disabled || d.stroke(), d.fillStyle = l, E.disabled || (d.beginPath(), d.moveTo(31, b + 5), d.lineTo(21, b + 0.5 * k), d.lineTo(31, b + k - 5), d.fill(), d.beginPath(), d.moveTo(z - 15 - 16, b + 5), d.lineTo(z - 15 - 6, b + 0.5 * k), d.lineTo(z - 15 - 16, b + k - 5), d.fill()), d.fillStyle = g, d.fillText(E.name, 35, I + 0.7 * k), d.fillStyle = l, d.textAlign = "right", "number" == E.type ? d.fillText(Number(E.value).toFixed(void 0 !== E.options.precision ? E.options.precision : 
          3), z - 30 - 20, I + 0.7 * k) : (m = E.value, E.options.values && (n = E.options.values, n.constructor === Function && (n = n()), n && n.constructor !== Array && (m = n[E.value])), d.fillText(m, z - 30 - 20, I + 0.7 * k)));
          break;
        case "string":
        case "text":
          d.textAlign = "left";
          d.strokeStyle = t;
          d.fillStyle = q;
          d.beginPath();
          r ? d.roundRect(15, b, z - 30, k, 0.5 * k) : d.rect(15, b, z - 30, k);
          d.fill();
          r && (E.disabled || d.stroke(), d.save(), d.beginPath(), d.rect(15, b, z - 30, k), d.clip(), d.fillStyle = g, null != E.name && d.fillText(E.name, 30, I + 0.7 * k), d.fillStyle = l, d.textAlign = "right", d.fillText(String(E.value).substr(0, 30), z - 30, I + 0.7 * k), d.restore());
          break;
        default:
          E.draw && E.draw(d, a, z, I, k);
      }
      b += (E.computeSize ? E.computeSize(z)[1] : k) + 4;
      d.globalAlpha = this.editor_alpha;
    }
    d.restore();
    d.textAlign = "left";
  };
  l.prototype.processNodeWidgets = function(a, b, d, f) {
    function h(f, h) {
      f.value = h;
      f.options && f.options.property && void 0 !== a.properties[f.options.property] && a.setProperty(f.options.property, h);
      f.callback && f.callback(f.value, t, a, b, d);
    }
    if (!a.widgets || !a.widgets.length) {
      return null;
    }
    for (var c = b[0] - a.pos[0], k = b[1] - a.pos[1], r = a.size[0], t = this, q = this.getCanvasWindow(), l = 0; l < a.widgets.length; ++l) {
      var g = a.widgets[l];
      if (g && !g.disabled) {
        var J = g.computeSize ? g.computeSize(r)[1] : e.NODE_WIDGET_HEIGHT, E = g.width || r;
        if (g == f || !(6 > c || c > E - 12 || k < g.last_y || k > g.last_y + J || void 0 === g.last_y)) {
          f = g.value;
          switch(g.type) {
            case "button":
              "mousedown" === d.type && (g.callback && setTimeout(function() {
                g.callback(g, t, a, b, d);
              }, 20), this.dirty_canvas = g.clicked = !0);
              break;
            case "slider":
              q = Math.clamp((c - 15) / (E - 30), 0, 1);
              g.value = g.options.min + (g.options.max - g.options.min) * q;
              g.callback && setTimeout(function() {
                h(g, g.value);
              }, 20);
              this.dirty_canvas = !0;
              break;
            case "number":
            case "combo":
              f = g.value;
              if ("mousemove" == d.type && "number" == g.type) {
                g.value += 0.1 * d.deltaX * (g.options.step || 1), null != g.options.min && g.value < g.options.min && (g.value = g.options.min), null != g.options.max && g.value > g.options.max && (g.value = g.options.max);
              } else {
                if ("mousedown" == d.type) {
                  var I = g.options.values;
                  I && I.constructor === Function && (I = g.options.values(g, a));
                  var z = null;
                  "number" != g.type && (z = I.constructor === Array ? I : Object.keys(I));
                  c = 40 > c ? -1 : c > E - 40 ? 1 : 0;
                  if ("number" == g.type) {
                    g.value += 0.1 * c * (g.options.step || 1), null != g.options.min && g.value < g.options.min && (g.value = g.options.min), null != g.options.max && g.value > g.options.max && (g.value = g.options.max);
                  } else {
                    if (c) {
                      q = -1, this.last_mouseclick = 0, q = I.constructor === Object ? z.indexOf(String(g.value)) + c : z.indexOf(g.value) + c, q >= z.length && (q = z.length - 1), 0 > q && (q = 0), g.value = I.constructor === Array ? I[q] : q;
                    } else {
                      var m = I != z ? Object.values(I) : I;
                      new e.ContextMenu(m, {scale:Math.max(1, this.ds.scale), event:d, className:"dark", callback:function(a, b, d) {
                        I != z && (a = m.indexOf(a));
                        this.value = a;
                        h(this, a);
                        t.dirty_canvas = !0;
                        return !1;
                      }.bind(g)}, q);
                    }
                  }
                } else {
                  "mouseup" == d.type && "number" == g.type && (c = 40 > c ? -1 : c > E - 40 ? 1 : 0, 200 > d.click_time && 0 == c && this.prompt("Value", g.value, function(a) {
                    this.value = Number(a);
                    h(this, this.value);
                  }.bind(g), d));
                }
              }
              f != g.value && setTimeout(function() {
                h(this, this.value);
              }.bind(g), 20);
              this.dirty_canvas = !0;
              break;
            case "toggle":
              "mousedown" == d.type && (g.value = !g.value, setTimeout(function() {
                h(g, g.value);
              }, 20));
              break;
            case "string":
            case "text":
              "mousedown" == d.type && this.prompt("Value", g.value, function(a) {
                this.value = a;
                h(this, a);
              }.bind(g), d, g.options ? g.options.multiline : !1);
              break;
            default:
              g.mouse && (this.dirty_canvas = g.mouse(d, [c, k], a));
          }
          if (f != g.value) {
            if (a.onWidgetChanged) {
              a.onWidgetChanged(g.name, g.value, f, g);
            }
            a.graph._version++;
          }
          return g;
        }
      }
    }
    return null;
  };
  l.prototype.drawGroups = function(a, b) {
    if (this.graph) {
      a = this.graph._groups;
      b.save();
      b.globalAlpha = 0.5 * this.editor_alpha;
      for (var d = 0; d < a.length; ++d) {
        var f = a[d];
        if (D(this.visible_area, f._bounding)) {
          b.fillStyle = f.color || "#335";
          b.strokeStyle = f.color || "#335";
          var h = f._pos, c = f._size;
          b.globalAlpha = 0.25 * this.editor_alpha;
          b.beginPath();
          b.rect(h[0] + 0.5, h[1] + 0.5, c[0], c[1]);
          b.fill();
          b.globalAlpha = this.editor_alpha;
          b.stroke();
          b.beginPath();
          b.moveTo(h[0] + c[0], h[1] + c[1]);
          b.lineTo(h[0] + c[0] - 10, h[1] + c[1]);
          b.lineTo(h[0] + c[0], h[1] + c[1] - 10);
          b.fill();
          c = f.font_size || e.DEFAULT_GROUP_FONT_SIZE;
          b.font = c + "px Arial";
          b.fillText(f.title, h[0] + 4, h[1] + c);
        }
      }
      b.restore();
    }
  };
  l.prototype.adjustNodesSize = function() {
    for (var a = this.graph._nodes, b = 0; b < a.length; ++b) {
      a[b].size = a[b].computeSize();
    }
    this.setDirty(!0, !0);
  };
  l.prototype.resize = function(a, b) {
    a || b || (b = this.canvas.parentNode, a = b.offsetWidth, b = b.offsetHeight);
    if (this.canvas.width != a || this.canvas.height != b) {
      this.canvas.width = a, this.canvas.height = b, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0);
    }
  };
  l.prototype.switchLiveMode = function(a) {
    if (a) {
      var b = this, d = this.live_mode ? 1.1 : 0.9;
      this.live_mode && (this.live_mode = !1, this.editor_alpha = 0.1);
      var f = setInterval(function() {
        b.editor_alpha *= d;
        b.dirty_canvas = !0;
        b.dirty_bgcanvas = !0;
        1 > d && 0.01 > b.editor_alpha && (clearInterval(f), 1 > d && (b.live_mode = !0));
        1 < d && 0.99 < b.editor_alpha && (clearInterval(f), b.editor_alpha = 1);
      }, 1);
    } else {
      this.live_mode = !this.live_mode, this.dirty_bgcanvas = this.dirty_canvas = !0;
    }
  };
  l.prototype.onNodeSelectionChange = function(a) {
  };
  l.prototype.touchHandler = function(a) {
    var b = a.changedTouches[0];
    switch(a.type) {
      case "touchstart":
        var d = "mousedown";
        break;
      case "touchmove":
        d = "mousemove";
        break;
      case "touchend":
        d = "mouseup";
        break;
      default:
        return;
    }
    var f = this.getCanvasWindow(), h = f.document.createEvent("MouseEvent");
    h.initMouseEvent(d, !0, !0, f, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null);
    b.target.dispatchEvent(h);
    a.preventDefault();
  };
  l.onGroupAdd = function(a, b, d) {
    a = l.active_canvas;
    a.getCanvasWindow();
    b = new e.LGraphGroup;
    b.pos = a.convertEventToCanvasOffset(d);
    a.graph.add(b);
  };
  l.onMenuAdd = function(a, b, d, f, h) {
    function c(a, b) {
      var f = [];
      e.getNodeTypesCategories(k.filter || t.filter).filter(function(b) {
        return b.startsWith(a);
      }).map(function(b) {
        if (b) {
          b = b.replace(new RegExp("^(" + a + ")"), "").split("/")[0];
          var d = "" === a ? b + "/" : a + b + "/";
          -1 != b.indexOf("::") && (b = b.split("::")[1]);
          -1 === f.findIndex(function(a) {
            return a.value === d;
          }) && f.push({value:d, content:b, has_submenu:!0, callback:function(a, b, d, f) {
            c(a.value, f);
          }});
        }
      });
      e.getNodeTypesInCategory(a.slice(0, -1), k.filter || t.filter).map(function(a) {
        a.skip_list || f.push({value:a.type, content:a.title, has_submenu:!1, callback:function(a, b, d, f) {
          b = f.getFirstEvent();
          k.graph.beforeChange();
          if (a = e.createNode(a.value)) {
            a.pos = k.convertEventToCanvasOffset(b), k.graph.add(a);
          }
          h && h(a);
          k.graph.afterChange();
        }});
      });
      new e.ContextMenu(f, {event:d, parentMenu:b}, r);
    }
    var k = l.active_canvas, r = k.getCanvasWindow(), t = k.graph;
    if (t) {
      return c("", f), !1;
    }
  };
  l.onMenuCollapseAll = function() {
  };
  l.onMenuNodeEdit = function() {
  };
  l.showMenuNodeOptionalInputs = function(a, b, d, f, h) {
    if (h) {
      var c = this;
      a = l.active_canvas.getCanvasWindow();
      b = h.optional_inputs;
      h.onGetInputs && (b = h.onGetInputs());
      var k = [];
      if (b) {
        for (var r = 0; r < b.length; r++) {
          var t = b[r];
          if (t) {
            var q = t[0];
            t[2] && t[2].label && (q = t[2].label);
            q = {content:q, value:t};
            t[1] == e.ACTION && (q.className = "event");
            k.push(q);
          } else {
            k.push(null);
          }
        }
      }
      this.onMenuNodeInputs && (k = this.onMenuNodeInputs(k));
      if (k.length) {
        return new e.ContextMenu(k, {event:d, callback:function(a, b, d) {
          h && (a.callback && a.callback.call(c, h, a, b, d), a.value && (h.graph.beforeChange(), h.addInput(a.value[0], a.value[1], a.value[2]), h.setDirtyCanvas(!0, !0), h.graph.afterChange()));
        }, parentMenu:f, node:h}, a), !1;
      }
      console.log("no input entries");
    }
  };
  l.showMenuNodeOptionalOutputs = function(a, b, d, f, h) {
    function c(a, b, d) {
      if (h && (a.callback && a.callback.call(k, h, a, b, d), a.value)) {
        if (d = a.value[1], !d || d.constructor !== Object && d.constructor !== Array) {
          h.graph.beforeChange(), h.addOutput(a.value[0], a.value[1], a.value[2]), h.setDirtyCanvas(!0, !0), h.graph.afterChange();
        } else {
          a = [];
          for (var r in d) {
            a.push({content:r, value:d[r]});
          }
          new e.ContextMenu(a, {event:b, callback:c, parentMenu:f, node:h});
          return !1;
        }
      }
    }
    if (h) {
      var k = this;
      a = l.active_canvas.getCanvasWindow();
      b = h.optional_outputs;
      h.onGetOutputs && (b = h.onGetOutputs());
      var r = [];
      if (b) {
        for (var t = 0; t < b.length; t++) {
          var q = b[t];
          if (!q) {
            r.push(null);
          } else {
            if (!h.flags || !h.flags.skip_repeated_outputs || -1 == h.findOutputSlot(q[0])) {
              var g = q[0];
              q[2] && q[2].label && (g = q[2].label);
              g = {content:g, value:q};
              q[1] == e.EVENT && (g.className = "event");
              r.push(g);
            }
          }
        }
      }
      this.onMenuNodeOutputs && (r = this.onMenuNodeOutputs(r));
      if (r.length) {
        return new e.ContextMenu(r, {event:d, callback:c, parentMenu:f, node:h}, a), !1;
      }
    }
  };
  l.onShowMenuNodeProperties = function(a, b, d, f, h) {
    if (h && h.properties) {
      var c = l.active_canvas;
      b = c.getCanvasWindow();
      var k = [], r;
      for (r in h.properties) {
        a = void 0 !== h.properties[r] ? h.properties[r] : " ";
        "object" == typeof a && (a = JSON.stringify(a));
        var t = h.getPropertyInfo(r);
        if ("enum" == t.type || "combo" == t.type) {
          a = l.getPropertyPrintableValue(a, t.values);
        }
        a = l.decodeHTML(a);
        k.push({content:"<span class='property_name'>" + (t.label ? t.label : r) + "</span><span class='property_value'>" + a + "</span>", value:r});
      }
      if (k.length) {
        return new e.ContextMenu(k, {event:d, callback:function(a, b, d, f) {
          h && (b = this.getBoundingClientRect(), c.showEditPropertyValue(h, a.value, {position:[b.left, b.top]}));
        }, parentMenu:f, allow_html:!0, node:h}, b), !1;
      }
    }
  };
  l.decodeHTML = function(a) {
    var b = document.createElement("div");
    b.innerText = a;
    return b.innerHTML;
  };
  l.onResizeNode = function(a, b, d, f, h) {
    if (h) {
      h.size = h.computeSize();
      if (h.onResize) {
        h.onResize(h.size);
      }
      h.setDirtyCanvas(!0, !0);
    }
  };
  l.prototype.showLinkMenu = function(a, b) {
    var d = this;
    console.log(a);
    var f = new e.ContextMenu(["Add Node", null, "Delete"], {event:b, title:null != a.data ? a.data.constructor.name : null, callback:function(b, c, e) {
      switch(b) {
        case "Add Node":
          l.onMenuAdd(null, null, e, f, function(b) {
            console.log("node autoconnect");
            var f = d.graph.getNodeById(a.origin_id), h = d.graph.getNodeById(a.target_id);
            b.inputs && b.inputs.length && b.outputs && b.outputs.length && f.outputs[a.origin_slot].type == b.inputs[0].type && b.outputs[0].type == h.inputs[0].type && (f.connect(a.origin_slot, b, 0), b.connect(0, h, a.target_slot), b.pos[0] -= 0.5 * b.size[0]);
          });
          break;
        case "Delete":
          d.graph.removeLink(a.id);
      }
    }});
    return !1;
  };
  l.onShowPropertyEditor = function(a, b, d, f, h) {
    function c() {
      var b = k.value;
      "Number" == a.type ? b = Number(b) : "Boolean" == a.type && (b = !!b);
      h[e] = b;
      r.parentNode && r.parentNode.removeChild(r);
      h.setDirtyCanvas(!0, !0);
    }
    var e = a.property || "title";
    b = h[e];
    var r = document.createElement("div");
    r.className = "graphdialog";
    r.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
    r.querySelector(".name").innerText = e;
    var k = r.querySelector(".value");
    k && (k.value = b, k.addEventListener("blur", function(a) {
      this.focus();
    }), k.addEventListener("keydown", function(a) {
      if (13 == a.keyCode || "textarea" == a.target.localName) {
        c(), a.preventDefault(), a.stopPropagation();
      }
    }));
    b = l.active_canvas.canvas;
    d = b.getBoundingClientRect();
    var t = f = -20;
    d && (f -= d.left, t -= d.top);
    event ? (r.style.left = event.clientX + f + "px", r.style.top = event.clientY + t + "px") : (r.style.left = 0.5 * b.width + f + "px", r.style.top = 0.5 * b.height + t + "px");
    r.querySelector("button").addEventListener("click", c);
    b.parentNode.appendChild(r);
  };
  l.prototype.prompt = function(a, b, d, f, h) {
    var c = this;
    a = a || "";
    var e = !1, k = document.createElement("div");
    k.className = "graphdialog rounded";
    k.innerHTML = h ? "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>" : "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
    k.close = function() {
      c.prompt_box = null;
      k.parentNode && k.parentNode.removeChild(k);
    };
    1 < this.ds.scale && (k.style.transform = "scale(" + this.ds.scale + ")");
    k.addEventListener("mouseleave", function(a) {
      e || k.close();
    });
    c.prompt_box && c.prompt_box.close();
    c.prompt_box = k;
    k.querySelector(".name").innerText = a;
    var t = k.querySelector(".value");
    t.value = b;
    t.addEventListener("keydown", function(a) {
      e = !0;
      if (27 == a.keyCode) {
        k.close();
      } else {
        if (13 == a.keyCode && "textarea" != a.target.localName) {
          d && d(this.value), k.close();
        } else {
          return;
        }
      }
      a.preventDefault();
      a.stopPropagation();
    });
    k.querySelector("button").addEventListener("click", function(a) {
      d && d(t.value);
      c.setDirty(!0);
      k.close();
    });
    a = l.active_canvas.canvas;
    b = a.getBoundingClientRect();
    var q = h = -20;
    b && (h -= b.left, q -= b.top);
    f ? (k.style.left = f.clientX + h + "px", k.style.top = f.clientY + q + "px") : (k.style.left = 0.5 * a.width + h + "px", k.style.top = 0.5 * a.height + q + "px");
    a.parentNode.appendChild(k);
    setTimeout(function() {
      t.focus();
    }, 10);
    return k;
  };
  l.search_limit = -1;
  l.prototype.showSearchBox = function(a) {
    function b(b) {
      if (b) {
        if (h.onSearchBoxSelection) {
          h.onSearchBoxSelection(b, a, c);
        } else {
          var d = e.searchbox_extras[b.toLowerCase()];
          d && (b = d.type);
          c.graph.beforeChange();
          if (b = e.createNode(b)) {
            b.pos = c.convertEventToCanvasOffset(a), c.graph.add(b);
          }
          if (d && d.data) {
            if (d.data.properties) {
              for (var f in d.data.properties) {
                b.addProperty(f, d.data.properties[f]);
              }
            }
            if (d.data.inputs) {
              for (f in b.inputs = [], d.data.inputs) {
                b.addOutput(d.data.inputs[f][0], d.data.inputs[f][1]);
              }
            }
            if (d.data.outputs) {
              for (f in b.outputs = [], d.data.outputs) {
                b.addOutput(d.data.outputs[f][0], d.data.outputs[f][1]);
              }
            }
            d.data.title && (b.title = d.data.title);
            d.data.json && b.configure(d.data.json);
            c.graph.afterChange();
          }
        }
      }
      t.close();
    }
    function d(a) {
      var b = E;
      E && E.classList.remove("selected");
      E ? (E = a ? E.nextSibling : E.previousSibling) || (E = b) : E = a ? g.childNodes[0] : g.childNodes[g.childNodes.length];
      E && (E.classList.add("selected"), E.scrollIntoView({block:"end", behavior:"smooth"}));
    }
    function f() {
      function a(a, d) {
        var f = document.createElement("div");
        z || (z = a);
        f.innerText = a;
        f.dataset.type = escape(a);
        f.className = "litegraph lite-search-item";
        d && (f.className += " " + d);
        f.addEventListener("click", function(a) {
          b(unescape(this.dataset.type));
        });
        g.appendChild(f);
      }
      J = null;
      var d = I.value;
      z = null;
      g.innerHTML = "";
      if (d) {
        if (h.onSearchBox) {
          var f = h.onSearchBox(g, d, c);
          if (f) {
            for (var k = 0; k < f.length; ++k) {
              a(f[k]);
            }
          }
        } else {
          f = function(a) {
            var b = e.registered_node_types[a];
            return t && b.filter != t ? !1 : -1 !== a.toLowerCase().indexOf(d);
          };
          var r = 0;
          d = d.toLowerCase();
          var t = c.filter || c.graph.filter;
          for (k in e.searchbox_extras) {
            var q = e.searchbox_extras[k];
            if (-1 !== q.desc.toLowerCase().indexOf(d)) {
              var W = e.registered_node_types[q.type];
              if (!W || W.filter == t) {
                if (a(q.desc, "searchbox_extra"), -1 !== l.search_limit && r++ > l.search_limit) {
                  break;
                }
              }
            }
          }
          q = null;
          if (Array.prototype.filter) {
            q = Object.keys(e.registered_node_types).filter(f);
          } else {
            for (k in q = [], e.registered_node_types) {
              f(k) && q.push(k);
            }
          }
          for (k = 0; k < q.length && !(a(q[k]), -1 !== l.search_limit && r++ > l.search_limit); k++) {
          }
        }
      }
    }
    var h = this, c = l.active_canvas, k = c.canvas, r = k.ownerDocument || document, t = document.createElement("div");
    t.className = "litegraph litesearchbox graphdialog rounded";
    t.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>";
    t.close = function() {
      h.search_box = null;
      r.body.focus();
      r.body.style.overflow = "";
      setTimeout(function() {
        h.canvas.focus();
      }, 20);
      t.parentNode && t.parentNode.removeChild(t);
    };
    var q = null;
    1 < this.ds.scale && (t.style.transform = "scale(" + this.ds.scale + ")");
    t.addEventListener("mouseenter", function(a) {
      q && (clearTimeout(q), q = null);
    });
    t.addEventListener("mouseleave", function(a) {
      q = setTimeout(function() {
        t.close();
      }, 500);
    });
    h.search_box && h.search_box.close();
    h.search_box = t;
    var g = t.querySelector(".helper"), z = null, J = null, E = null, I = t.querySelector("input");
    I && (I.addEventListener("blur", function(a) {
      this.focus();
    }), I.addEventListener("keydown", function(a) {
      if (38 == a.keyCode) {
        d(!1);
      } else {
        if (40 == a.keyCode) {
          d(!0);
        } else {
          if (27 == a.keyCode) {
            t.close();
          } else {
            if (13 == a.keyCode) {
              E ? b(E.innerHTML) : z ? b(z) : t.close();
            } else {
              J && clearInterval(J);
              J = setTimeout(f, 10);
              return;
            }
          }
        }
      }
      a.preventDefault();
      a.stopPropagation();
      a.stopImmediatePropagation();
      return !0;
    }));
    r.fullscreenElement ? r.fullscreenElement.appendChild(t) : (r.body.appendChild(t), r.body.style.overflow = "hidden");
    k = k.getBoundingClientRect();
    var m = (a ? a.clientY : k.top + 0.5 * k.height) - 20;
    t.style.left = (a ? a.clientX : k.left + 0.5 * k.width) - 80 + "px";
    t.style.top = m + "px";
    a.layerY > k.height - 200 && (g.style.maxHeight = k.height - a.layerY - 20 + "px");
    I.focus();
    return t;
  };
  l.prototype.showEditPropertyValue = function(a, b, d) {
    function f() {
      h(l.value);
    }
    function h(f) {
      c && c.values && c.values.constructor === Object && void 0 != c.values[f] && (f = c.values[f]);
      "number" == typeof a.properties[b] && (f = Number(f));
      if ("array" == e || "object" == e) {
        f = JSON.parse(f);
      }
      a.properties[b] = f;
      a.graph && a.graph._version++;
      if (a.onPropertyChanged) {
        a.onPropertyChanged(b, f);
      }
      if (d.onclose) {
        d.onclose();
      }
      g.close();
      a.setDirtyCanvas(!0, !0);
    }
    if (a && void 0 !== a.properties[b]) {
      d = d || {};
      var c = a.getPropertyInfo(b), e = c.type, k = "";
      if ("string" == e || "number" == e || "array" == e || "object" == e) {
        k = "<input autofocus type='text' class='value'/>";
      } else {
        if ("enum" != e && "combo" != e || !c.values) {
          if ("boolean" == e) {
            k = "<input autofocus type='checkbox' class='value' " + (a.properties[b] ? "checked" : "") + "/>";
          } else {
            console.warn("unknown type: " + e);
            return;
          }
        } else {
          k = "<select autofocus type='text' class='value'>";
          for (var t in c.values) {
            var q = t;
            c.values.constructor === Array && (q = c.values[t]);
            k += "<option value='" + q + "' " + (q == a.properties[b] ? "selected" : "") + ">" + c.values[t] + "</option>";
          }
          k += "</select>";
        }
      }
      var g = this.createDialog("<span class='name'>" + (c.label ? c.label : b) + "</span>" + k + "<button>OK</button>", d);
      if ("enum" != e && "combo" != e || !c.values) {
        if ("boolean" == e) {
          (l = g.querySelector("input")) && l.addEventListener("click", function(a) {
            h(!!l.checked);
          });
        } else {
          if (l = g.querySelector("input")) {
            l.addEventListener("blur", function(a) {
              this.focus();
            }), q = void 0 !== a.properties[b] ? a.properties[b] : "", "string" !== e && (q = JSON.stringify(q)), l.value = q, l.addEventListener("keydown", function(a) {
              13 == a.keyCode && (f(), a.preventDefault(), a.stopPropagation());
            });
          }
        }
      } else {
        var l = g.querySelector("select");
        l.addEventListener("change", function(a) {
          h(a.target.value);
        });
      }
      g.querySelector("button").addEventListener("click", f);
      return g;
    }
  };
  l.prototype.createDialog = function(a, b) {
    b = b || {};
    var d = document.createElement("div");
    d.className = "graphdialog";
    d.innerHTML = a;
    a = this.canvas.getBoundingClientRect();
    var f = -20, h = -20;
    a && (f -= a.left, h -= a.top);
    b.position ? (f += b.position[0], h += b.position[1]) : b.event ? (f += b.event.clientX, h += b.event.clientY) : (f += 0.5 * this.canvas.width, h += 0.5 * this.canvas.height);
    d.style.left = f + "px";
    d.style.top = h + "px";
    this.canvas.parentNode.appendChild(d);
    d.close = function() {
      this.parentNode && this.parentNode.removeChild(this);
    };
    return d;
  };
  l.prototype.createPanel = function(a, b) {
    b = b || {};
    var d = b.window || window, f = document.createElement("div");
    f.className = "litegraph dialog";
    f.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>";
    f.header = f.querySelector(".dialog-header");
    b.width && (f.style.width = b.width + (b.width.constructor === Number ? "px" : ""));
    b.height && (f.style.height = b.height + (b.height.constructor === Number ? "px" : ""));
    b.closable && (b = document.createElement("span"), b.innerHTML = "&#10005;", b.classList.add("close"), b.addEventListener("click", function() {
      f.close();
    }), f.header.appendChild(b));
    f.title_element = f.querySelector(".dialog-title");
    f.title_element.innerText = a;
    f.content = f.querySelector(".dialog-content");
    f.footer = f.querySelector(".dialog-footer");
    f.close = function() {
      this.parentNode && this.parentNode.removeChild(this);
    };
    f.clear = function() {
      this.content.innerHTML = "";
    };
    f.addHTML = function(a, b, d) {
      var h = document.createElement("div");
      b && (h.className = b);
      h.innerHTML = a;
      d ? f.footer.appendChild(h) : f.content.appendChild(h);
      return h;
    };
    f.addButton = function(a, b, d) {
      var h = document.createElement("button");
      h.innerText = a;
      h.options = d;
      h.classList.add("btn");
      h.addEventListener("click", b);
      f.footer.appendChild(h);
      return h;
    };
    f.addSeparator = function() {
      var a = document.createElement("div");
      a.className = "separator";
      f.content.appendChild(a);
    };
    f.addWidget = function(a, b, c, k, t) {
      function h(a, b) {
        console.log("change", a, b);
        k.callback && k.callback(a, b);
        t && t(a, b);
      }
      k = k || {};
      var r = String(c);
      a = a.toLowerCase();
      "number" == a && (r = c.toFixed(3));
      var q = document.createElement("div");
      q.className = "property";
      q.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
      q.querySelector(".property_name").innerText = k.label || b;
      var g = q.querySelector(".property_value");
      g.innerText = r;
      q.dataset.property = b;
      q.dataset.type = k.type || a;
      q.options = k;
      q.value = c;
      if ("boolean" == a) {
        q.classList.add("boolean"), c && q.classList.add("bool-on"), q.addEventListener("click", function() {
          var a = this.dataset.property;
          this.value = !this.value;
          this.classList.toggle("bool-on");
          this.querySelector(".property_value").innerText = this.value ? "true" : "false";
          h(a, this.value);
        });
      } else {
        if ("string" == a || "number" == a) {
          g.setAttribute("contenteditable", !0), g.addEventListener("keydown", function(a) {
            "Enter" == a.code && (a.preventDefault(), this.blur());
          }), g.addEventListener("blur", function() {
            var a = this.innerText, b = this.parentNode.dataset.property;
            "number" == this.parentNode.dataset.type && (a = Number(a));
            h(b, a);
          });
        } else {
          if ("enum" == a || "combo" == a) {
            r = l.getPropertyPrintableValue(c, k.values), g.innerText = r, g.addEventListener("click", function(a) {
              var b = this.parentNode.dataset.property, f = this;
              new e.ContextMenu(k.values || [], {event:a, className:"dark", callback:function(a, d, c) {
                f.innerText = a;
                h(b, a);
                return !1;
              }}, d);
            });
          }
        }
      }
      f.content.appendChild(q);
      return q;
    };
    return f;
  };
  l.getPropertyPrintableValue = function(a, b) {
    if (!b || b.constructor === Array) {
      return String(a);
    }
    if (b.constructor === Object) {
      var d = "", f;
      for (f in b) {
        if (b[f] == a) {
          d = f;
          break;
        }
      }
      return String(a) + " (" + d + ")";
    }
  };
  l.prototype.showShowNodePanel = function(a) {
    window.SELECTED_NODE = a;
    var b = document.querySelector("#node-panel");
    b && b.close();
    var d = this.getCanvasWindow();
    b = this.createPanel(a.title || "", {closable:!0, window:d});
    b.id = "node-panel";
    b.node = a;
    b.classList.add("settings");
    var f = this;
    (function() {
      b.content.innerHTML = "";
      b.addHTML("<span class='node_type'>" + a.type + "</span><span class='node_desc'>" + (a.constructor.desc || "") + "</span><span class='separator'></span>");
      b.addHTML("<h3>Properties</h3>");
      for (var d in a.properties) {
        var c = a.properties[d], e = a.getPropertyInfo(d);
        a.onAddPropertyToPanel && a.onAddPropertyToPanel(d, b) || b.addWidget(e.widget || e.type, d, c, e, function(b, d) {
          f.graph.beforeChange(a);
          a.setProperty(b, d);
          f.graph.afterChange();
          f.dirty_canvas = !0;
        });
      }
      b.addSeparator();
      if (a.onShowCustomPanelInfo) {
        a.onShowCustomPanelInfo(b);
      }
      b.addButton("Delete", function() {
        a.block_delete || (a.graph.remove(a), b.close());
      }).classList.add("delete");
    })();
    this.canvas.parentNode.appendChild(b);
  };
  l.prototype.showSubgraphPropertiesDialog = function(a) {
    function b() {
      f.clear();
      if (a.inputs) {
        for (var d = 0; d < a.inputs.length; ++d) {
          var c = a.inputs[d];
          if (!c.not_subgraph_input) {
            var e = f.addHTML("<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", "subgraph_property");
            e.dataset.name = c.name;
            e.dataset.slot = d;
            e.querySelector(".name").innerText = c.name;
            e.querySelector(".type").innerText = c.type;
            e.querySelector("button").addEventListener("click", function(d) {
              a.removeInput(Number(this.parentNode.dataset.slot));
              b();
            });
          }
        }
      }
    }
    console.log("showing subgraph properties dialog");
    var d = this.canvas.parentNode.querySelector(".subgraph_dialog");
    d && d.close();
    var f = this.createPanel("Subgraph Inputs", {closable:!0, width:500});
    f.node = a;
    f.classList.add("subgraph_dialog");
    f.addHTML(" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>", "subgraph_property extra", !0).querySelector("button").addEventListener("click", function(d) {
      d = this.parentNode;
      var f = d.querySelector(".name").value, h = d.querySelector(".type").value;
      f && -1 == a.findInputSlot(f) && (a.addInput(f, h), d.querySelector(".name").value = "", d.querySelector(".type").value = "", b());
    });
    b();
    this.canvas.parentNode.appendChild(f);
    return f;
  };
  l.prototype.checkPanels = function() {
    if (this.canvas) {
      for (var a = this.canvas.parentNode.querySelectorAll(".litegraph.dialog"), b = 0; b < a.length; ++b) {
        var d = a[b];
        d.node && (d.node.graph && d.graph == this.graph || d.close());
      }
    }
  };
  l.onMenuNodeCollapse = function(a, b, d, f, h) {
    h.graph.beforeChange(h);
    h.collapse();
    h.graph.afterChange(h);
  };
  l.onMenuNodePin = function(a, b, d, f, h) {
    h.pin();
  };
  l.onMenuNodeMode = function(a, b, d, f, h) {
    new e.ContextMenu(["Always", "On Event", "On Trigger", "Never"], {event:d, callback:function(a) {
      if (h) {
        switch(a) {
          case "On Event":
            h.mode = e.ON_EVENT;
            break;
          case "On Trigger":
            h.mode = e.ON_TRIGGER;
            break;
          case "Never":
            h.mode = e.NEVER;
            break;
          default:
            h.mode = e.ALWAYS;
        }
      }
    }, parentMenu:f, node:h});
    return !1;
  };
  l.onMenuNodeColors = function(a, b, d, f, h) {
    if (!h) {
      throw "no node for color";
    }
    b = [];
    b.push({value:null, content:"<span style='display: block; padding-left: 4px;'>No color</span>"});
    for (var c in l.node_colors) {
      a = l.node_colors[c], a = {value:c, content:"<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + a.color + "; background-color:" + a.bgcolor + "'>" + c + "</span>"}, b.push(a);
    }
    new e.ContextMenu(b, {event:d, callback:function(a) {
      h && ((a = a.value ? l.node_colors[a.value] : null) ? h.constructor === e.LGraphGroup ? h.color = a.groupcolor : (h.color = a.color, h.bgcolor = a.bgcolor) : (delete h.color, delete h.bgcolor), h.setDirtyCanvas(!0, !0));
    }, parentMenu:f, node:h});
    return !1;
  };
  l.onMenuNodeShapes = function(a, b, d, f, h) {
    if (!h) {
      throw "no node passed";
    }
    new e.ContextMenu(e.VALID_SHAPES, {event:d, callback:function(a) {
      h && (h.graph.beforeChange(h), h.shape = a, h.graph.afterChange(h), h.setDirtyCanvas(!0));
    }, parentMenu:f, node:h});
    return !1;
  };
  l.onMenuNodeRemove = function(a, b, d, f, h) {
    if (!h) {
      throw "no node passed";
    }
    !1 !== h.removable && (a = h.graph, a.beforeChange(), a.remove(h), a.afterChange(), h.setDirtyCanvas(!0, !0));
  };
  l.onMenuNodeToSubgraph = function(a, b, d, f, h) {
    a = h.graph;
    if (b = l.active_canvas) {
      d = Object.values(b.selected_nodes || {}), d.length || (d = [h]), f = e.createNode("graph/subgraph"), f.pos = h.pos.concat(), a.add(f), f.buildFromNodes(d), b.deselectAllNodes(), h.setDirtyCanvas(!0, !0);
    }
  };
  l.onMenuNodeClone = function(a, b, d, f, h) {
    0 != h.clonable && (a = h.clone()) && (a.pos = [h.pos[0] + 5, h.pos[1] + 5], h.graph.beforeChange(), h.graph.add(a), h.graph.afterChange(), h.setDirtyCanvas(!0, !0));
  };
  l.node_colors = {red:{color:"#322", bgcolor:"#533", groupcolor:"#A88"}, brown:{color:"#332922", bgcolor:"#593930", groupcolor:"#b06634"}, green:{color:"#232", bgcolor:"#353", groupcolor:"#8A8"}, blue:{color:"#223", bgcolor:"#335", groupcolor:"#88A"}, pale_blue:{color:"#2a363b", bgcolor:"#3f5159", groupcolor:"#3f789e"}, cyan:{color:"#233", bgcolor:"#355", groupcolor:"#8AA"}, purple:{color:"#323", bgcolor:"#535", groupcolor:"#a1309b"}, yellow:{color:"#432", bgcolor:"#653", groupcolor:"#b58b2a"}, 
  black:{color:"#222", bgcolor:"#000", groupcolor:"#444"}};
  l.prototype.getCanvasMenuOptions = function() {
    if (this.getMenuOptions) {
      var a = this.getMenuOptions();
    } else {
      a = [{content:"Add Node", has_submenu:!0, callback:l.onMenuAdd}, {content:"Add Group", callback:l.onGroupAdd}], this._graph_stack && 0 < this._graph_stack.length && a.push(null, {content:"Close subgraph", callback:this.closeSubgraph.bind(this)});
    }
    if (this.getExtraMenuOptions) {
      var b = this.getExtraMenuOptions(this, a);
      b && (a = a.concat(b));
    }
    return a;
  };
  l.prototype.getNodeMenuOptions = function(a) {
    var b = null;
    b = a.getMenuOptions ? a.getMenuOptions(this) : [{content:"Inputs", has_submenu:!0, disabled:!0, callback:l.showMenuNodeOptionalInputs}, {content:"Outputs", has_submenu:!0, disabled:!0, callback:l.showMenuNodeOptionalOutputs}, null, {content:"Properties", has_submenu:!0, callback:l.onShowMenuNodeProperties}, null, {content:"Title", callback:l.onShowPropertyEditor}, {content:"Mode", has_submenu:!0, callback:l.onMenuNodeMode}, {content:"Resize", callback:function() {
      if (a.resizable) {
        return l.onResizeNode;
      }
    }}, {content:"Collapse", callback:l.onMenuNodeCollapse}, {content:"Pin", callback:l.onMenuNodePin}, {content:"Colors", has_submenu:!0, callback:l.onMenuNodeColors}, {content:"Shapes", has_submenu:!0, callback:l.onMenuNodeShapes}, null];
    if (a.onGetInputs) {
      var d = a.onGetInputs();
      d && d.length && (b[0].disabled = !1);
    }
    a.onGetOutputs && (d = a.onGetOutputs()) && d.length && (b[1].disabled = !1);
    a.getExtraMenuOptions && (d = a.getExtraMenuOptions(this, b)) && (d.push(null), b = d.concat(b));
    !1 !== a.clonable && b.push({content:"Clone", callback:l.onMenuNodeClone});
    b.push(null, {content:"Remove", disabled:!(!1 !== a.removable && !a.block_delete), callback:l.onMenuNodeRemove});
    if (a.graph && a.graph.onGetNodeMenuOptions) {
      a.graph.onGetNodeMenuOptions(b, a);
    }
    return b;
  };
  l.prototype.getGroupMenuOptions = function(a) {
    return [{content:"Title", callback:l.onShowPropertyEditor}, {content:"Color", has_submenu:!0, callback:l.onMenuNodeColors}, {content:"Font size", property:"font_size", type:"Number", callback:l.onShowPropertyEditor}, null, {content:"Remove", callback:l.onMenuNodeRemove}];
  };
  l.prototype.processContextMenu = function(a, b) {
    var d = this, f = l.active_canvas.getCanvasWindow(), h = null, c = {event:b, callback:function(b, f, h) {
      if (b) {
        if ("Remove Slot" == b.content) {
          b = b.slot, b.input ? a.removeInput(b.slot) : b.output && a.removeOutput(b.slot);
        } else {
          if ("Disconnect Links" == b.content) {
            b = b.slot, b.output ? a.disconnectOutput(b.slot) : b.input && a.disconnectInput(b.slot);
          } else {
            if ("Rename Slot" == b.content) {
              b = b.slot;
              var c = b.input ? a.getInputInfo(b.slot) : a.getOutputInfo(b.slot), e = d.createDialog("<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>", f), k = e.querySelector("input");
              k && c && (k.value = c.label || "");
              e.querySelector("button").addEventListener("click", function(a) {
                k.value && (c && (c.label = k.value), d.setDirty(!0));
                e.close();
              });
            }
          }
        }
      }
    }, extra:a};
    a && (c.title = a.type);
    var k = null;
    a && (k = a.getSlotInPosition(b.canvasX, b.canvasY), l.active_node = a);
    k ? (h = [], a.getSlotMenuOptions ? h = a.getSlotMenuOptions(k) : (k && k.output && k.output.links && k.output.links.length && h.push({content:"Disconnect Links", slot:k}), b = k.input || k.output, h.push(b.locked ? "Cannot remove" : {content:"Remove Slot", slot:k}), h.push(b.nameLocked ? "Cannot rename" : {content:"Rename Slot", slot:k})), c.title = (k.input ? k.input.type : k.output.type) || "*", k.input && k.input.type == e.ACTION && (c.title = "Action"), k.output && k.output.type == e.EVENT && 
    (c.title = "Event")) : a ? h = this.getNodeMenuOptions(a) : (h = this.getCanvasMenuOptions(), (k = this.graph.getGroupOnPos(b.canvasX, b.canvasY)) && h.push(null, {content:"Edit Group", has_submenu:!0, submenu:{title:"Group", extra:k, options:this.getGroupMenuOptions(k)}}));
    h && new e.ContextMenu(h, c, f);
  };
  "undefined" != typeof window && window.CanvasRenderingContext2D && (window.CanvasRenderingContext2D.prototype.roundRect = function(a, b, d, f, h, c) {
    void 0 === h && (h = 5);
    void 0 === c && (c = h);
    this.moveTo(a + h, b);
    this.lineTo(a + d - h, b);
    this.quadraticCurveTo(a + d, b, a + d, b + h);
    this.lineTo(a + d, b + f - c);
    this.quadraticCurveTo(a + d, b + f, a + d - c, b + f);
    this.lineTo(a + c, b + f);
    this.quadraticCurveTo(a, b + f, a, b + f - c);
    this.lineTo(a, b + h);
    this.quadraticCurveTo(a, b, a + h, b);
  });
  e.compareObjects = function(a, b) {
    for (var d in a) {
      if (a[d] != b[d]) {
        return !1;
      }
    }
    return !0;
  };
  e.distance = G;
  e.colorToString = function(a) {
    return "rgba(" + Math.round(255 * a[0]).toFixed() + "," + Math.round(255 * a[1]).toFixed() + "," + Math.round(255 * a[2]).toFixed() + "," + (4 == a.length ? a[3].toFixed(2) : "1.0") + ")";
  };
  e.isInsideRectangle = A;
  e.growBounding = function(a, b, d) {
    b < a[0] ? a[0] = b : b > a[2] && (a[2] = b);
    d < a[1] ? a[1] = d : d > a[3] && (a[3] = d);
  };
  e.isInsideBounding = function(a, b) {
    return a[0] < b[0][0] || a[1] < b[0][1] || a[0] > b[1][0] || a[1] > b[1][1] ? !1 : !0;
  };
  e.overlapBounding = D;
  e.hex2num = function(a) {
    "#" == a.charAt(0) && (a = a.slice(1));
    a = a.toUpperCase();
    for (var b = Array(3), d = 0, f, h, c = 0; 6 > c; c += 2) {
      f = "0123456789ABCDEF".indexOf(a.charAt(c)), h = "0123456789ABCDEF".indexOf(a.charAt(c + 1)), b[d] = 16 * f + h, d++;
    }
    return b;
  };
  e.num2hex = function(a) {
    for (var b = "#", d, f, h = 0; 3 > h; h++) {
      d = a[h] / 16, f = a[h] % 16, b += "0123456789ABCDEF".charAt(d) + "0123456789ABCDEF".charAt(f);
    }
    return b;
  };
  B.prototype.addItem = function(a, b, d) {
    function f(a) {
      var b = this.value;
      b && b.has_submenu && h.call(this, a);
    }
    function h(a) {
      var b = this.value, f = !0;
      c.current_submenu && c.current_submenu.close(a);
      if (d.callback) {
        var h = d.callback.call(this, b, d, a, c, d.node);
        !0 === h && (f = !1);
      }
      if (b && (b.callback && !d.ignore_item_callbacks && !0 !== b.disabled && (h = b.callback.call(this, b, d, a, c, d.extra), !0 === h && (f = !1)), b.submenu)) {
        if (!b.submenu.options) {
          throw "ContextMenu submenu needs options";
        }
        new c.constructor(b.submenu.options, {callback:b.submenu.callback, event:a, parentMenu:c, ignore_item_callbacks:b.submenu.ignore_item_callbacks, title:b.submenu.title, extra:b.submenu.extra, autoopen:d.autoopen});
        f = !1;
      }
      f && !c.lock && c.close();
    }
    var c = this;
    d = d || {};
    var e = document.createElement("div");
    e.className = "litemenu-entry submenu";
    var k = !1;
    if (null === b) {
      e.classList.add("separator");
    } else {
      e.innerHTML = b && b.title ? b.title : a;
      if (e.value = b) {
        b.disabled && (k = !0, e.classList.add("disabled")), (b.submenu || b.has_submenu) && e.classList.add("has_submenu");
      }
      "function" == typeof b ? (e.dataset.value = a, e.onclick_callback = b) : e.dataset.value = b;
      b.className && (e.className += " " + b.className);
    }
    this.root.appendChild(e);
    k || e.addEventListener("click", h);
    d.autoopen && e.addEventListener("mouseenter", f);
    return e;
  };
  B.prototype.close = function(a, b) {
    this.root.parentNode && this.root.parentNode.removeChild(this.root);
    this.parentMenu && !b && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, void 0 === a ? this.parentMenu.close() : a && !B.isCursorOverElement(a, this.parentMenu.root) && B.trigger(this.parentMenu.root, "mouseleave", a));
    this.current_submenu && this.current_submenu.close(a, !0);
    this.root.closing_timer && clearTimeout(this.root.closing_timer);
  };
  B.trigger = function(a, b, d, f) {
    var h = document.createEvent("CustomEvent");
    h.initCustomEvent(b, !0, !0, d);
    h.srcElement = f;
    a.dispatchEvent ? a.dispatchEvent(h) : a.__events && a.__events.dispatchEvent(h);
    return h;
  };
  B.prototype.getTopMenu = function() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this;
  };
  B.prototype.getFirstEvent = function() {
    return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event;
  };
  B.isCursorOverElement = function(a, b) {
    var d = a.clientX;
    a = a.clientY;
    return (b = b.getBoundingClientRect()) ? a > b.top && a < b.top + b.height && d > b.left && d < b.left + b.width ? !0 : !1 : !1;
  };
  e.ContextMenu = B;
  e.closeAllContextMenus = function(a) {
    a = a || window;
    a = a.document.querySelectorAll(".litecontextmenu");
    if (a.length) {
      for (var b = [], d = 0; d < a.length; d++) {
        b.push(a[d]);
      }
      for (d = 0; d < b.length; d++) {
        b[d].close ? b[d].close() : b[d].parentNode && b[d].parentNode.removeChild(b[d]);
      }
    }
  };
  e.extendClass = function(a, b) {
    for (var d in b) {
      a.hasOwnProperty(d) || (a[d] = b[d]);
    }
    if (b.prototype) {
      for (d in b.prototype) {
        b.prototype.hasOwnProperty(d) && !a.prototype.hasOwnProperty(d) && (b.prototype.__lookupGetter__(d) ? a.prototype.__defineGetter__(d, b.prototype.__lookupGetter__(d)) : a.prototype[d] = b.prototype[d], b.prototype.__lookupSetter__(d) && a.prototype.__defineSetter__(d, b.prototype.__lookupSetter__(d)));
      }
    }
  };
  F.sampleCurve = function(a, b) {
    if (b) {
      for (var d = 0; d < b.length - 1; ++d) {
        var f = b[d], h = b[d + 1];
        if (!(h[0] < a)) {
          b = h[0] - f[0];
          if (0.00001 > Math.abs(b)) {
            return f[1];
          }
          a = (a - f[0]) / b;
          return f[1] * (1.0 - a) + h[1] * a;
        }
      }
      return 0;
    }
  };
  F.prototype.draw = function(a, b, d, f, h, c) {
    if (d = this.points) {
      this.size = b;
      var e = b[0] - 2 * this.margin;
      b = b[1] - 2 * this.margin;
      h = h || "#666";
      a.save();
      a.translate(this.margin, this.margin);
      f && (a.fillStyle = "#111", a.fillRect(0, 0, e, b), a.fillStyle = "#222", a.fillRect(0.5 * e, 0, 1, b), a.strokeStyle = "#333", a.strokeRect(0, 0, e, b));
      a.strokeStyle = h;
      c && (a.globalAlpha = 0.5);
      a.beginPath();
      for (f = 0; f < d.length; ++f) {
        h = d[f], a.lineTo(h[0] * e, (1.0 - h[1]) * b);
      }
      a.stroke();
      a.globalAlpha = 1;
      if (!c) {
        for (f = 0; f < d.length; ++f) {
          h = d[f], a.fillStyle = this.selected == f ? "#FFF" : this.nearest == f ? "#DDD" : "#AAA", a.beginPath(), a.arc(h[0] * e, (1.0 - h[1]) * b, 2, 0, 2 * Math.PI), a.fill();
        }
      }
      a.restore();
    }
  };
  F.prototype.onMouseDown = function(a, b) {
    var d = this.points;
    if (d && !(0 > a[1])) {
      var f = this.size[0] - 2 * this.margin, c = this.size[1] - 2 * this.margin, e = a[0] - this.margin;
      a = a[1] - this.margin;
      this.selected = this.getCloserPoint([e, a], 30 / b.ds.scale);
      -1 == this.selected && (b = [e / f, 1 - a / c], d.push(b), d.sort(function(a, b) {
        return a[0] - b[0];
      }), this.selected = d.indexOf(b), this.must_update = !0);
      if (-1 != this.selected) {
        return !0;
      }
    }
  };
  F.prototype.onMouseMove = function(a, b) {
    var d = this.points;
    if (d) {
      var f = this.selected;
      if (!(0 > f)) {
        var c = (a[0] - this.margin) / (this.size[0] - 2 * this.margin), e = (a[1] - this.margin) / (this.size[1] - 2 * this.margin);
        this._nearest = this.getCloserPoint([a[0] - this.margin, a[1] - this.margin], 30 / b.ds.scale);
        if (b = d[f]) {
          var k = 0 == f || f == d.length - 1;
          !k && (-10 > a[0] || a[0] > this.size[0] + 10 || -10 > a[1] || a[1] > this.size[1] + 10) ? (d.splice(f, 1), this.selected = -1) : (b[0] = k ? 0 == f ? 0 : 1 : Math.clamp(c, 0, 1), b[1] = 1.0 - Math.clamp(e, 0, 1), d.sort(function(a, b) {
            return a[0] - b[0];
          }), this.selected = d.indexOf(b), this.must_update = !0);
        }
      }
    }
  };
  F.prototype.onMouseUp = function(a, b) {
    this.selected = -1;
    return !1;
  };
  F.prototype.getCloserPoint = function(a, b) {
    var d = this.points;
    if (!d) {
      return -1;
    }
    b = b || 30;
    for (var f = this.size[0] - 2 * this.margin, c = this.size[1] - 2 * this.margin, e = d.length, k = [0, 0], r = 1000000, t = -1, q = 0; q < e; ++q) {
      var g = d[q];
      k[0] = g[0] * f;
      k[1] = (1.0 - g[1]) * c;
      g = vec2.distance(a, k);
      g > r || g > b || (t = q, r = g);
    }
    return t;
  };
  e.CurveEditor = F;
  e.getParameterNames = function(a) {
    return (a + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  };
  Math.clamp = function(a, b, d) {
    return b > a ? b : d < a ? d : a;
  };
  "undefined" == typeof window || window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
    window.setTimeout(a, 1000 / 60);
  });
})(this);
"undefined" != typeof exports && (exports.LiteGraph = this.LiteGraph);
(function(y) {
  function c() {
    this.addOutput("in ms", "number");
    this.addOutput("in sec", "number");
  }
  function g() {
    this.size = [140, 80];
    this.properties = {enabled:!0};
    this.enabled = !0;
    this.subgraph = new v.LGraph;
    this.subgraph._subgraph_node = this;
    this.subgraph._is_subgraph = !0;
    this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);
    this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);
    this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);
    this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);
    this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);
    this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);
    this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);
    this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);
    this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
  }
  function n() {
    this.addOutput("", "number");
    this.name_in_graph = "";
    this.properties = {name:"", type:"number", value:0};
    var a = this;
    this.name_widget = this.addWidget("text", "Name", this.properties.name, function(b) {
      b && a.setProperty("name", b);
    });
    this.type_widget = this.addWidget("text", "Type", this.properties.type, function(b) {
      a.setProperty("type", b);
    });
    this.value_widget = this.addWidget("number", "Value", this.properties.value, function(b) {
      a.setProperty("value", b);
    });
    this.widgets_up = !0;
    this.size = [180, 90];
  }
  function m() {
    this.addInput("", "");
    this.name_in_graph = "";
    this.properties = {};
    var a = this;
    Object.defineProperty(this.properties, "name", {get:function() {
      return a.name_in_graph;
    }, set:function(b) {
      "" != b && b != a.name_in_graph && (a.name_in_graph ? a.graph.renameOutput(a.name_in_graph, b) : a.graph.addOutput(b, a.properties.type), a.name_widget.value = b, a.name_in_graph = b);
    }, enumerable:!0});
    Object.defineProperty(this.properties, "type", {get:function() {
      return a.inputs[0].type;
    }, set:function(b) {
      if ("action" == b || "event" == b) {
        b = v.ACTION;
      }
      v.isValidConnection(a.inputs[0].type, b) || a.disconnectInput(0);
      a.inputs[0].type = b;
      a.name_in_graph && a.graph.changeOutputType(a.name_in_graph, a.inputs[0].type);
      a.type_widget.value = b || "";
    }, enumerable:!0});
    this.name_widget = this.addWidget("text", "Name", this.properties.name, "name");
    this.type_widget = this.addWidget("text", "Type", this.properties.type, "type");
    this.widgets_up = !0;
    this.size = [180, 60];
  }
  function u() {
    this.addOutput("value", "number");
    this.addProperty("value", 1.0);
    this.widget = this.addWidget("number", "value", 1, "value");
    this.widgets_up = !0;
    this.size = [180, 30];
  }
  function l() {
    this.addOutput("", "boolean");
    this.addProperty("value", !0);
    this.widget = this.addWidget("toggle", "value", !0, "value");
    this.widgets_up = !0;
    this.size = [140, 30];
  }
  function G() {
    this.addOutput("", "string");
    this.addProperty("value", "");
    this.widget = this.addWidget("text", "value", "", "value");
    this.widgets_up = !0;
    this.size = [180, 30];
  }
  function A() {
    this.addOutput("obj", "object");
    this.size = [120, 30];
    this._object = {};
  }
  function D() {
    this.addInput("url", "");
    this.addOutput("", "");
    this.addProperty("url", "");
    this.addProperty("type", "text");
    this.widget = this.addWidget("text", "url", "", "url");
    this._data = null;
  }
  function B() {
    this.addOutput("", "");
    this.addProperty("value", "");
    this.widget = this.addWidget("text", "json", "", "value");
    this.widgets_up = !0;
    this.size = [140, 30];
    this._value = null;
  }
  function F() {
    this._value = [];
    this.addInput("", "");
    this.addOutput("", "array");
    this.addOutput("length", "number");
    this.addProperty("value", "[]");
    this.widget = this.addWidget("text", "array", this.properties.value, "value");
    this.widgets_up = !0;
    this.size = [140, 50];
  }
  function e() {
    this.addInput("arr", "array");
    this.addInput("value", "");
    this.addOutput("arr", "array");
    this.properties = {index:0};
    this.widget = this.addWidget("number", "i", this.properties.index, "index");
  }
  function z() {
    this.addInput("array", "array,table,string");
    this.addInput("index", "number");
    this.addOutput("value", "");
    this.addProperty("index", 0);
  }
  function H() {
    this.addInput("table", "table");
    this.addInput("row", "number");
    this.addInput("col", "number");
    this.addOutput("value", "");
    this.addProperty("row", 0);
    this.addProperty("column", 0);
  }
  function x() {
    this.addInput("obj", "");
    this.addOutput("", "");
    this.addProperty("value", "");
    this.widget = this.addWidget("text", "prop.", "", this.setValue.bind(this));
    this.widgets_up = !0;
    this.size = [140, 30];
    this._value = null;
  }
  function K() {
    this.addInput("obj", "");
    this.addOutput("keys", "array");
    this.size = [140, 30];
  }
  function k() {
    this.addInput("obj", "");
    this.addInput("value", "");
    this.addOutput("obj", "");
    this.properties = {property:""};
    this.name_widget = this.addWidget("text", "prop.", this.properties.property, "property");
  }
  function q() {
    this.addInput("A", "");
    this.addInput("B", "");
    this.addOutput("", "");
    this._result = {};
    var a = this;
    this.addWidget("button", "clear", "", function() {
      a._result = {};
    });
    this.size = this.computeSize();
  }
  function t() {
    this.size = [60, 30];
    this.addInput("in");
    this.addOutput("out");
    this.properties = {varname:"myname", container:t.LITEGRAPH};
    this.value = null;
  }
  function a() {
    this.size = [60, 30];
    this.addInput("data", 0);
    this.addInput("download", v.ACTION);
    this.properties = {filename:"data.json"};
    this.value = null;
    var a = this;
    this.addWidget("button", "Download", "", function(b) {
      a.value && a.downloadAsFile();
    });
  }
  function b() {
    this.size = [60, 30];
    this.addInput("value", 0, {label:""});
    this.value = 0;
  }
  function d() {
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.size = [40, 30];
  }
  function f() {
    this.mode = v.ON_EVENT;
    this.size = [80, 30];
    this.addProperty("msg", "");
    this.addInput("log", v.EVENT);
    this.addInput("msg", 0);
  }
  function h() {
    this.mode = v.ON_EVENT;
    this.addProperty("msg", "");
    this.addInput("", v.EVENT);
    this.widget = this.addWidget("text", "Text", "", "msg");
    this.widgets_up = !0;
    this.size = [200, 30];
  }
  function w() {
    this.size = [60, 30];
    this.addProperty("onExecute", "return A;");
    this.addInput("A", "");
    this.addInput("B", "");
    this.addOutput("out", "");
    this._func = null;
    this.data = {};
  }
  var v = y.LiteGraph;
  c.title = "Time";
  c.desc = "Time";
  c.prototype.onExecute = function() {
    this.setOutputData(0, 1000 * this.graph.globaltime);
    this.setOutputData(1, this.graph.globaltime);
  };
  v.registerNodeType("basic/time", c);
  g.title = "Subgraph";
  g.desc = "Graph inside a node";
  g.title_color = "#334";
  g.prototype.onGetInputs = function() {
    return [["enabled", "boolean"]];
  };
  g.prototype.onDblClick = function(a, b, d) {
    var f = this;
    setTimeout(function() {
      d.openSubgraph(f.subgraph);
    }, 10);
  };
  g.prototype.onAction = function(a, b) {
    this.subgraph.onAction(a, b);
  };
  g.prototype.onExecute = function() {
    if (this.enabled = this.getInputOrProperty("enabled")) {
      if (this.inputs) {
        for (var a = 0; a < this.inputs.length; a++) {
          var b = this.inputs[a], d = this.getInputData(a);
          this.subgraph.setInputData(b.name, d);
        }
      }
      this.subgraph.runStep();
      if (this.outputs) {
        for (a = 0; a < this.outputs.length; a++) {
          d = this.subgraph.getOutputData(this.outputs[a].name), this.setOutputData(a, d);
        }
      }
    }
  };
  g.prototype.sendEventToAllNodes = function(a, b, d) {
    this.enabled && this.subgraph.sendEventToAllNodes(a, b, d);
  };
  g.prototype.onDrawBackground = function(a, b, d, f) {
    this.flags.collapsed || (b = this.size[1] - v.NODE_TITLE_HEIGHT + 0.5, f = v.isInsideRectangle(f[0], f[1], this.pos[0], this.pos[1] + b, this.size[0], v.NODE_TITLE_HEIGHT), a.fillStyle = f ? "#555" : "#222", a.beginPath(), this._shape == v.BOX_SHAPE ? a.rect(0, b, this.size[0] + 1, v.NODE_TITLE_HEIGHT) : a.roundRect(0, b, this.size[0] + 1, v.NODE_TITLE_HEIGHT, 0, 8), a.fill(), a.textAlign = "center", a.font = "24px Arial", a.fillStyle = f ? "#DDD" : "#999", a.fillText("+", 0.5 * this.size[0], 
    b + 24));
  };
  g.prototype.onMouseDown = function(a, b, d) {
    b[1] > this.size[1] - v.NODE_TITLE_HEIGHT + 0.5 && d.showSubgraphPropertiesDialog(this);
  };
  g.prototype.computeSize = function() {
    return [200, Math.max(this.inputs ? this.inputs.length : 0, this.outputs ? this.outputs.length : 0) * v.NODE_SLOT_HEIGHT + v.NODE_TITLE_HEIGHT];
  };
  g.prototype.onSubgraphTrigger = function(a, b) {
    a = this.findOutputSlot(a);
    -1 != a && this.triggerSlot(a);
  };
  g.prototype.onSubgraphNewInput = function(a, b) {
    -1 == this.findInputSlot(a) && this.addInput(a, b);
  };
  g.prototype.onSubgraphRenamedInput = function(a, b) {
    a = this.findInputSlot(a);
    -1 != a && (this.getInputInfo(a).name = b);
  };
  g.prototype.onSubgraphTypeChangeInput = function(a, b) {
    a = this.findInputSlot(a);
    -1 != a && (this.getInputInfo(a).type = b);
  };
  g.prototype.onSubgraphRemovedInput = function(a) {
    a = this.findInputSlot(a);
    -1 != a && this.removeInput(a);
  };
  g.prototype.onSubgraphNewOutput = function(a, b) {
    -1 == this.findOutputSlot(a) && this.addOutput(a, b);
  };
  g.prototype.onSubgraphRenamedOutput = function(a, b) {
    a = this.findOutputSlot(a);
    -1 != a && (this.getOutputInfo(a).name = b);
  };
  g.prototype.onSubgraphTypeChangeOutput = function(a, b) {
    a = this.findOutputSlot(a);
    -1 != a && (this.getOutputInfo(a).type = b);
  };
  g.prototype.onSubgraphRemovedOutput = function(a) {
    a = this.findInputSlot(a);
    -1 != a && this.removeOutput(a);
  };
  g.prototype.getExtraMenuOptions = function(a) {
    var b = this;
    return [{content:"Open", callback:function() {
      a.openSubgraph(b.subgraph);
    }}];
  };
  g.prototype.onResize = function(a) {
    a[1] += 20;
  };
  g.prototype.serialize = function() {
    var a = v.LGraphNode.prototype.serialize.call(this);
    a.subgraph = this.subgraph.serialize();
    return a;
  };
  g.prototype.clone = function() {
    var a = v.createNode(this.type), b = this.serialize();
    delete b.id;
    delete b.inputs;
    delete b.outputs;
    a.configure(b);
    return a;
  };
  g.prototype.buildFromNodes = function(a) {
    for (var b = {}, d = 0; d < a.length; ++d) {
      var f = a[d];
      b[f.id] = f;
    }
    for (d = 0; d < a.length; ++d) {
      f = a[d];
      if (f.inputs) {
        for (var c = 0; c < f.inputs.length; ++c) {
          var h = f.inputs[c];
          if (h && h.links) {
            for (var e = 0; e < h.links.length; e++) {
              var k = f.graph.links[h.links[e]];
              k && (b[k.origin_id] || this.subgraph.addInput(h.name, k.type));
            }
          }
        }
      }
      if (f.outputs) {
        for (c = 0; c < f.outputs.length; ++c) {
          if ((h = f.outputs[c]) && h.links && h.links.length) {
            for (e = 0; e < h.links.length && (!(k = f.graph.links[h.links[e]]) || b[k.target_id]); ++e) {
            }
          }
        }
      }
    }
  };
  v.Subgraph = g;
  v.registerNodeType("graph/subgraph", g);
  n.title = "Input";
  n.desc = "Input of the graph";
  n.prototype.onConfigure = function() {
    this.updateType();
  };
  n.prototype.updateType = function() {
    var a = this.properties.type;
    this.type_widget.value = a;
    this.outputs[0].type != a && (v.isValidConnection(this.outputs[0].type, a) || this.disconnectOutput(0), this.outputs[0].type = a);
    "number" == a ? (this.value_widget.type = "number", this.value_widget.value = 0) : "boolean" == a ? (this.value_widget.type = "toggle", this.value_widget.value = !0) : "string" == a ? (this.value_widget.type = "text", this.value_widget.value = "") : (this.value_widget.type = null, this.value_widget.value = null);
    this.properties.value = this.value_widget.value;
    this.graph && this.name_in_graph && this.graph.changeInputType(this.name_in_graph, a);
  };
  n.prototype.onPropertyChanged = function(a, b) {
    if ("name" == a) {
      if ("" == b || b == this.name_in_graph || "enabled" == b) {
        return !1;
      }
      this.graph && (this.name_in_graph ? this.graph.renameInput(this.name_in_graph, b) : this.graph.addInput(b, this.properties.type));
      this.name_in_graph = this.name_widget.value = b;
    } else {
      "type" == a && this.updateType();
    }
  };
  n.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.name : this.title;
  };
  n.prototype.onAction = function(a, b) {
    this.properties.type == v.EVENT && this.triggerSlot(0, b);
  };
  n.prototype.onExecute = function() {
    var a = this.graph.inputs[this.properties.name];
    a ? this.setOutputData(0, void 0 !== a.value ? a.value : this.properties.value) : this.setOutputData(0, this.properties.value);
  };
  n.prototype.onRemoved = function() {
    this.name_in_graph && this.graph.removeInput(this.name_in_graph);
  };
  v.GraphInput = n;
  v.registerNodeType("graph/input", n);
  m.title = "Output";
  m.desc = "Output of the graph";
  m.prototype.onExecute = function() {
    this._value = this.getInputData(0);
    this.graph.setOutputData(this.properties.name, this._value);
  };
  m.prototype.onAction = function(a, b) {
    this.properties.type == v.ACTION && this.graph.trigger(this.properties.name, b);
  };
  m.prototype.onRemoved = function() {
    this.name_in_graph && this.graph.removeOutput(this.name_in_graph);
  };
  m.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.name : this.title;
  };
  v.GraphOutput = m;
  v.registerNodeType("graph/output", m);
  u.title = "Const Number";
  u.desc = "Constant number";
  u.prototype.onExecute = function() {
    this.setOutputData(0, parseFloat(this.properties.value));
  };
  u.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.value : this.title;
  };
  u.prototype.setValue = function(a) {
    this.setProperty("value", a);
  };
  u.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this.properties.value.toFixed(3);
  };
  v.registerNodeType("basic/const", u);
  l.title = "Const Boolean";
  l.desc = "Constant boolean";
  l.prototype.getTitle = u.prototype.getTitle;
  l.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  l.prototype.setValue = u.prototype.setValue;
  l.prototype.onGetInputs = function() {
    return [["toggle", v.ACTION]];
  };
  l.prototype.onAction = function(a) {
    this.setValue(!this.properties.value);
  };
  v.registerNodeType("basic/boolean", l);
  G.title = "Const String";
  G.desc = "Constant string";
  G.prototype.getTitle = u.prototype.getTitle;
  G.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  G.prototype.setValue = u.prototype.setValue;
  G.prototype.onDropFile = function(a) {
    var b = this, d = new FileReader;
    d.onload = function(a) {
      b.setProperty("value", a.target.result);
    };
    d.readAsText(a);
  };
  v.registerNodeType("basic/string", G);
  A.title = "Const Object";
  A.desc = "Constant Object";
  A.prototype.onExecute = function() {
    this.setOutputData(0, this._object);
  };
  v.registerNodeType("basic/object", A);
  D.title = "Const File";
  D.desc = "Fetches a file from an url";
  D["@type"] = {type:"enum", values:["text", "arraybuffer", "blob", "json"]};
  D.prototype.onPropertyChanged = function(a, b) {
    "url" == a && (null == b || "" == b ? this._data = null : this.fetchFile(b));
  };
  D.prototype.onExecute = function() {
    var a = this.getInputData(0) || this.properties.url;
    !a || a == this._url && this._type == this.properties.type || this.fetchFile(a);
    this.setOutputData(0, this._data);
  };
  D.prototype.setValue = u.prototype.setValue;
  D.prototype.fetchFile = function(a) {
    var b = this;
    a && a.constructor === String ? (this._url = a, this._type = this.properties.type, "http" == a.substr(0, 4) && v.proxy && (a = v.proxy + a.substr(a.indexOf(":") + 3)), fetch(a).then(function(a) {
      if (!a.ok) {
        throw Error("File not found");
      }
      if ("arraybuffer" == b.properties.type) {
        return a.arrayBuffer();
      }
      if ("text" == b.properties.type) {
        return a.text();
      }
      if ("json" == b.properties.type) {
        return a.json();
      }
      if ("blob" == b.properties.type) {
        return a.blob();
      }
    }).then(function(a) {
      b._data = a;
      b.boxcolor = "#AEA";
    }).catch(function(d) {
      b._data = null;
      b.boxcolor = "red";
      console.error("error fetching file:", a);
    })) : (b._data = null, b.boxcolor = null);
  };
  D.prototype.onDropFile = function(a) {
    var b = this;
    this._url = a.name;
    this._type = this.properties.type;
    this.properties.url = a.name;
    var d = new FileReader;
    d.onload = function(a) {
      b.boxcolor = "#AEA";
      a = a.target.result;
      "json" == b.properties.type && (a = JSON.parse(a));
      b._data = a;
    };
    if ("arraybuffer" == b.properties.type) {
      d.readAsArrayBuffer(a);
    } else {
      if ("text" == b.properties.type || "json" == b.properties.type) {
        d.readAsText(a);
      } else {
        if ("blob" == b.properties.type) {
          return d.readAsBinaryString(a);
        }
      }
    }
  };
  v.registerNodeType("basic/file", D);
  B.title = "Const Data";
  B.desc = "Constant Data";
  B.prototype.onPropertyChanged = function(a, b) {
    this.widget.value = b;
    if (null != b && "" != b) {
      try {
        this._value = JSON.parse(b), this.boxcolor = "#AEA";
      } catch (O) {
        this.boxcolor = "red";
      }
    }
  };
  B.prototype.onExecute = function() {
    this.setOutputData(0, this._value);
  };
  B.prototype.setValue = u.prototype.setValue;
  v.registerNodeType("basic/data", B);
  F.title = "Const Array";
  F.desc = "Constant Array";
  F.prototype.onPropertyChanged = function(a, b) {
    this.widget.value = b;
    if (null != b && "" != b) {
      try {
        this._value = "[" != b[0] ? JSON.parse("[" + b + "]") : JSON.parse(b), this.boxcolor = "#AEA";
      } catch (O) {
        this.boxcolor = "red";
      }
    }
  };
  F.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && a.length) {
      this._value || (this._value = []);
      this._value.length = a.length;
      for (var b = 0; b < a.length; ++b) {
        this._value[b] = a[b];
      }
    }
    this.setOutputData(0, this._value);
    this.setOutputData(1, this._value ? this._value.length || 0 : 0);
  };
  F.prototype.setValue = u.prototype.setValue;
  v.registerNodeType("basic/array", F);
  e.title = "Set Array";
  e.desc = "Sets index of array";
  e.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      var b = this.getInputData(1);
      void 0 !== b && (this.properties.index && (a[Math.floor(this.properties.index)] = b), this.setOutputData(0, a));
    }
  };
  v.registerNodeType("basic/set_array", e);
  z.title = "Array[i]";
  z.desc = "Returns an element from an array";
  z.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    null == b && (b = this.properties.index);
    null != a && null != b && this.setOutputData(0, a[Math.floor(Number(b))]);
  };
  v.registerNodeType("basic/array[]", z);
  H.title = "Table[row][col]";
  H.desc = "Returns an element from a table";
  H.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1), d = this.getInputData(2);
    null == b && (b = this.properties.row);
    null == d && (d = this.properties.column);
    null != a && null != b && null != d && ((b = a[Math.floor(Number(b))]) ? this.setOutputData(0, b[Math.floor(Number(d))]) : this.setOutputData(0, null));
  };
  v.registerNodeType("basic/table[][]", H);
  x.title = "Object property";
  x.desc = "Outputs the property of an object";
  x.prototype.setValue = function(a) {
    this.properties.value = a;
    this.widget.value = a;
  };
  x.prototype.getTitle = function() {
    return this.flags.collapsed ? "in." + this.properties.value : this.title;
  };
  x.prototype.onPropertyChanged = function(a, b) {
    this.widget.value = b;
  };
  x.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a[this.properties.value]);
  };
  v.registerNodeType("basic/object_property", x);
  K.title = "Object keys";
  K.desc = "Outputs an array with the keys of an object";
  K.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Object.keys(a));
  };
  v.registerNodeType("basic/object_keys", K);
  k.title = "Set Object";
  k.desc = "Adds propertiesrty to object";
  k.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      var b = this.getInputData(1);
      void 0 !== b && (this.properties.property && (a[this.properties.property] = b), this.setOutputData(0, a));
    }
  };
  v.registerNodeType("basic/set_object", k);
  q.title = "Merge Objects";
  q.desc = "Creates an object copying properties from others";
  q.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1), d = this._result;
    if (a) {
      for (var f in a) {
        d[f] = a[f];
      }
    }
    if (b) {
      for (f in b) {
        d[f] = b[f];
      }
    }
    this.setOutputData(0, d);
  };
  v.registerNodeType("basic/merge_objects", q);
  t.title = "Variable";
  t.desc = "store/read variable value";
  t.LITEGRAPH = 0;
  t.GRAPH = 1;
  t.GLOBALSCOPE = 2;
  t["@container"] = {type:"enum", values:{litegraph:t.LITEGRAPH, graph:t.GRAPH, global:t.GLOBALSCOPE}};
  t.prototype.onExecute = function() {
    var a = this.getContainer();
    this.isInputConnected(0) ? (this.value = this.getInputData(0), a[this.properties.varname] = this.value, this.setOutputData(0, this.value)) : this.setOutputData(0, a[this.properties.varname]);
  };
  t.prototype.getContainer = function() {
    switch(this.properties.container) {
      case t.GRAPH:
        return this.graph ? this.graph.vars : {};
      case t.GLOBALSCOPE:
        return y;
      default:
        return v.Globals;
    }
  };
  t.prototype.getTitle = function() {
    return this.properties.varname;
  };
  v.registerNodeType("basic/variable", t);
  v.wrapFunctionAsNode("basic/length", function(a) {
    return a && null != a.length ? Number(a.length) : 0;
  }, [""], "number");
  a.title = "Download";
  a.desc = "Download some data";
  a.prototype.downloadAsFile = function() {
    if (null != this.value) {
      var a = null;
      a = this.value.constructor === String ? this.value : JSON.stringify(this.value);
      a = new Blob([a]);
      var b = URL.createObjectURL(a);
      a = document.createElement("a");
      a.setAttribute("href", b);
      a.setAttribute("download", this.properties.filename);
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(function() {
        URL.revokeObjectURL(b);
      }, 6E4);
    }
  };
  a.prototype.onAction = function(a, b) {
    var d = this;
    setTimeout(function() {
      d.downloadAsFile();
    }, 100);
  };
  a.prototype.onExecute = function() {
    this.inputs[0] && (this.value = this.getInputData(0));
  };
  a.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.filename : this.title;
  };
  v.registerNodeType("basic/download", a);
  b.title = "Watch";
  b.desc = "Show value of input";
  b.prototype.onExecute = function() {
    this.inputs[0] && (this.value = this.getInputData(0));
  };
  b.prototype.getTitle = function() {
    return this.flags.collapsed ? this.inputs[0].label : this.title;
  };
  b.toString = function(a) {
    if (null == a) {
      return "null";
    }
    if (a.constructor === Number) {
      return a.toFixed(3);
    }
    if (a.constructor === Array) {
      for (var d = "[", f = 0; f < a.length; ++f) {
        d += b.toString(a[f]) + (f + 1 != a.length ? "," : "");
      }
      return d + "]";
    }
    return String(a);
  };
  b.prototype.onDrawBackground = function(a) {
    this.inputs[0].label = b.toString(this.value);
  };
  v.registerNodeType("basic/watch", b);
  d.title = "Cast";
  d.desc = "Allows to connect different types";
  d.prototype.onExecute = function() {
    this.setOutputData(0, this.getInputData(0));
  };
  v.registerNodeType("basic/cast", d);
  f.title = "Console";
  f.desc = "Show value inside the console";
  f.prototype.onAction = function(a, b) {
    "log" == a ? console.log(b) : "warn" == a ? console.warn(b) : "error" == a && console.error(b);
  };
  f.prototype.onExecute = function() {
    var a = this.getInputData(1);
    null !== a && (this.properties.msg = a);
    console.log(a);
  };
  f.prototype.onGetInputs = function() {
    return [["log", v.ACTION], ["warn", v.ACTION], ["error", v.ACTION]];
  };
  v.registerNodeType("basic/console", f);
  h.title = "Alert";
  h.desc = "Show an alert window";
  h.color = "#510";
  h.prototype.onConfigure = function(a) {
    this.widget.value = a.properties.msg;
  };
  h.prototype.onAction = function(a, b) {
    var d = this.properties.msg;
    setTimeout(function() {
      alert(d);
    }, 10);
  };
  v.registerNodeType("basic/alert", h);
  w.prototype.onConfigure = function(a) {
    a.properties.onExecute && v.allow_scripts ? this.compileCode(a.properties.onExecute) : console.warn("Script not compiled, LiteGraph.allow_scripts is false");
  };
  w.title = "Script";
  w.desc = "executes a code (max 100 characters)";
  w.widgets_info = {onExecute:{type:"code"}};
  w.prototype.onPropertyChanged = function(a, b) {
    "onExecute" == a && v.allow_scripts ? this.compileCode(b) : console.warn("Script not compiled, LiteGraph.allow_scripts is false");
  };
  w.prototype.compileCode = function(a) {
    this._func = null;
    if (256 < a.length) {
      console.warn("Script too long, max 256 chars");
    } else {
      for (var b = a.toLowerCase(), d = "script body document eval nodescript function".split(" "), f = 0; f < d.length; ++f) {
        if (-1 != b.indexOf(d[f])) {
          console.warn("invalid script");
          return;
        }
      }
      try {
        this._func = new Function("A", "B", "C", "DATA", "node", a);
      } catch (C) {
        console.error("Error parsing script"), console.error(C);
      }
    }
  };
  w.prototype.onExecute = function() {
    if (this._func) {
      try {
        var a = this.getInputData(0), b = this.getInputData(1), d = this.getInputData(2);
        this.setOutputData(0, this._func(a, b, d, this.data, this));
      } catch (M) {
        console.error("Error in script"), console.error(M);
      }
    }
  };
  w.prototype.onGetOutputs = function() {
    return [["C", ""]];
  };
  v.registerNodeType("basic/script", w);
})(this);
(function(y) {
  function c() {
    this.size = [60, 30];
    this.addInput("event", B.ACTION);
  }
  function g() {
    this.size = [60, 30];
    this.addInput("if", "");
    this.addOutput("true", B.EVENT);
    this.addOutput("change", B.EVENT);
    this.addOutput("false", B.EVENT);
    this.properties = {only_on_change:!0};
    this.prev = 0;
  }
  function n() {
    this.addInput("", B.ACTION);
    this.addInput("", B.ACTION);
    this.addInput("", B.ACTION);
    this.addInput("", B.ACTION);
    this.addInput("", B.ACTION);
    this.addInput("", B.ACTION);
    this.addOutput("", B.EVENT);
    this.addOutput("", B.EVENT);
    this.addOutput("", B.EVENT);
    this.addOutput("", B.EVENT);
    this.addOutput("", B.EVENT);
    this.addOutput("", B.EVENT);
    this.size = [120, 30];
    this.flags = {horizontal:!0, render_box:!1};
  }
  function m() {
    this.size = [60, 30];
    this.addInput("event", B.ACTION);
    this.addOutput("event", B.EVENT);
    this.properties = {equal_to:"", has_property:"", property_equal_to:""};
  }
  function u() {
    this.addInput("in", B.ACTION);
    this.addInput("cond", "boolean");
    this.addOutput("true", B.EVENT);
    this.addOutput("false", B.EVENT);
    this.size = [120, 60];
    this._value = !1;
  }
  function l() {
    this.addInput("inc", B.ACTION);
    this.addInput("dec", B.ACTION);
    this.addInput("reset", B.ACTION);
    this.addOutput("change", B.EVENT);
    this.addOutput("num", "number");
    this.num = 0;
  }
  function G() {
    this.size = [60, 30];
    this.addProperty("time_in_ms", 1000);
    this.addInput("event", B.ACTION);
    this.addOutput("on_time", B.EVENT);
    this._pending = [];
  }
  function A() {
    this.addProperty("interval", 1000);
    this.addProperty("event", "tick");
    this.addOutput("on_tick", B.EVENT);
    this.time = 0;
    this.last_interval = 1000;
    this.triggered = !1;
  }
  function D() {
    this.addInput("data", "");
    this.addInput("assign", B.ACTION);
    this.addOutput("data", "");
    this._last_value = null;
    this.properties = {data:null, serialize:!0};
    var c = this;
    this.addWidget("button", "store", "", function() {
      c.properties.data = c._last_value;
    });
  }
  var B = y.LiteGraph;
  c.title = "Log Event";
  c.desc = "Log event in console";
  c.prototype.onAction = function(c, e) {
    console.log(c, e);
  };
  B.registerNodeType("events/log", c);
  g.title = "TriggerEvent";
  g.desc = "Triggers event if input evaluates to true";
  g.prototype.onExecute = function(c, e) {
    c = this.getInputData(0);
    var g = c != this.prev;
    0 === this.prev && (g = !1);
    var l = g && this.properties.only_on_change || !g && !this.properties.only_on_change;
    c && l && this.triggerSlot(0, e);
    !c && l && this.triggerSlot(2, e);
    g && this.triggerSlot(1, e);
    this.prev = c;
  };
  B.registerNodeType("events/trigger", g);
  n.title = "Sequencer";
  n.desc = "Trigger events when an event arrives";
  n.prototype.getTitle = function() {
    return "";
  };
  n.prototype.onAction = function(c, e) {
    if (this.outputs) {
      for (c = 0; c < this.outputs.length; ++c) {
        this.triggerSlot(c, e);
      }
    }
  };
  B.registerNodeType("events/sequencer", n);
  m.title = "Filter Event";
  m.desc = "Blocks events that do not match the filter";
  m.prototype.onAction = function(c, e) {
    if (null != e && (!this.properties.equal_to || this.properties.equal_to == e)) {
      if (this.properties.has_property && (c = e[this.properties.has_property], null == c || this.properties.property_equal_to && this.properties.property_equal_to != c)) {
        return;
      }
      this.triggerSlot(0, e);
    }
  };
  B.registerNodeType("events/filter", m);
  u.title = "Branch";
  u.desc = "If condition is true, outputs triggers true, otherwise false";
  u.prototype.onExecute = function() {
    this._value = this.getInputData(1);
  };
  u.prototype.onAction = function(c, e) {
    this.triggerSlot(this._value ? 0 : 1);
  };
  B.registerNodeType("events/branch", u);
  l.title = "Counter";
  l.desc = "Counts events";
  l.prototype.getTitle = function() {
    return this.flags.collapsed ? String(this.num) : this.title;
  };
  l.prototype.onAction = function(c, e) {
    e = this.num;
    "inc" == c ? this.num += 1 : "dec" == c ? --this.num : "reset" == c && (this.num = 0);
    this.num != e && this.trigger("change", this.num);
  };
  l.prototype.onDrawBackground = function(c) {
    this.flags.collapsed || (c.fillStyle = "#AAA", c.font = "20px Arial", c.textAlign = "center", c.fillText(this.num, 0.5 * this.size[0], 0.5 * this.size[1]));
  };
  l.prototype.onExecute = function() {
    this.setOutputData(1, this.num);
  };
  B.registerNodeType("events/counter", l);
  G.title = "Delay";
  G.desc = "Delays one event";
  G.prototype.onAction = function(c, e) {
    c = this.properties.time_in_ms;
    0 >= c ? this.trigger(null, e) : this._pending.push([c, e]);
  };
  G.prototype.onExecute = function() {
    var c = 1000 * this.graph.elapsed_time;
    this.isInputConnected(1) && (this.properties.time_in_ms = this.getInputData(1));
    for (var e = 0; e < this._pending.length; ++e) {
      var g = this._pending[e];
      g[0] -= c;
      0 < g[0] || (this._pending.splice(e, 1), --e, this.trigger(null, g[1]));
    }
  };
  G.prototype.onGetInputs = function() {
    return [["event", B.ACTION], ["time_in_ms", "number"]];
  };
  B.registerNodeType("events/delay", G);
  A.title = "Timer";
  A.desc = "Sends an event every N milliseconds";
  A.prototype.onStart = function() {
    this.time = 0;
  };
  A.prototype.getTitle = function() {
    return "Timer: " + this.last_interval.toString() + "ms";
  };
  A.on_color = "#AAA";
  A.off_color = "#222";
  A.prototype.onDrawBackground = function() {
    this.boxcolor = this.triggered ? A.on_color : A.off_color;
    this.triggered = !1;
  };
  A.prototype.onExecute = function() {
    var c = 0 == this.time;
    this.time += 1000 * this.graph.elapsed_time;
    this.last_interval = Math.max(1, this.getInputOrProperty("interval") | 0);
    !c && (this.time < this.last_interval || isNaN(this.last_interval)) ? this.inputs && 1 < this.inputs.length && this.inputs[1] && this.setOutputData(1, !1) : (this.triggered = !0, this.time %= this.last_interval, this.trigger("on_tick", this.properties.event), this.inputs && 1 < this.inputs.length && this.inputs[1] && this.setOutputData(1, !0));
  };
  A.prototype.onGetInputs = function() {
    return [["interval", "number"]];
  };
  A.prototype.onGetOutputs = function() {
    return [["tick", "boolean"]];
  };
  B.registerNodeType("events/timer", A);
  D.title = "Data Store";
  D.desc = "Stores data and only changes when event is received";
  D.prototype.onExecute = function() {
    this._last_value = this.getInputData(0);
    this.setOutputData(0, this.properties.data);
  };
  D.prototype.onAction = function(c, e) {
    this.properties.data = this._last_value;
  };
  D.prototype.onSerialize = function(c) {
    null != c.data && (0 == this.properties.serialize || c.data.constructor !== String && c.data.constructor !== Number && c.data.constructor !== Boolean && c.data.constructor !== Array && c.data.constructor !== Object) && (c.data = null);
  };
  B.registerNodeType("basic/data_store", D);
})(this);
(function(y) {
  function c() {
    this.addOutput("", F.EVENT);
    this.addOutput("", "boolean");
    this.addProperty("text", "click me");
    this.addProperty("font_size", 30);
    this.addProperty("message", "");
    this.size = [164, 84];
    this.clicked = !1;
  }
  function g() {
    this.addInput("", "boolean");
    this.addInput("e", F.ACTION);
    this.addOutput("v", "boolean");
    this.addOutput("e", F.EVENT);
    this.properties = {font:"", value:!1};
    this.size = [160, 44];
  }
  function n() {
    this.addOutput("", "number");
    this.size = [80, 60];
    this.properties = {min:-1000, max:1000, value:1, step:1};
    this.old_y = -1;
    this._precision = this._remainder = 0;
    this.mouse_captured = !1;
  }
  function m() {
    this.addOutput("", "string");
    this.addOutput("change", F.EVENT);
    this.size = [80, 60];
    this.properties = {value:"A", values:"A;B;C"};
    this.old_y = -1;
    this.mouse_captured = !1;
    this._values = this.properties.values.split(";");
    var c = this;
    this.widgets_up = !0;
    this.widget = this.addWidget("combo", "", this.properties.value, function(e) {
      c.properties.value = e;
      c.triggerSlot(1, e);
    }, {property:"value", values:this._values});
  }
  function u() {
    this.addOutput("", "number");
    this.size = [64, 84];
    this.properties = {min:0, max:1, value:0.5, color:"#7AF", precision:2};
    this.value = -1;
  }
  function l() {
    this.addOutput("", "number");
    this.properties = {value:0.5, min:0, max:1, text:"V"};
    var c = this;
    this.size = [140, 40];
    this.slider = this.addWidget("slider", "V", this.properties.value, function(e) {
      c.properties.value = e;
    }, this.properties);
    this.widgets_up = !0;
  }
  function G() {
    this.size = [160, 26];
    this.addOutput("", "number");
    this.properties = {color:"#7AF", min:0, max:1, value:0.5};
    this.value = -1;
  }
  function A() {
    this.size = [160, 26];
    this.addInput("", "number");
    this.properties = {min:0, max:1, value:0, color:"#AAF"};
  }
  function D() {
    this.addInputs("", 0);
    this.properties = {value:"...", font:"Arial", fontsize:18, color:"#AAA", align:"left", glowSize:0, decimals:1};
  }
  function B() {
    this.size = [200, 100];
    this.properties = {borderColor:"#ffffff", bgcolorTop:"#f0f0f0", bgcolorBottom:"#e0e0e0", shadowSize:2, borderRadius:3};
  }
  var F = y.LiteGraph;
  c.title = "Button";
  c.desc = "Triggers an event";
  c.font = "Arial";
  c.prototype.onDrawForeground = function(e) {
    if (!this.flags.collapsed && (e.fillStyle = "black", e.fillRect(11, 11, this.size[0] - 20, this.size[1] - 20), e.fillStyle = "#AAF", e.fillRect(9, 9, this.size[0] - 20, this.size[1] - 20), e.fillStyle = this.clicked ? "white" : this.mouseOver ? "#668" : "#334", e.fillRect(10, 10, this.size[0] - 20, this.size[1] - 20), this.properties.text || 0 === this.properties.text)) {
      var g = this.properties.font_size || 30;
      e.textAlign = "center";
      e.fillStyle = this.clicked ? "black" : "white";
      e.font = g + "px " + c.font;
      e.fillText(this.properties.text, 0.5 * this.size[0], 0.5 * this.size[1] + 0.3 * g);
      e.textAlign = "left";
    }
  };
  c.prototype.onMouseDown = function(c, g) {
    if (1 < g[0] && 1 < g[1] && g[0] < this.size[0] - 2 && g[1] < this.size[1] - 2) {
      return this.clicked = !0, this.triggerSlot(0, this.properties.message), !0;
    }
  };
  c.prototype.onExecute = function() {
    this.setOutputData(1, this.clicked);
  };
  c.prototype.onMouseUp = function(c) {
    this.clicked = !1;
  };
  F.registerNodeType("widget/button", c);
  g.title = "Toggle";
  g.desc = "Toggles between true or false";
  g.prototype.onDrawForeground = function(c) {
    if (!this.flags.collapsed) {
      var e = 0.5 * this.size[1], g = 0.8 * this.size[1];
      c.font = this.properties.font || (0.8 * e).toFixed(0) + "px Arial";
      var l = c.measureText(this.title).width;
      l = 0.5 * (this.size[0] - (l + e));
      c.fillStyle = "#AAA";
      c.fillRect(l, g - e, e, e);
      c.fillStyle = this.properties.value ? "#AEF" : "#000";
      c.fillRect(l + 0.25 * e, g - e + 0.25 * e, .5 * e, .5 * e);
      c.textAlign = "left";
      c.fillStyle = "#AAA";
      c.fillText(this.title, 1.2 * e + l, 0.85 * g);
      c.textAlign = "left";
    }
  };
  g.prototype.onAction = function(c) {
    this.properties.value = !this.properties.value;
    this.trigger("e", this.properties.value);
  };
  g.prototype.onExecute = function() {
    var c = this.getInputData(0);
    null != c && (this.properties.value = c);
    this.setOutputData(0, this.properties.value);
  };
  g.prototype.onMouseDown = function(c, g) {
    if (1 < g[0] && 1 < g[1] && g[0] < this.size[0] - 2 && g[1] < this.size[1] - 2) {
      return this.properties.value = !this.properties.value, this.graph._version++, this.trigger("e", this.properties.value), !0;
    }
  };
  F.registerNodeType("widget/toggle", g);
  n.title = "Number";
  n.desc = "Widget to select number value";
  n.pixels_threshold = 10;
  n.markers_color = "#666";
  n.prototype.onDrawForeground = function(c) {
    var e = 0.5 * this.size[0], g = this.size[1];
    30 < g ? (c.fillStyle = n.markers_color, c.beginPath(), c.moveTo(e, 0.1 * g), c.lineTo(e + 0.1 * g, 0.2 * g), c.lineTo(e + -0.1 * g, 0.2 * g), c.fill(), c.beginPath(), c.moveTo(e, 0.9 * g), c.lineTo(e + 0.1 * g, 0.8 * g), c.lineTo(e + -0.1 * g, 0.8 * g), c.fill(), c.font = (0.7 * g).toFixed(1) + "px Arial") : c.font = (0.8 * g).toFixed(1) + "px Arial";
    c.textAlign = "center";
    c.font = (0.7 * g).toFixed(1) + "px Arial";
    c.fillStyle = "#EEE";
    c.fillText(this.properties.value.toFixed(this._precision), e, 0.75 * g);
  };
  n.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  n.prototype.onPropertyChanged = function(c, g) {
    c = (this.properties.step + "").split(".");
    this._precision = 1 < c.length ? c[1].length : 0;
  };
  n.prototype.onMouseDown = function(c, g) {
    if (!(0 > g[1])) {
      return this.old_y = c.canvasY, this.captureInput(!0), this.mouse_captured = !0;
    }
  };
  n.prototype.onMouseMove = function(c) {
    if (this.mouse_captured) {
      var e = this.old_y - c.canvasY;
      c.shiftKey && (e *= 10);
      if (c.metaKey || c.altKey) {
        e *= 0.1;
      }
      this.old_y = c.canvasY;
      c = this._remainder + e / n.pixels_threshold;
      this._remainder = c % 1;
      c = Math.clamp(this.properties.value + (c | 0) * this.properties.step, this.properties.min, this.properties.max);
      this.properties.value = c;
      this.graph._version++;
      this.setDirtyCanvas(!0);
    }
  };
  n.prototype.onMouseUp = function(c, g) {
    200 > c.click_time && (this.properties.value = Math.clamp(this.properties.value + (g[1] > 0.5 * this.size[1] ? -1 : 1) * this.properties.step, this.properties.min, this.properties.max), this.graph._version++, this.setDirtyCanvas(!0));
    this.mouse_captured && (this.mouse_captured = !1, this.captureInput(!1));
  };
  F.registerNodeType("widget/number", n);
  m.title = "Combo";
  m.desc = "Widget to select from a list";
  m.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  m.prototype.onPropertyChanged = function(c, g) {
    "values" == c ? (this._values = g.split(";"), this.widget.options.values = this._values) : "value" == c && (this.widget.value = g);
  };
  F.registerNodeType("widget/combo", m);
  u.title = "Knob";
  u.desc = "Circular controller";
  u.size = [80, 100];
  u.prototype.onDrawForeground = function(c) {
    if (!this.flags.collapsed) {
      -1 == this.value && (this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min));
      var e = 0.5 * this.size[0], g = 0.5 * this.size[1], l = 0.5 * Math.min(this.size[0], this.size[1]) - 5;
      c.globalAlpha = 1;
      c.save();
      c.translate(e, g);
      c.rotate(0.75 * Math.PI);
      c.fillStyle = "rgba(0,0,0,0.5)";
      c.beginPath();
      c.moveTo(0, 0);
      c.arc(0, 0, l, 0, 1.5 * Math.PI);
      c.fill();
      c.strokeStyle = "black";
      c.fillStyle = this.properties.color;
      c.lineWidth = 2;
      c.beginPath();
      c.moveTo(0, 0);
      c.arc(0, 0, l - 4, 0, 1.5 * Math.PI * Math.max(0.01, this.value));
      c.closePath();
      c.fill();
      c.lineWidth = 1;
      c.globalAlpha = 1;
      c.restore();
      c.fillStyle = "black";
      c.beginPath();
      c.arc(e, g, 0.75 * l, 0, 2 * Math.PI, !0);
      c.fill();
      c.fillStyle = this.mouseOver ? "white" : this.properties.color;
      c.beginPath();
      var m = this.value * Math.PI * 1.5 + 0.75 * Math.PI;
      c.arc(e + Math.cos(m) * l * 0.65, g + Math.sin(m) * l * 0.65, 0.05 * l, 0, 2 * Math.PI, !0);
      c.fill();
      c.fillStyle = this.mouseOver ? "white" : "#AAA";
      c.font = Math.floor(0.5 * l) + "px Arial";
      c.textAlign = "center";
      c.fillText(this.properties.value.toFixed(this.properties.precision), e, g + 0.15 * l);
    }
  };
  u.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
    this.boxcolor = F.colorToString([this.value, this.value, this.value]);
  };
  u.prototype.onMouseDown = function(c) {
    this.center = [0.5 * this.size[0], 0.5 * this.size[1] + 20];
    this.radius = 0.5 * this.size[0];
    if (20 > c.canvasY - this.pos[1] || F.distance([c.canvasX, c.canvasY], [this.pos[0] + this.center[0], this.pos[1] + this.center[1]]) > this.radius) {
      return !1;
    }
    this.oldmouse = [c.canvasX - this.pos[0], c.canvasY - this.pos[1]];
    this.captureInput(!0);
    return !0;
  };
  u.prototype.onMouseMove = function(c) {
    if (this.oldmouse) {
      c = [c.canvasX - this.pos[0], c.canvasY - this.pos[1]];
      var e = this.value;
      e -= 0.01 * (c[1] - this.oldmouse[1]);
      1.0 < e ? e = 1.0 : 0.0 > e && (e = 0.0);
      this.value = e;
      this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
      this.oldmouse = c;
      this.setDirtyCanvas(!0);
    }
  };
  u.prototype.onMouseUp = function(c) {
    this.oldmouse && (this.oldmouse = null, this.captureInput(!1));
  };
  u.prototype.onPropertyChanged = function(c, g) {
    if ("min" == c || "max" == c || "value" == c) {
      return this.properties[c] = parseFloat(g), !0;
    }
  };
  F.registerNodeType("widget/knob", u);
  l.title = "Inner Slider";
  l.prototype.onPropertyChanged = function(c, g) {
    "value" == c && (this.slider.value = g);
  };
  l.prototype.onExecute = function() {
    this.setOutputData(0, this.properties.value);
  };
  F.registerNodeType("widget/internal_slider", l);
  G.title = "H.Slider";
  G.desc = "Linear slider controller";
  G.prototype.onDrawForeground = function(c) {
    -1 == this.value && (this.value = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min));
    c.globalAlpha = 1;
    c.lineWidth = 1;
    c.fillStyle = "#000";
    c.fillRect(2, 2, this.size[0] - 4, this.size[1] - 4);
    c.fillStyle = this.properties.color;
    c.beginPath();
    c.rect(4, 4, (this.size[0] - 8) * this.value, this.size[1] - 8);
    c.fill();
  };
  G.prototype.onExecute = function() {
    this.properties.value = this.properties.min + (this.properties.max - this.properties.min) * this.value;
    this.setOutputData(0, this.properties.value);
    this.boxcolor = F.colorToString([this.value, this.value, this.value]);
  };
  G.prototype.onMouseDown = function(c) {
    if (0 > c.canvasY - this.pos[1]) {
      return !1;
    }
    this.oldmouse = [c.canvasX - this.pos[0], c.canvasY - this.pos[1]];
    this.captureInput(!0);
    return !0;
  };
  G.prototype.onMouseMove = function(c) {
    if (this.oldmouse) {
      c = [c.canvasX - this.pos[0], c.canvasY - this.pos[1]];
      var e = this.value;
      e += (c[0] - this.oldmouse[0]) / this.size[0];
      1.0 < e ? e = 1.0 : 0.0 > e && (e = 0.0);
      this.value = e;
      this.oldmouse = c;
      this.setDirtyCanvas(!0);
    }
  };
  G.prototype.onMouseUp = function(c) {
    this.oldmouse = null;
    this.captureInput(!1);
  };
  G.prototype.onMouseLeave = function(c) {
  };
  F.registerNodeType("widget/hslider", G);
  A.title = "Progress";
  A.desc = "Shows data in linear progress";
  A.prototype.onExecute = function() {
    var c = this.getInputData(0);
    void 0 != c && (this.properties.value = c);
  };
  A.prototype.onDrawForeground = function(c) {
    c.lineWidth = 1;
    c.fillStyle = this.properties.color;
    var e = (this.properties.value - this.properties.min) / (this.properties.max - this.properties.min);
    e = Math.min(1, e);
    e = Math.max(0, e);
    c.fillRect(2, 2, (this.size[0] - 4) * e, this.size[1] - 4);
  };
  F.registerNodeType("widget/progress", A);
  D.title = "Text";
  D.desc = "Shows the input value";
  D.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"led_text", text:"LED", type:"minibutton"}, {name:"normal_text", text:"Normal", type:"minibutton"}];
  D.prototype.onDrawForeground = function(c) {
    c.fillStyle = this.properties.color;
    var e = this.properties.value;
    this.properties.glowSize ? (c.shadowColor = this.properties.color, c.shadowOffsetX = 0, c.shadowOffsetY = 0, c.shadowBlur = this.properties.glowSize) : c.shadowColor = "transparent";
    var g = this.properties.fontsize;
    c.textAlign = this.properties.align;
    c.font = g.toString() + "px " + this.properties.font;
    this.str = "number" == typeof e ? e.toFixed(this.properties.decimals) : e;
    if ("string" == typeof this.str) {
      e = this.str.split("\\n");
      for (var l = 0; l < e.length; l++) {
        c.fillText(e[l], "left" == this.properties.align ? 15 : this.size[0] - 15, -0.15 * g + g * (parseInt(l) + 1));
      }
    }
    c.shadowColor = "transparent";
    this.last_ctx = c;
    c.textAlign = "left";
  };
  D.prototype.onExecute = function() {
    var c = this.getInputData(0);
    null != c && (this.properties.value = c);
  };
  D.prototype.resize = function() {
    if (this.last_ctx) {
      var c = this.str.split("\\n");
      this.last_ctx.font = this.properties.fontsize + "px " + this.properties.font;
      for (var g = 0, l = 0; l < c.length; l++) {
        var m = this.last_ctx.measureText(c[l]).width;
        g < m && (g = m);
      }
      this.size[0] = g + 20;
      this.size[1] = 4 + c.length * this.properties.fontsize;
      this.setDirtyCanvas(!0);
    }
  };
  D.prototype.onPropertyChanged = function(c, g) {
    this.properties[c] = g;
    this.str = "number" == typeof g ? g.toFixed(3) : g;
    return !0;
  };
  F.registerNodeType("widget/text", D);
  B.title = "Panel";
  B.desc = "Non interactive panel";
  B.widgets = [{name:"update", text:"Update", type:"button"}];
  B.prototype.createGradient = function(c) {
    "" == this.properties.bgcolorTop || "" == this.properties.bgcolorBottom ? this.lineargradient = 0 : (this.lineargradient = c.createLinearGradient(0, 0, 0, this.size[1]), this.lineargradient.addColorStop(0, this.properties.bgcolorTop), this.lineargradient.addColorStop(1, this.properties.bgcolorBottom));
  };
  B.prototype.onDrawForeground = function(c) {
    this.flags.collapsed || (null == this.lineargradient && this.createGradient(c), this.lineargradient && (c.lineWidth = 1, c.strokeStyle = this.properties.borderColor, c.fillStyle = this.lineargradient, this.properties.shadowSize ? (c.shadowColor = "#000", c.shadowOffsetX = 0, c.shadowOffsetY = 0, c.shadowBlur = this.properties.shadowSize) : c.shadowColor = "transparent", c.roundRect(0, 0, this.size[0] - 1, this.size[1] - 1, this.properties.shadowSize), c.fill(), c.shadowColor = "transparent", 
    c.stroke()));
  };
  F.registerNodeType("widget/panel", B);
})(this);
(function(y) {
  function c() {
    this.addOutput("left_x_axis", "number");
    this.addOutput("left_y_axis", "number");
    this.addOutput("button_pressed", g.EVENT);
    this.properties = {gamepad_index:0, threshold:0.1};
    this._left_axis = new Float32Array(2);
    this._right_axis = new Float32Array(2);
    this._triggers = new Float32Array(2);
    this._previous_buttons = new Uint8Array(17);
    this._current_buttons = new Uint8Array(17);
  }
  var g = y.LiteGraph;
  c.title = "Gamepad";
  c.desc = "gets the input of the gamepad";
  c.CENTER = 0;
  c.LEFT = 1;
  c.RIGHT = 2;
  c.UP = 4;
  c.DOWN = 8;
  c.zero = new Float32Array(2);
  c.buttons = "a b x y lb rb lt rt back start ls rs home".split(" ");
  c.prototype.onExecute = function() {
    var g = this.getGamepad(), m = this.properties.threshold || 0.0;
    g && (this._left_axis[0] = Math.abs(g.xbox.axes.lx) > m ? g.xbox.axes.lx : 0, this._left_axis[1] = Math.abs(g.xbox.axes.ly) > m ? g.xbox.axes.ly : 0, this._right_axis[0] = Math.abs(g.xbox.axes.rx) > m ? g.xbox.axes.rx : 0, this._right_axis[1] = Math.abs(g.xbox.axes.ry) > m ? g.xbox.axes.ry : 0, this._triggers[0] = Math.abs(g.xbox.axes.ltrigger) > m ? g.xbox.axes.ltrigger : 0, this._triggers[1] = Math.abs(g.xbox.axes.rtrigger) > m ? g.xbox.axes.rtrigger : 0);
    if (this.outputs) {
      for (m = 0; m < this.outputs.length; m++) {
        var u = this.outputs[m];
        if (u.links && u.links.length) {
          var l = null;
          if (g) {
            switch(u.name) {
              case "left_axis":
                l = this._left_axis;
                break;
              case "right_axis":
                l = this._right_axis;
                break;
              case "left_x_axis":
                l = this._left_axis[0];
                break;
              case "left_y_axis":
                l = this._left_axis[1];
                break;
              case "right_x_axis":
                l = this._right_axis[0];
                break;
              case "right_y_axis":
                l = this._right_axis[1];
                break;
              case "trigger_left":
                l = this._triggers[0];
                break;
              case "trigger_right":
                l = this._triggers[1];
                break;
              case "a_button":
                l = g.xbox.buttons.a ? 1 : 0;
                break;
              case "b_button":
                l = g.xbox.buttons.b ? 1 : 0;
                break;
              case "x_button":
                l = g.xbox.buttons.x ? 1 : 0;
                break;
              case "y_button":
                l = g.xbox.buttons.y ? 1 : 0;
                break;
              case "lb_button":
                l = g.xbox.buttons.lb ? 1 : 0;
                break;
              case "rb_button":
                l = g.xbox.buttons.rb ? 1 : 0;
                break;
              case "ls_button":
                l = g.xbox.buttons.ls ? 1 : 0;
                break;
              case "rs_button":
                l = g.xbox.buttons.rs ? 1 : 0;
                break;
              case "hat_left":
                l = g.xbox.hatmap & c.LEFT;
                break;
              case "hat_right":
                l = g.xbox.hatmap & c.RIGHT;
                break;
              case "hat_up":
                l = g.xbox.hatmap & c.UP;
                break;
              case "hat_down":
                l = g.xbox.hatmap & c.DOWN;
                break;
              case "hat":
                l = g.xbox.hatmap;
                break;
              case "start_button":
                l = g.xbox.buttons.start ? 1 : 0;
                break;
              case "back_button":
                l = g.xbox.buttons.back ? 1 : 0;
                break;
              case "button_pressed":
                for (u = 0; u < this._current_buttons.length; ++u) {
                  this._current_buttons[u] && !this._previous_buttons[u] && this.triggerSlot(m, c.buttons[u]);
                }
            }
          } else {
            switch(u.name) {
              case "button_pressed":
                break;
              case "left_axis":
              case "right_axis":
                l = c.zero;
                break;
              default:
                l = 0;
            }
          }
          this.setOutputData(m, l);
        }
      }
    }
  };
  c.mapping = {a:0, b:1, x:2, y:3, lb:4, rb:5, lt:6, rt:7, back:8, start:9, ls:10, rs:11};
  c.mapping_array = "a b x y lb rb lt rt back start ls rs".split(" ");
  c.prototype.getGamepad = function() {
    var g = navigator.getGamepads || navigator.webkitGetGamepads || navigator.mozGetGamepads;
    if (!g) {
      return null;
    }
    g = g.call(navigator);
    this._previous_buttons.set(this._current_buttons);
    for (var m = this.properties.gamepad_index; 4 > m; m++) {
      if (g[m]) {
        g = g[m];
        m = this.xbox_mapping;
        m || (m = this.xbox_mapping = {axes:[], buttons:{}, hat:"", hatmap:c.CENTER});
        m.axes.lx = g.axes[0];
        m.axes.ly = g.axes[1];
        m.axes.rx = g.axes[2];
        m.axes.ry = g.axes[3];
        m.axes.ltrigger = g.buttons[6].value;
        m.axes.rtrigger = g.buttons[7].value;
        m.hat = "";
        m.hatmap = c.CENTER;
        for (var u = 0; u < g.buttons.length; u++) {
          if (this._current_buttons[u] = g.buttons[u].pressed, 12 > u) {
            m.buttons[c.mapping_array[u]] = g.buttons[u].pressed, g.buttons[u].was_pressed && this.trigger(c.mapping_array[u] + "_button_event");
          } else {
            switch(u) {
              case 12:
                g.buttons[u].pressed && (m.hat += "up", m.hatmap |= c.UP);
                break;
              case 13:
                g.buttons[u].pressed && (m.hat += "down", m.hatmap |= c.DOWN);
                break;
              case 14:
                g.buttons[u].pressed && (m.hat += "left", m.hatmap |= c.LEFT);
                break;
              case 15:
                g.buttons[u].pressed && (m.hat += "right", m.hatmap |= c.RIGHT);
                break;
              case 16:
                m.buttons.home = g.buttons[u].pressed;
            }
          }
        }
        g.xbox = m;
        return g;
      }
    }
  };
  c.prototype.onDrawBackground = function(c) {
    if (!this.flags.collapsed) {
      var g = this._left_axis, n = this._right_axis;
      c.strokeStyle = "#88A";
      c.strokeRect(0.5 * (g[0] + 1) * this.size[0] - 4, 0.5 * (g[1] + 1) * this.size[1] - 4, 8, 8);
      c.strokeStyle = "#8A8";
      c.strokeRect(0.5 * (n[0] + 1) * this.size[0] - 4, 0.5 * (n[1] + 1) * this.size[1] - 4, 8, 8);
      g = this.size[1] / this._current_buttons.length;
      c.fillStyle = "#AEB";
      for (n = 0; n < this._current_buttons.length; ++n) {
        this._current_buttons[n] && c.fillRect(0, g * n, 6, g);
      }
    }
  };
  c.prototype.onGetOutputs = function() {
    return [["left_axis", "vec2"], ["right_axis", "vec2"], ["left_x_axis", "number"], ["left_y_axis", "number"], ["right_x_axis", "number"], ["right_y_axis", "number"], ["trigger_left", "number"], ["trigger_right", "number"], ["a_button", "number"], ["b_button", "number"], ["x_button", "number"], ["y_button", "number"], ["lb_button", "number"], ["rb_button", "number"], ["ls_button", "number"], ["rs_button", "number"], ["start_button", "number"], ["back_button", "number"], ["a_button_event", g.EVENT], 
    ["b_button_event", g.EVENT], ["x_button_event", g.EVENT], ["y_button_event", g.EVENT], ["lb_button_event", g.EVENT], ["rb_button_event", g.EVENT], ["ls_button_event", g.EVENT], ["rs_button_event", g.EVENT], ["start_button_event", g.EVENT], ["back_button_event", g.EVENT], ["hat_left", "number"], ["hat_right", "number"], ["hat_up", "number"], ["hat_down", "number"], ["hat", "number"], ["button_pressed", g.EVENT]];
  };
  g.registerNodeType("input/gamepad", c);
})(this);
(function(y) {
  function c() {
    this.addInput("in", "");
    this.addOutput("out");
    this.size = [80, 30];
  }
  function g() {
    this.addInput("in");
    this.addOutput("out");
    this.size = [80, 30];
  }
  function n() {
    this.addInput("in");
    this.addOutput("out");
  }
  function m() {
    this.addInput("in", "number", {locked:!0});
    this.addOutput("out", "number", {locked:!0});
    this.addOutput("clamped", "number", {locked:!0});
    this.addProperty("in", 0);
    this.addProperty("in_min", 0);
    this.addProperty("in_max", 1);
    this.addProperty("out_min", 0);
    this.addProperty("out_max", 1);
    this.size = [120, 50];
  }
  function u() {
    this.addOutput("value", "number");
    this.addProperty("min", 0);
    this.addProperty("max", 1);
    this.size = [80, 30];
  }
  function l() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.addProperty("min", 0);
    this.addProperty("max", 1);
    this.addProperty("smooth", !0);
    this.addProperty("seed", 0);
    this.addProperty("octaves", 1);
    this.addProperty("persistence", 0.8);
    this.addProperty("speed", 1);
    this.size = [90, 30];
  }
  function G() {
    this.addOutput("out", "number");
    this.addProperty("min_time", 1);
    this.addProperty("max_time", 2);
    this.addProperty("duration", 0.2);
    this.size = [90, 30];
    this._blink_time = this._remaining_time = 0;
  }
  function A() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
    this.addProperty("min", 0);
    this.addProperty("max", 1);
  }
  function D() {
    this.properties = {f:0.5};
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("out", "number");
  }
  function B() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
  }
  function F() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
  }
  function e() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
  }
  function z() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
    this.properties = {A:0, B:1};
  }
  function H() {
    this.addInput("in", "number", {label:""});
    this.addOutput("out", "number", {label:""});
    this.size = [80, 30];
    this.addProperty("factor", 1);
  }
  function x() {
    this.addInput("v", "boolean");
    this.addInput("A");
    this.addInput("B");
    this.addOutput("out");
  }
  function K() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.size = [80, 30];
    this.addProperty("samples", 10);
    this._values = new Float32Array(10);
    this._current = 0;
  }
  function k() {
    this.addInput("in", "number");
    this.addOutput("out", "number");
    this.addProperty("factor", 0.1);
    this.size = [80, 30];
    this._value = null;
  }
  function q() {
    this.addInput("A", "number,array,object");
    this.addInput("B", "number");
    this.addOutput("=", "number");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", "+", "enum", {values:q.values});
    this._func = function(a, b) {
      return a + b;
    };
    this._result = [];
  }
  function t() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("A==B", "boolean");
    this.addOutput("A!=B", "boolean");
    this.addProperty("A", 0);
    this.addProperty("B", 0);
  }
  function a() {
    this.addInput("A", "number");
    this.addInput("B", "number");
    this.addOutput("true", "boolean");
    this.addOutput("false", "boolean");
    this.addProperty("A", 1);
    this.addProperty("B", 1);
    this.addProperty("OP", ">", "enum", {values:a.values});
    this.addWidget("combo", "Cond.", this.properties.OP, {property:"OP", values:a.values});
    this.size = [80, 60];
  }
  function b() {
    this.addInput("in", "");
    this.addInput("cond", "boolean");
    this.addOutput("true", "");
    this.addOutput("false", "");
    this.size = [80, 60];
  }
  function d() {
    this.addInput("inc", "number");
    this.addOutput("total", "number");
    this.addProperty("increment", 1);
    this.addProperty("value", 0);
  }
  function f() {
    this.addInput("v", "number");
    this.addOutput("sin", "number");
    this.addProperty("amplitude", 1);
    this.addProperty("offset", 0);
    this.bgImageUrl = "nodes/imgs/icon-sin.png";
  }
  function h() {
    this.addInput("x", "number");
    this.addInput("y", "number");
    this.addOutput("", "number");
    this.properties = {x:1.0, y:1.0, formula:"x+y"};
    this.code_widget = this.addWidget("text", "F(x,y)", this.properties.formula, function(a, b, d) {
      d.properties.formula = a;
    });
    this.addWidget("toggle", "allow", C.allow_scripts, function(a) {
      C.allow_scripts = a;
    });
    this._func = null;
  }
  function w() {
    this.addInput("vec2", "vec2");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
  }
  function v() {
    this.addInputs([["x", "number"], ["y", "number"]]);
    this.addOutput("vec2", "vec2");
    this.properties = {x:0, y:0};
    this._data = new Float32Array(2);
  }
  function r() {
    this.addInput("vec3", "vec3");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
  }
  function N() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"]]);
    this.addOutput("vec3", "vec3");
    this.properties = {x:0, y:0, z:0};
    this._data = new Float32Array(3);
  }
  function O() {
    this.addInput("vec4", "vec4");
    this.addOutput("x", "number");
    this.addOutput("y", "number");
    this.addOutput("z", "number");
    this.addOutput("w", "number");
  }
  function M() {
    this.addInputs([["x", "number"], ["y", "number"], ["z", "number"], ["w", "number"]]);
    this.addOutput("vec4", "vec4");
    this.properties = {x:0, y:0, z:0, w:0};
    this._data = new Float32Array(4);
  }
  var C = y.LiteGraph;
  c.title = "Converter";
  c.desc = "type A to type B";
  c.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (null != a && this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        var d = this.outputs[b];
        if (d.links && d.links.length) {
          var c = null;
          switch(d.name) {
            case "number":
              c = a.length ? a[0] : parseFloat(a);
              break;
            case "vec2":
            case "vec3":
            case "vec4":
              c = 1;
              switch(d.name) {
                case "vec2":
                  c = 2;
                  break;
                case "vec3":
                  c = 3;
                  break;
                case "vec4":
                  c = 4;
              }c = new Float32Array(c);
              if (a.length) {
                for (d = 0; d < a.length && d < c.length; d++) {
                  c[d] = a[d];
                }
              } else {
                c[0] = parseFloat(a);
              }
          }
          this.setOutputData(b, c);
        }
      }
    }
  };
  c.prototype.onGetOutputs = function() {
    return [["number", "number"], ["vec2", "vec2"], ["vec3", "vec3"], ["vec4", "vec4"]];
  };
  C.registerNodeType("math/converter", c);
  g.title = "Bypass";
  g.desc = "removes the type";
  g.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, a);
  };
  C.registerNodeType("math/bypass", g);
  n.title = "to Number";
  n.desc = "Cast to number";
  n.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, Number(a));
  };
  C.registerNodeType("math/to_number", n);
  m.title = "Range";
  m.desc = "Convert a number from one range to another";
  m.prototype.getTitle = function() {
    return this.flags.collapsed ? (this._last_v || 0).toFixed(2) : this.title;
  };
  m.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], d = this.getInputData(a);
        void 0 !== d && (this.properties[b.name] = d);
      }
    }
    d = this.properties["in"];
    if (void 0 === d || null === d || d.constructor !== Number) {
      d = 0;
    }
    a = this.properties.in_min;
    b = this.properties.out_min;
    var c = this.properties.out_max;
    this._last_v = (d - a) / (this.properties.in_max - a) * (c - b) + b;
    this.setOutputData(0, this._last_v);
    this.setOutputData(1, Math.clamp(this._last_v, b, c));
  };
  m.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = this._last_v ? this._last_v.toFixed(3) : "?";
  };
  m.prototype.onGetInputs = function() {
    return [["in_min", "number"], ["in_max", "number"], ["out_min", "number"], ["out_max", "number"]];
  };
  C.registerNodeType("math/range", m);
  u.title = "Rand";
  u.desc = "Random number";
  u.prototype.onExecute = function() {
    if (this.inputs) {
      for (var a = 0; a < this.inputs.length; a++) {
        var b = this.inputs[a], d = this.getInputData(a);
        void 0 !== d && (this.properties[b.name] = d);
      }
    }
    a = this.properties.min;
    this._last_v = Math.random() * (this.properties.max - a) + a;
    this.setOutputData(0, this._last_v);
  };
  u.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = (this._last_v || 0).toFixed(3);
  };
  u.prototype.onGetInputs = function() {
    return [["min", "number"], ["max", "number"]];
  };
  C.registerNodeType("math/rand", u);
  l.title = "Noise";
  l.desc = "Random number with temporal continuity";
  l.data = null;
  l.getValue = function(a, b) {
    if (!l.data) {
      l.data = new Float32Array(1024);
      for (var d = 0; d < l.data.length; ++d) {
        l.data[d] = Math.random();
      }
    }
    a %= 1024;
    0 > a && (a += 1024);
    var c = Math.floor(a);
    a -= c;
    d = l.data[c];
    c = l.data[1023 == c ? 0 : c + 1];
    b && (a = a * a * a * (a * (6.0 * a - 15.0) + 10.0));
    return d * (1 - a) + c * a;
  };
  l.prototype.onExecute = function() {
    var a = this.getInputData(0) || 0, b = this.properties.octaves || 1, d = 0, c = 1;
    a += this.properties.seed || 0;
    for (var f = this.properties.speed || 1, h = 0, k = 0; k < b && !(d += l.getValue(a * (1 + k) * f, this.properties.smooth) * c, h += c, c *= this.properties.persistence, 0.001 > c); ++k) {
    }
    a = this.properties.min;
    this._last_v = d / h * (this.properties.max - a) + a;
    this.setOutputData(0, this._last_v);
  };
  l.prototype.onDrawBackground = function(a) {
    this.outputs[0].label = (this._last_v || 0).toFixed(3);
  };
  C.registerNodeType("math/noise", l);
  G.title = "Spikes";
  G.desc = "spike every random time";
  G.prototype.onExecute = function() {
    var a = this.graph.elapsed_time;
    this._remaining_time -= a;
    this._blink_time -= a;
    a = 0;
    0 < this._blink_time && (a = 1 / (Math.pow(this._blink_time / this.properties.duration * 8 - 4, 4) + 1));
    0 > this._remaining_time ? (this._remaining_time = Math.random() * (this.properties.max_time - this.properties.min_time) + this.properties.min_time, this._blink_time = this.properties.duration, this.boxcolor = "#FFF") : this.boxcolor = "#000";
    this.setOutputData(0, a);
  };
  C.registerNodeType("math/spikes", G);
  A.title = "Clamp";
  A.desc = "Clamp number between min and max";
  A.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (a = Math.max(this.properties.min, a), a = Math.min(this.properties.max, a), this.setOutputData(0, a));
  };
  A.prototype.getCode = function(a) {
    a = "";
    this.isInputConnected(0) && (a += "clamp({{0}}," + this.properties.min + "," + this.properties.max + ")");
    return a;
  };
  C.registerNodeType("math/clamp", A);
  D.title = "Lerp";
  D.desc = "Linear Interpolation";
  D.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.getInputData(1);
    null == b && (b = 0);
    var d = this.properties.f, c = this.getInputData(2);
    void 0 !== c && (d = c);
    this.setOutputData(0, a * (1 - d) + b * d);
  };
  D.prototype.onGetInputs = function() {
    return [["f", "number"]];
  };
  C.registerNodeType("math/lerp", D);
  B.title = "Abs";
  B.desc = "Absolute";
  B.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.abs(a));
  };
  C.registerNodeType("math/abs", B);
  F.title = "Floor";
  F.desc = "Floor number to remove fractional part";
  F.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, Math.floor(a));
  };
  C.registerNodeType("math/floor", F);
  e.title = "Frac";
  e.desc = "Returns fractional part";
  e.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a % 1);
  };
  C.registerNodeType("math/frac", e);
  z.title = "Smoothstep";
  z.desc = "Smoothstep";
  z.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (void 0 !== a) {
      var b = this.properties.A;
      a = Math.clamp((a - b) / (this.properties.B - b), 0.0, 1.0);
      this.setOutputData(0, a * a * (3 - 2 * a));
    }
  };
  C.registerNodeType("math/smoothstep", z);
  H.title = "Scale";
  H.desc = "v * factor";
  H.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && this.setOutputData(0, a * this.properties.factor);
  };
  C.registerNodeType("math/scale", H);
  x.title = "Gate";
  x.desc = "if v is true, then outputs A, otherwise B";
  x.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.setOutputData(0, this.getInputData(a ? 1 : 2));
  };
  C.registerNodeType("math/gate", x);
  K.title = "Average";
  K.desc = "Average Filter";
  K.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this._values.length;
    this._values[this._current % b] = a;
    this._current += 1;
    this._current > b && (this._current = 0);
    for (var d = a = 0; d < b; ++d) {
      a += this._values[d];
    }
    this.setOutputData(0, a / b);
  };
  K.prototype.onPropertyChanged = function(a, b) {
    1 > b && (b = 1);
    this.properties.samples = Math.round(b);
    a = this._values;
    this._values = new Float32Array(this.properties.samples);
    a.length <= this._values.length ? this._values.set(a) : this._values.set(a.subarray(0, this._values.length));
  };
  C.registerNodeType("math/average", K);
  k.title = "TendTo";
  k.desc = "moves the output value always closer to the input";
  k.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.factor;
    this._value = null == this._value ? a : this._value * (1 - b) + a * b;
    this.setOutputData(0, this._value);
  };
  C.registerNodeType("math/tendTo", k);
  q.values = "+ - * / % ^ max min".split(" ");
  q.title = "Operation";
  q.desc = "Easy math operators";
  q["@OP"] = {type:"enum", title:"operation", values:q.values};
  q.size = [100, 60];
  q.prototype.getTitle = function() {
    return "max" == this.properties.OP || "min" == this.properties.OP ? this.properties.OP + "(A,B)" : "A " + this.properties.OP + " B";
  };
  q.prototype.setValue = function(a) {
    "string" == typeof a && (a = parseFloat(a));
    this.properties.value = a;
  };
  q.prototype.onPropertyChanged = function(a, b) {
    if ("OP" == a) {
      switch(this.properties.OP) {
        case "+":
          this._func = function(a, b) {
            return a + b;
          };
          break;
        case "-":
          this._func = function(a, b) {
            return a - b;
          };
          break;
        case "x":
        case "X":
        case "*":
          this._func = function(a, b) {
            return a * b;
          };
          break;
        case "/":
          this._func = function(a, b) {
            return a / b;
          };
          break;
        case "%":
          this._func = function(a, b) {
            return a % b;
          };
          break;
        case "^":
          this._func = function(a, b) {
            return Math.pow(a, b);
          };
          break;
        case "max":
          this._func = function(a, b) {
            return Math.max(a, b);
          };
          break;
        case "min":
          this._func = function(a, b) {
            return Math.min(a, b);
          };
          break;
        default:
          console.warn("Unknown operation: " + this.properties.OP), this._func = function(a) {
            return a;
          };
      }
    }
  };
  q.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    null != a ? a.constructor === Number && (this.properties.A = a) : a = this.properties.A;
    null != b ? this.properties.B = b : b = this.properties.B;
    if (a.constructor === Number) {
      var d = this._func(a, b);
    } else {
      if (a.constructor === Array) {
        d = this._result;
        d.length = a.length;
        for (var c = 0; c < a.length; ++c) {
          d[c] = this._func(a[c], b);
        }
      } else {
        for (c in d = {}, a) {
          d[c] = this._func(a[c], b);
        }
      }
    }
    this.setOutputData(0, d);
  };
  q.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || (a.font = "40px Arial", a.fillStyle = "#666", a.textAlign = "center", a.fillText(this.properties.OP, 0.5 * this.size[0], 0.5 * (this.size[1] + C.NODE_TITLE_HEIGHT)), a.textAlign = "left");
  };
  C.registerNodeType("math/operation", q);
  C.registerSearchboxExtra("math/operation", "MAX", {properties:{OP:"max"}, title:"MAX()"});
  C.registerSearchboxExtra("math/operation", "MIN", {properties:{OP:"min"}, title:"MIN()"});
  t.title = "Compare";
  t.desc = "compares between two values";
  t.prototype.onExecute = function() {
    var a = this.getInputData(0), b = this.getInputData(1);
    void 0 !== a ? this.properties.A = a : a = this.properties.A;
    void 0 !== b ? this.properties.B = b : b = this.properties.B;
    for (var d = 0, c = this.outputs.length; d < c; ++d) {
      var f = this.outputs[d];
      if (f.links && f.links.length) {
        switch(f.name) {
          case "A==B":
            var h = a == b;
            break;
          case "A!=B":
            h = a != b;
            break;
          case "A>B":
            h = a > b;
            break;
          case "A<B":
            h = a < b;
            break;
          case "A<=B":
            h = a <= b;
            break;
          case "A>=B":
            h = a >= b;
        }
        this.setOutputData(d, h);
      }
    }
  };
  t.prototype.onGetOutputs = function() {
    return [["A==B", "boolean"], ["A!=B", "boolean"], ["A>B", "boolean"], ["A<B", "boolean"], ["A>=B", "boolean"], ["A<=B", "boolean"]];
  };
  C.registerNodeType("math/compare", t);
  C.registerSearchboxExtra("math/compare", "==", {outputs:[["A==B", "boolean"]], title:"A==B"});
  C.registerSearchboxExtra("math/compare", "!=", {outputs:[["A!=B", "boolean"]], title:"A!=B"});
  C.registerSearchboxExtra("math/compare", ">", {outputs:[["A>B", "boolean"]], title:"A>B"});
  C.registerSearchboxExtra("math/compare", "<", {outputs:[["A<B", "boolean"]], title:"A<B"});
  C.registerSearchboxExtra("math/compare", ">=", {outputs:[["A>=B", "boolean"]], title:"A>=B"});
  C.registerSearchboxExtra("math/compare", "<=", {outputs:[["A<=B", "boolean"]], title:"A<=B"});
  a.values = "> < == != <= >= || &&".split(" ");
  a["@OP"] = {type:"enum", title:"operation", values:a.values};
  a.title = "Condition";
  a.desc = "evaluates condition between A and B";
  a.prototype.getTitle = function() {
    return "A " + this.properties.OP + " B";
  };
  a.prototype.onExecute = function() {
    var a = this.getInputData(0);
    void 0 === a ? a = this.properties.A : this.properties.A = a;
    var b = this.getInputData(1);
    void 0 === b ? b = this.properties.B : this.properties.B = b;
    var d = !0;
    switch(this.properties.OP) {
      case ">":
        d = a > b;
        break;
      case "<":
        d = a < b;
        break;
      case "==":
        d = a == b;
        break;
      case "!=":
        d = a != b;
        break;
      case "<=":
        d = a <= b;
        break;
      case ">=":
        d = a >= b;
        break;
      case "||":
        d = a || b;
        break;
      case "&&":
        d = a && b;
    }
    this.setOutputData(0, d);
    this.setOutputData(1, !d);
  };
  C.registerNodeType("math/condition", a);
  b.title = "Branch";
  b.desc = "If condition is true, outputs IN in true, otherwise in false";
  b.prototype.onExecute = function() {
    var a = this.getInputData(0);
    this.getInputData(1) ? (this.setOutputData(0, a), this.setOutputData(1, null)) : (this.setOutputData(0, null), this.setOutputData(1, a));
  };
  C.registerNodeType("math/branch", b);
  d.title = "Accumulate";
  d.desc = "Increments a value every time";
  d.prototype.onExecute = function() {
    null === this.properties.value && (this.properties.value = 0);
    var a = this.getInputData(0);
    this.properties.value = null !== a ? this.properties.value + a : this.properties.value + this.properties.increment;
    this.setOutputData(0, this.properties.value);
  };
  C.registerNodeType("math/accumulate", d);
  f.title = "Trigonometry";
  f.desc = "Sin Cos Tan";
  f.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = 0);
    var b = this.properties.amplitude, d = this.findInputSlot("amplitude");
    -1 != d && (b = this.getInputData(d));
    var c = this.properties.offset;
    d = this.findInputSlot("offset");
    -1 != d && (c = this.getInputData(d));
    d = 0;
    for (var f = this.outputs.length; d < f; ++d) {
      switch(this.outputs[d].name) {
        case "sin":
          var h = Math.sin(a);
          break;
        case "cos":
          h = Math.cos(a);
          break;
        case "tan":
          h = Math.tan(a);
          break;
        case "asin":
          h = Math.asin(a);
          break;
        case "acos":
          h = Math.acos(a);
          break;
        case "atan":
          h = Math.atan(a);
      }
      this.setOutputData(d, b * h + c);
    }
  };
  f.prototype.onGetInputs = function() {
    return [["v", "number"], ["amplitude", "number"], ["offset", "number"]];
  };
  f.prototype.onGetOutputs = function() {
    return [["sin", "number"], ["cos", "number"], ["tan", "number"], ["asin", "number"], ["acos", "number"], ["atan", "number"]];
  };
  C.registerNodeType("math/trigonometry", f);
  C.registerSearchboxExtra("math/trigonometry", "SIN()", {outputs:[["sin", "number"]], title:"SIN()"});
  C.registerSearchboxExtra("math/trigonometry", "COS()", {outputs:[["cos", "number"]], title:"COS()"});
  C.registerSearchboxExtra("math/trigonometry", "TAN()", {outputs:[["tan", "number"]], title:"TAN()"});
  h.title = "Formula";
  h.desc = "Compute formula";
  h.size = [160, 100];
  K.prototype.onPropertyChanged = function(a, b) {
    "formula" == a && (this.code_widget.value = b);
  };
  h.prototype.onExecute = function() {
    if (C.allow_scripts) {
      var a = this.getInputData(0), b = this.getInputData(1);
      null != a ? this.properties.x = a : a = this.properties.x;
      null != b ? this.properties.y = b : b = this.properties.y;
      try {
        this._func && this._func_code == this.properties.formula || (this._func = new Function("x", "y", "TIME", "return " + this.properties.formula), this._func_code = this.properties.formula);
        var d = this._func(a, b, this.graph.globaltime);
        this.boxcolor = null;
      } catch (P) {
        this.boxcolor = "red";
      }
      this.setOutputData(0, d);
    }
  };
  h.prototype.getTitle = function() {
    return this._func_code || "Formula";
  };
  h.prototype.onDrawBackground = function() {
    var a = this.properties.formula;
    this.outputs && this.outputs.length && (this.outputs[0].label = a);
  };
  C.registerNodeType("math/formula", h);
  w.title = "Vec2->XY";
  w.desc = "vector 2 to components";
  w.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]));
  };
  C.registerNodeType("math3d/vec2-to-xy", w);
  v.title = "XY->Vec2";
  v.desc = "components to vector2";
  v.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var d = this._data;
    d[0] = a;
    d[1] = b;
    this.setOutputData(0, d);
  };
  C.registerNodeType("math3d/xy-to-vec2", v);
  r.title = "Vec3->XYZ";
  r.desc = "vector 3 to components";
  r.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]));
  };
  C.registerNodeType("math3d/vec3-to-xyz", r);
  N.title = "XYZ->Vec3";
  N.desc = "components to vector3";
  N.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var d = this.getInputData(2);
    null == d && (d = this.properties.z);
    var c = this._data;
    c[0] = a;
    c[1] = b;
    c[2] = d;
    this.setOutputData(0, c);
  };
  C.registerNodeType("math3d/xyz-to-vec3", N);
  O.title = "Vec4->XYZW";
  O.desc = "vector 4 to components";
  O.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null != a && (this.setOutputData(0, a[0]), this.setOutputData(1, a[1]), this.setOutputData(2, a[2]), this.setOutputData(3, a[3]));
  };
  C.registerNodeType("math3d/vec4-to-xyzw", O);
  M.title = "XYZW->Vec4";
  M.desc = "components to vector4";
  M.prototype.onExecute = function() {
    var a = this.getInputData(0);
    null == a && (a = this.properties.x);
    var b = this.getInputData(1);
    null == b && (b = this.properties.y);
    var d = this.getInputData(2);
    null == d && (d = this.properties.z);
    var c = this.getInputData(3);
    null == c && (c = this.properties.w);
    var f = this._data;
    f[0] = a;
    f[1] = b;
    f[2] = d;
    f[3] = c;
    this.setOutputData(0, f);
  };
  C.registerNodeType("math3d/xyzw-to-vec4", M);
})(this);
(function(y) {
  function c() {
    this.addInput("T", "vec3");
    this.addInput("R", "vec3");
    this.addInput("S", "vec3");
    this.addOutput("mat4", "mat4");
    this.properties = {T:[0, 0, 0], R:[0, 0, 0], S:[1, 1, 1], R_in_degrees:!0};
    this._result = mat4.create();
    this._must_update = !0;
  }
  function g() {
    this.addInput("A", "number,vec3");
    this.addInput("B", "number,vec3");
    this.addOutput("=", "number,vec3");
    this.addProperty("OP", "+", "enum", {values:g.values});
    this._result = vec3.create();
  }
  function n() {
    this.addInput("in", "vec3");
    this.addInput("f", "number");
    this.addOutput("out", "vec3");
    this.properties = {f:1};
    this._data = new Float32Array(3);
  }
  function m() {
    this.addInput("in", "vec3");
    this.addOutput("out", "number");
  }
  function u() {
    this.addInput("in", "vec3");
    this.addOutput("out", "vec3");
    this._data = new Float32Array(3);
  }
  function l() {
    this.addInput("A", "vec3");
    this.addInput("B", "vec3");
    this.addInput("f", "vec3");
    this.addOutput("out", "vec3");
    this.properties = {f:0.5};
    this._data = new Float32Array(3);
  }
  function G() {
    this.addInput("A", "vec3");
    this.addInput("B", "vec3");
    this.addOutput("out", "number");
  }
  var A = y.LiteGraph;
  c.title = "mat4";
  c.temp_quat = new Float32Array([0, 0, 0, 1]);
  c.temp_mat4 = new Float32Array(16);
  c.temp_vec3 = new Float32Array(3);
  c.prototype.onPropertyChanged = function(c, k) {
    this._must_update = !0;
  };
  c.prototype.onExecute = function() {
    var e = this._result, k = c.temp_quat, g = c.temp_mat4, t = c.temp_vec3, a = this.getInputData(0), b = this.getInputData(1), d = this.getInputData(2);
    if (this._must_update || a || b || d) {
      a = a || this.properties.T, b = b || this.properties.R, d = d || this.properties.S, mat4.identity(e), mat4.translate(e, e, a), this.properties.R_in_degrees ? (t.set(b), vec3.scale(t, t, DEG2RAD), quat.fromEuler(k, t)) : quat.fromEuler(k, b), mat4.fromQuat(g, k), mat4.multiply(e, e, g), mat4.scale(e, e, d);
    }
    this.setOutputData(0, e);
  };
  A.registerNodeType("math3d/mat4", c);
  g.values = "+ - * / % ^ max min dot cross".split(" ");
  A.registerSearchboxExtra("math3d/operation", "CROSS()", {properties:{OP:"cross"}, title:"CROSS()"});
  A.registerSearchboxExtra("math3d/operation", "DOT()", {properties:{OP:"dot"}, title:"DOT()"});
  g.title = "Operation";
  g.desc = "Easy math 3D operators";
  g["@OP"] = {type:"enum", title:"operation", values:g.values};
  g.size = [100, 60];
  g.prototype.getTitle = function() {
    return "max" == this.properties.OP || "min" == this.properties.OP ? this.properties.OP + "(A,B)" : "A " + this.properties.OP + " B";
  };
  g.prototype.onExecute = function() {
    var c = this.getInputData(0), k = this.getInputData(1);
    if (null != c && null != k) {
      c.constructor === Number && (c = [c, c, c]);
      k.constructor === Number && (k = [k, k, k]);
      var e = this._result;
      switch(this.properties.OP) {
        case "+":
          e = vec3.add(e, c, k);
          break;
        case "-":
          e = vec3.sub(e, c, k);
          break;
        case "x":
        case "X":
        case "*":
          e = vec3.mul(e, c, k);
          break;
        case "/":
          e = vec3.div(e, c, k);
          break;
        case "%":
          e[0] = c[0] % k[0];
          e[1] = c[1] % k[1];
          e[2] = c[2] % k[2];
          break;
        case "^":
          e[0] = Math.pow(c[0], k[0]);
          e[1] = Math.pow(c[1], k[1]);
          e[2] = Math.pow(c[2], k[2]);
          break;
        case "max":
          e[0] = Math.max(c[0], k[0]);
          e[1] = Math.max(c[1], k[1]);
          e[2] = Math.max(c[2], k[2]);
          break;
        case "min":
          e[0] = Math.min(c[0], k[0]), e[1] = Math.min(c[1], k[1]), e[2] = Math.min(c[2], k[2]);
        case "dot":
          e = vec3.dot(c, k);
          break;
        case "cross":
          vec3.cross(e, c, k);
          break;
        default:
          console.warn("Unknown operation: " + this.properties.OP);
      }
      this.setOutputData(0, e);
    }
  };
  g.prototype.onDrawBackground = function(c) {
    this.flags.collapsed || (c.font = "40px Arial", c.fillStyle = "#666", c.textAlign = "center", c.fillText(this.properties.OP, 0.5 * this.size[0], 0.5 * (this.size[1] + A.NODE_TITLE_HEIGHT)), c.textAlign = "left");
  };
  A.registerNodeType("math3d/operation", g);
  n.title = "vec3_scale";
  n.desc = "scales the components of a vec3";
  n.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (null != c) {
      var k = this.getInputData(1);
      null == k && (k = this.properties.f);
      var e = this._data;
      e[0] = c[0] * k;
      e[1] = c[1] * k;
      e[2] = c[2] * k;
      this.setOutputData(0, e);
    }
  };
  A.registerNodeType("math3d/vec3-scale", n);
  m.title = "vec3_length";
  m.desc = "returns the module of a vector";
  m.prototype.onExecute = function() {
    var c = this.getInputData(0);
    null != c && this.setOutputData(0, Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]));
  };
  A.registerNodeType("math3d/vec3-length", m);
  u.title = "vec3_normalize";
  u.desc = "returns the vector normalized";
  u.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (null != c) {
      var k = Math.sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]), e = this._data;
      e[0] = c[0] / k;
      e[1] = c[1] / k;
      e[2] = c[2] / k;
      this.setOutputData(0, e);
    }
  };
  A.registerNodeType("math3d/vec3-normalize", u);
  l.title = "vec3_lerp";
  l.desc = "returns the interpolated vector";
  l.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (null != c) {
      var k = this.getInputData(1);
      if (null != k) {
        var e = this.getInputOrProperty("f"), g = this._data;
        g[0] = c[0] * (1 - e) + k[0] * e;
        g[1] = c[1] * (1 - e) + k[1] * e;
        g[2] = c[2] * (1 - e) + k[2] * e;
        this.setOutputData(0, g);
      }
    }
  };
  A.registerNodeType("math3d/vec3-lerp", l);
  G.title = "vec3_dot";
  G.desc = "returns the dot product";
  G.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (null != c) {
      var k = this.getInputData(1);
      null != k && this.setOutputData(0, c[0] * k[0] + c[1] * k[1] + c[2] * k[2]);
    }
  };
  A.registerNodeType("math3d/vec3-dot", G);
  if (y.glMatrix) {
    y = function() {
      this.addInput("vec3", "vec3");
      this.addOutput("remap", "vec3");
      this.addOutput("clamped", "vec3");
      this.properties = {clamp:!0, range_min:[-1, -1, 0], range_max:[1, 1, 0], target_min:[-1, -1, 0], target_max:[1, 1, 0]};
      this._value = vec3.create();
      this._clamped = vec3.create();
    };
    var D = function() {
      this.addInputs([["A", "quat"], ["B", "quat"], ["factor", "number"]]);
      this.addOutput("slerp", "quat");
      this.addProperty("factor", 0.5);
      this._value = quat.create();
    }, B = function() {
      this.addInputs([["A", "quat"], ["B", "quat"]]);
      this.addOutput("A*B", "quat");
      this._value = quat.create();
    }, F = function() {
      this.addInputs([["vec3", "vec3"], ["quat", "quat"]]);
      this.addOutput("result", "vec3");
      this.properties = {vec:[0, 0, 1]};
    }, e = function() {
      this.addInput(["quat", "quat"]);
      this.addOutput("euler", "vec3");
      this._value = vec3.create();
    }, z = function() {
      this.addInput("euler", "vec3");
      this.addOutput("quat", "quat");
      this.properties = {euler:[0, 0, 0], use_yaw_pitch_roll:!1};
      this._degs = vec3.create();
      this._value = quat.create();
    }, H = function() {
      this.addInputs([["degrees", "number"], ["axis", "vec3"]]);
      this.addOutput("quat", "quat");
      this.properties = {angle:90.0, axis:vec3.fromValues(0, 1, 0)};
      this._value = quat.create();
    }, x = function() {
      this.addOutput("quat", "quat");
      this.properties = {x:0, y:0, z:0, w:1, normalize:!1};
      this._value = quat.create();
    };
    x.title = "Quaternion";
    x.desc = "quaternion";
    x.prototype.onExecute = function() {
      this._value[0] = this.getInputOrProperty("x");
      this._value[1] = this.getInputOrProperty("y");
      this._value[2] = this.getInputOrProperty("z");
      this._value[3] = this.getInputOrProperty("w");
      this.properties.normalize && quat.normalize(this._value, this._value);
      this.setOutputData(0, this._value);
    };
    x.prototype.onGetInputs = function() {
      return [["x", "number"], ["y", "number"], ["z", "number"], ["w", "number"]];
    };
    A.registerNodeType("math3d/quaternion", x);
    H.title = "Rotation";
    H.desc = "quaternion rotation";
    H.prototype.onExecute = function() {
      var c = this.getInputData(0);
      null == c && (c = this.properties.angle);
      var k = this.getInputData(1);
      null == k && (k = this.properties.axis);
      c = quat.setAxisAngle(this._value, k, 0.0174532925 * c);
      this.setOutputData(0, c);
    };
    A.registerNodeType("math3d/rotation", H);
    z.title = "Euler->Quat";
    z.desc = "Converts euler angles (in degrees) to quaternion";
    z.prototype.onExecute = function() {
      var c = this.getInputData(0);
      null == c && (c = this.properties.euler);
      vec3.scale(this._degs, c, DEG2RAD);
      this.properties.use_yaw_pitch_roll && (this._degs = [this._degs[2], this._degs[0], this._degs[1]]);
      c = quat.fromEuler(this._value, this._degs);
      this.setOutputData(0, c);
    };
    A.registerNodeType("math3d/euler_to_quat", z);
    e.title = "Euler->Quat";
    e.desc = "Converts rotX,rotY,rotZ in degrees to quat";
    e.prototype.onExecute = function() {
      var c = this.getInputData(0);
      c && (quat.toEuler(this._value, c), vec3.scale(this._value, this._value, DEG2RAD), this.setOutputData(0, this._value));
    };
    A.registerNodeType("math3d/quat_to_euler", e);
    F.title = "Rot. Vec3";
    F.desc = "rotate a point";
    F.prototype.onExecute = function() {
      var c = this.getInputData(0);
      null == c && (c = this.properties.vec);
      var k = this.getInputData(1);
      null == k ? this.setOutputData(c) : this.setOutputData(0, vec3.transformQuat(vec3.create(), c, k));
    };
    A.registerNodeType("math3d/rotate_vec3", F);
    B.title = "Mult. Quat";
    B.desc = "rotate quaternion";
    B.prototype.onExecute = function() {
      var c = this.getInputData(0);
      if (null != c) {
        var k = this.getInputData(1);
        null != k && (c = quat.multiply(this._value, c, k), this.setOutputData(0, c));
      }
    };
    A.registerNodeType("math3d/mult-quat", B);
    D.title = "Quat Slerp";
    D.desc = "quaternion spherical interpolation";
    D.prototype.onExecute = function() {
      var c = this.getInputData(0);
      if (null != c) {
        var k = this.getInputData(1);
        if (null != k) {
          var e = this.properties.factor;
          null != this.getInputData(2) && (e = this.getInputData(2));
          c = quat.slerp(this._value, c, k, e);
          this.setOutputData(0, c);
        }
      }
    };
    A.registerNodeType("math3d/quat-slerp", D);
    y.title = "Remap Range";
    y.desc = "remap a 3D range";
    y.prototype.onExecute = function() {
      var c = this.getInputData(0);
      c && this._value.set(c);
      c = this.properties.range_min;
      for (var k = this.properties.range_max, e = this.properties.target_min, g = this.properties.target_max, a = 0; 3 > a; ++a) {
        var b = k[a] - c[a];
        this._clamped[a] = Math.clamp(this._value[a], c[a], k[a]);
        0 == b ? this._value[a] = 0.5 * (e[a] + g[a]) : (b = (this._value[a] - c[a]) / b, this.properties.clamp && (b = Math.clamp(b, 0, 1)), this._value[a] = e[a] + b * (g[a] - e[a]));
      }
      this.setOutputData(0, this._value);
      this.setOutputData(1, this._clamped);
    };
    A.registerNodeType("math3d/remap_range", y);
  } else {
    console.warn("No glmatrix found, some Math3D nodes may not work");
  }
})(this);
(function(y) {
  function c() {
    this.addInput("sel", "number");
    this.addInput("A");
    this.addInput("B");
    this.addInput("C");
    this.addInput("D");
    this.addOutput("out");
    this.selected = 0;
  }
  function g() {
    this.properties = {sequence:"A,B,C"};
    this.addInput("index", "number");
    this.addInput("seq");
    this.addOutput("out");
    this.index = 0;
    this.values = this.properties.sequence.split(",");
  }
  var n = y.LiteGraph;
  c.title = "Selector";
  c.desc = "selects an output";
  c.prototype.onDrawBackground = function(c) {
    if (!this.flags.collapsed) {
      c.fillStyle = "#AFB";
      var g = (this.selected + 1) * n.NODE_SLOT_HEIGHT + 6;
      c.beginPath();
      c.moveTo(50, g);
      c.lineTo(50, g + n.NODE_SLOT_HEIGHT);
      c.lineTo(34, g + 0.5 * n.NODE_SLOT_HEIGHT);
      c.fill();
    }
  };
  c.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (null == c || c.constructor !== Number) {
      c = 0;
    }
    this.selected = c = Math.round(c) % (this.inputs.length - 1);
    c = this.getInputData(c + 1);
    void 0 !== c && this.setOutputData(0, c);
  };
  c.prototype.onGetInputs = function() {
    return [["E", 0], ["F", 0], ["G", 0], ["H", 0]];
  };
  n.registerNodeType("logic/selector", c);
  g.title = "Sequence";
  g.desc = "select one element from a sequence from a string";
  g.prototype.onPropertyChanged = function(c, g) {
    "sequence" == c && (this.values = g.split(","));
  };
  g.prototype.onExecute = function() {
    var c = this.getInputData(1);
    c && c != this.current_sequence && (this.values = c.split(","), this.current_sequence = c);
    c = this.getInputData(0);
    null == c && (c = 0);
    this.index = c = Math.round(c) % this.values.length;
    this.setOutputData(0, this.values[c]);
  };
  n.registerNodeType("logic/sequence", g);
})(this);
(function(y) {
  function c() {
    this.addOutput("tex", "Texture");
    this.addOutput("name", "string");
    this.properties = {name:"", filter:!0};
    this.size = [c.image_preview_size, c.image_preview_size];
  }
  function g() {
    this.addInput("Texture", "Texture");
    this.properties = {flipY:!1};
    this.size = [c.image_preview_size, c.image_preview_size];
  }
  function n() {
    this.addInput("Texture", "Texture");
    this.addOutput("tex", "Texture");
    this.addOutput("name", "string");
    this.properties = {name:"", generate_mipmaps:!1};
  }
  function m() {
    this.addInput("Texture", "Texture");
    this.addInput("TextureB", "Texture");
    this.addInput("value", "number");
    this.addOutput("Texture", "Texture");
    this.help = "<p>pixelcode must be vec3, uvcode must be vec2, is optional</p>\t\t<p><strong>uv:</strong> tex. coords</p><p><strong>color:</strong> texture <strong>colorB:</strong> textureB</p><p><strong>time:</strong> scene time <strong>value:</strong> input value</p><p>For multiline you must type: result = ...</p>";
    this.properties = {value:1, pixelcode:"color + colorB * value", uvcode:"", precision:c.DEFAULT};
    this.has_error = !1;
  }
  function u() {
    this.addOutput("out", "Texture");
    this.properties = {code:"", u_value:1, u_color:[1, 1, 1, 1], width:512, height:512, precision:c.DEFAULT};
    this.properties.code = u.pixel_shader;
    this._uniforms = {u_value:1, u_color:vec4.create(), in_texture:0, texSize:vec4.create(), time:0};
  }
  function l() {
    this.addInput("in", "Texture");
    this.addInput("scale", "vec2");
    this.addInput("offset", "vec2");
    this.addOutput("out", "Texture");
    this.properties = {offset:vec2.fromValues(0, 0), scale:vec2.fromValues(1, 1), precision:c.DEFAULT};
  }
  function G() {
    this.addInput("in", "Texture");
    this.addInput("warp", "Texture");
    this.addInput("factor", "number");
    this.addOutput("out", "Texture");
    this.properties = {factor:0.01, scale:[1, 1], offset:[0, 0], precision:c.DEFAULT};
    this._uniforms = {u_texture:0, u_textureB:1, u_factor:1, u_scale:vec2.create(), u_offset:vec2.create()};
  }
  function A() {
    this.addInput("Texture", "Texture");
    this.properties = {additive:!1, antialiasing:!1, filter:!0, disable_alpha:!1, gamma:1.0, viewport:[0, 0, 1, 1]};
    this.size[0] = 130;
  }
  function D() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {size:0, generate_mipmaps:!1, precision:c.DEFAULT};
  }
  function B() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {iterations:1, generate_mipmaps:!1, precision:c.DEFAULT};
  }
  function F() {
    this.addInput("Texture", "Texture");
    this.addOutput("", "Texture");
    this.properties = {size:[512, 512], generate_mipmaps:!1, precision:c.DEFAULT};
  }
  function e() {
    this.addInput("Texture", "Texture");
    this.addOutput("tex", "Texture");
    this.addOutput("avg", "vec4");
    this.addOutput("lum", "number");
    this.properties = {use_previous_frame:!0, high_quality:!1};
    this._uniforms = {u_texture:0, u_mipmap_offset:0};
    this._luminance = new Float32Array(4);
  }
  function z() {
    this.addInput("in", "Texture");
    this.addInput("factor", "Number");
    this.addOutput("out", "Texture");
    this.properties = {factor:0.5};
    this._uniforms = {u_texture:0, u_textureB:1, u_factor:this.properties.factor};
  }
  function H() {
    this.addInput("in", "Texture");
    this.addOutput("avg", "Texture");
    this.addOutput("array", "Texture");
    this.properties = {samples:64, frames_interval:1};
    this._uniforms = {u_texture:0, u_textureB:1, u_samples:this.properties.samples, u_isamples:1 / this.properties.samples};
    this.frame = 0;
  }
  function x() {
    this.addInput("Image", "image");
    this.addOutput("", "Texture");
    this.properties = {};
  }
  function K() {
    this.addInput("Texture", "Texture");
    this.addInput("LUT", "Texture");
    this.addInput("Intensity", "number");
    this.addOutput("", "Texture");
    this.properties = {enabled:!0, intensity:1, precision:c.DEFAULT, texture:null};
    K._shader || (K._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, K.pixel_shader));
  }
  function k() {
    this.addInput("Texture", "Texture");
    this.addInput("Atlas", "Texture");
    this.addOutput("", "Texture");
    this.properties = {enabled:!0, num_row_symbols:4, symbol_size:16, brightness:1, colorize:!1, filter:!1, invert:!1, precision:c.DEFAULT, generate_mipmaps:!1, texture:null};
    k._shader || (k._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, k.pixel_shader));
    this._uniforms = {u_texture:0, u_textureB:1, u_row_simbols:4, u_simbol_size:16, u_res:vec2.create()};
  }
  function q() {
    this.addInput("Texture", "Texture");
    this.addOutput("R", "Texture");
    this.addOutput("G", "Texture");
    this.addOutput("B", "Texture");
    this.addOutput("A", "Texture");
    q._shader || (q._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, q.pixel_shader));
  }
  function t() {
    this.addInput("R", "Texture");
    this.addInput("G", "Texture");
    this.addInput("B", "Texture");
    this.addInput("A", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {precision:c.DEFAULT, R:1, G:1, B:1, A:1};
    this._color = vec4.create();
    this._uniforms = {u_textureR:0, u_textureG:1, u_textureB:2, u_textureA:3, u_color:this._color};
  }
  function a() {
    this.addOutput("Texture", "Texture");
    this._tex_color = vec4.create();
    this.properties = {color:vec4.create(), precision:c.DEFAULT};
  }
  function b() {
    this.addInput("A", "color");
    this.addInput("B", "color");
    this.addOutput("Texture", "Texture");
    this.properties = {angle:0, scale:1, A:[0, 0, 0], B:[1, 1, 1], texture_size:32};
    b._shader || (b._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, b.pixel_shader));
    this._uniforms = {u_angle:0, u_colorA:vec3.create(), u_colorB:vec3.create()};
  }
  function d() {
    this.addInput("A", "Texture");
    this.addInput("B", "Texture");
    this.addInput("Mixer", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {factor:0.5, size_from_biggest:!0, invert:!1, precision:c.DEFAULT};
    this._uniforms = {u_textureA:0, u_textureB:1, u_textureMix:2, u_mix:vec4.create()};
  }
  function f() {
    this.addInput("Tex.", "Texture");
    this.addOutput("Edges", "Texture");
    this.properties = {invert:!0, threshold:!1, factor:1, precision:c.DEFAULT};
    f._shader || (f._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, f.pixel_shader));
  }
  function h() {
    this.addInput("Texture", "Texture");
    this.addInput("Distance", "number");
    this.addInput("Range", "number");
    this.addOutput("Texture", "Texture");
    this.properties = {distance:100, range:50, only_depth:!1, high_precision:!1};
    this._uniforms = {u_texture:0, u_distance:100, u_range:50, u_camera_planes:null};
  }
  function w() {
    this.addInput("Texture", "Texture");
    this.addOutput("Texture", "Texture");
    this.properties = {precision:c.DEFAULT, invert:!1};
    this._uniforms = {u_texture:0, u_camera_planes:null, u_ires:vec2.create()};
  }
  function v() {
    this.addInput("Texture", "Texture");
    this.addInput("Iterations", "number");
    this.addInput("Intensity", "number");
    this.addOutput("Blurred", "Texture");
    this.properties = {intensity:1, iterations:1, preserve_aspect:!1, scale:[1, 1], precision:c.DEFAULT};
  }
  function r() {
    this.intensity = 0.5;
    this.persistence = 0.6;
    this.iterations = 8;
    this.threshold = 0.8;
    this.scale = 1;
    this.dirt_texture = null;
    this.dirt_factor = 0.5;
    this._textures = [];
    this._uniforms = {u_intensity:1, u_texture:0, u_glow_texture:1, u_threshold:0, u_texel_size:vec2.create()};
  }
  function N() {
    this.addInput("in", "Texture");
    this.addInput("dirt", "Texture");
    this.addOutput("out", "Texture");
    this.addOutput("glow", "Texture");
    this.properties = {enabled:!0, intensity:1, persistence:0.99, iterations:16, threshold:0, scale:1, dirt_factor:0.5, precision:c.DEFAULT};
    this.fx = new r;
  }
  function O() {
    this.addInput("Texture", "Texture");
    this.addOutput("Filtered", "Texture");
    this.properties = {intensity:1, radius:5};
  }
  function M() {
    this.addInput("Texture", "Texture");
    this.addOutput("Filtered", "Texture");
    this.properties = {sigma:1.4, k:1.6, p:21.7, epsilon:79, phi:0.017};
  }
  function C() {
    this.addOutput("Webcam", "Texture");
    this.properties = {texture_name:"", facingMode:"user"};
    this.boxcolor = "black";
    this.version = 0;
  }
  function J() {
    this.addInput("in", "Texture");
    this.addInput("f", "number");
    this.addOutput("out", "Texture");
    this.properties = {enabled:!0, factor:1, precision:c.LOW};
    this._uniforms = {u_texture:0, u_factor:1};
  }
  function E() {
    this.addInput("in", "");
    this.properties = {precision:c.LOW, width:0, height:0, channels:1};
    this.addOutput("out", "Texture");
  }
  function I() {
    this.addInput("in", "Texture");
    this.addOutput("out", "Texture");
    this.properties = {precision:c.LOW, split_channels:!1};
    this._values = new Uint8Array(1024);
    this._values.fill(255);
    this._curve_texture = null;
    this._uniforms = {u_texture:0, u_curve:1, u_range:1.0};
    this._must_update = !0;
    this._points = {RGB:[[0, 0], [1, 1]], R:[[0, 0], [1, 1]], G:[[0, 0], [1, 1]], B:[[0, 0], [1, 1]]};
    this.curve_editor = null;
    this.addWidget("toggle", "Split Channels", !1, "split_channels");
    this.addWidget("combo", "Channel", "RGB", {values:["RGB", "R", "G", "B"]});
    this.curve_offset = 68;
    this.size = [240, 160];
  }
  function P() {
    this.addInput("in", "Texture");
    this.addInput("exp", "number");
    this.addOutput("out", "Texture");
    this.properties = {exposition:1, precision:c.LOW};
    this._uniforms = {u_texture:0, u_exposition:1};
  }
  function Q() {
    this.addInput("in", "Texture");
    this.addInput("avg", "number,Texture");
    this.addOutput("out", "Texture");
    this.properties = {enabled:!0, scale:1, gamma:1, average_lum:1, lum_white:1, precision:c.LOW};
    this._uniforms = {u_texture:0, u_lumwhite2:1, u_igamma:1, u_scale:1, u_average_lum:1};
  }
  function S() {
    this.addOutput("out", "Texture");
    this.properties = {width:512, height:512, seed:0, persistence:0.1, octaves:8, scale:1, offset:[0, 0], amplitude:1, precision:c.DEFAULT};
    this._key = 0;
    this._texture = null;
    this._uniforms = {u_persistence:0.1, u_seed:0, u_offset:vec2.create(), u_scale:1, u_viewport:vec2.create()};
  }
  function R() {
    this.addInput("v");
    this.addOutput("out", "Texture");
    this.properties = {code:R.default_code, width:512, height:512, clear:!0, precision:c.DEFAULT, use_html_canvas:!1};
    this._temp_texture = this._func = null;
    this.compileCode();
  }
  function T() {
    this.addInput("in", "Texture");
    this.addOutput("out", "Texture");
    this.properties = {key_color:vec3.fromValues(0, 1, 0), threshold:0.8, slope:0.2, precision:c.DEFAULT};
  }
  function U() {
    this.addInput("in", "texture");
    this.addInput("yaw", "number");
    this.addOutput("out", "texture");
    this.properties = {yaw:0};
  }
  var L = y.LiteGraph, Z = y.LGraphCanvas;
  y.LGraphTexture = null;
  "undefined" != typeof GL && (Z.link_type_colors.Texture = "#987", y.LGraphTexture = c, c.title = "Texture", c.desc = "Texture", c.widgets_info = {name:{widget:"texture"}, filter:{widget:"checkbox"}}, c.loadTextureCallback = null, c.image_preview_size = 256, c.UNDEFINED = 0, c.PASS_THROUGH = 1, c.COPY = 2, c.LOW = 3, c.HIGH = 4, c.REUSE = 5, c.DEFAULT = 2, c.MODE_VALUES = {undefined:c.UNDEFINED, "pass through":c.PASS_THROUGH, copy:c.COPY, low:c.LOW, high:c.HIGH, reuse:c.REUSE, default:c.DEFAULT}, 
  c.getTexturesContainer = function() {
    return gl.textures;
  }, c.loadTexture = function(a, b) {
    b = b || {};
    var d = a;
    "http://" == d.substr(0, 7) && L.proxy && (d = L.proxy + d.substr(7));
    return c.getTexturesContainer()[a] = GL.Texture.fromURL(d, b);
  }, c.getTexture = function(a) {
    var b = this.getTexturesContainer();
    if (!b) {
      throw "Cannot load texture, container of textures not found";
    }
    b = b[a];
    return !b && a && ":" != a[0] ? this.loadTexture(a) : b;
  }, c.getTargetTexture = function(a, b, d) {
    if (!a) {
      throw "LGraphTexture.getTargetTexture expects a reference texture";
    }
    switch(d) {
      case c.LOW:
        d = gl.UNSIGNED_BYTE;
        break;
      case c.HIGH:
        d = gl.HIGH_PRECISION_FORMAT;
        break;
      case c.REUSE:
        return a;
      default:
        d = a ? a.type : gl.UNSIGNED_BYTE;
    }
    b && b.width == a.width && b.height == a.height && b.type == d && b.format == a.format || (b = new GL.Texture(a.width, a.height, {type:d, format:a.format, filter:gl.LINEAR}));
    return b;
  }, c.getTextureType = function(a, b) {
    b = b ? b.type : gl.UNSIGNED_BYTE;
    switch(a) {
      case c.HIGH:
        b = gl.HIGH_PRECISION_FORMAT;
        break;
      case c.LOW:
        b = gl.UNSIGNED_BYTE;
    }
    return b;
  }, c.getWhiteTexture = function() {
    return this._white_texture ? this._white_texture : this._white_texture = GL.Texture.fromMemory(1, 1, [255, 255, 255, 255], {format:gl.RGBA, wrap:gl.REPEAT, filter:gl.NEAREST});
  }, c.getNoiseTexture = function() {
    if (this._noise_texture) {
      return this._noise_texture;
    }
    for (var a = new Uint8Array(1048576), b = 0; 1048576 > b; ++b) {
      a[b] = 255 * Math.random();
    }
    return this._noise_texture = a = GL.Texture.fromMemory(512, 512, a, {format:gl.RGBA, wrap:gl.REPEAT, filter:gl.NEAREST});
  }, c.prototype.onDropFile = function(a, b, d) {
    a ? ("string" == typeof a ? a = GL.Texture.fromURL(a) : -1 != b.toLowerCase().indexOf(".dds") ? a = GL.Texture.fromDDSInMemory(a) : (a = new Blob([d]), a = URL.createObjectURL(a), a = GL.Texture.fromURL(a)), this._drop_texture = a, this.properties.name = b) : (this._drop_texture = null, this.properties.name = "");
  }, c.prototype.getExtraMenuOptions = function(a) {
    var b = this;
    if (this._drop_texture) {
      return [{content:"Clear", callback:function() {
        b._drop_texture = null;
        b.properties.name = "";
      }}];
    }
  }, c.prototype.onExecute = function() {
    var a = null;
    this.isOutputConnected(1) && (a = this.getInputData(0));
    !a && this._drop_texture && (a = this._drop_texture);
    !a && this.properties.name && (a = c.getTexture(this.properties.name));
    if (a) {
      this._last_tex = a;
      !1 === this.properties.filter ? a.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST) : a.setParameter(gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      this.setOutputData(0, a);
      this.setOutputData(1, a.fullpath || a.filename);
      for (var b = 2; b < this.outputs.length; b++) {
        var d = this.outputs[b];
        if (d) {
          var f = null;
          "width" == d.name ? f = a.width : "height" == d.name ? f = a.height : "aspect" == d.name && (f = a.width / a.height);
          this.setOutputData(b, f);
        }
      }
    } else {
      this.setOutputData(0, null), this.setOutputData(1, "");
    }
  }, c.prototype.onResourceRenamed = function(a, b) {
    this.properties.name == a && (this.properties.name = b);
  }, c.prototype.onDrawBackground = function(a) {
    if (!(this.flags.collapsed || 20 >= this.size[1])) {
      if (this._drop_texture && a.webgl) {
        a.drawImage(this._drop_texture, 0, 0, this.size[0], this.size[1]);
      } else {
        if (this._last_preview_tex != this._last_tex) {
          if (a.webgl) {
            this._canvas = this._last_tex;
          } else {
            var b = c.generateLowResTexturePreview(this._last_tex);
            if (!b) {
              return;
            }
            this._last_preview_tex = this._last_tex;
            this._canvas = cloneCanvas(b);
          }
        }
        this._canvas && (a.save(), a.webgl || (a.translate(0, this.size[1]), a.scale(1, -1)), a.drawImage(this._canvas, 0, 0, this.size[0], this.size[1]), a.restore());
      }
    }
  }, c.generateLowResTexturePreview = function(a) {
    if (!a) {
      return null;
    }
    var b = c.image_preview_size, d = a;
    if (a.format == gl.DEPTH_COMPONENT) {
      return null;
    }
    if (a.width > b || a.height > b) {
      d = this._preview_temp_tex, this._preview_temp_tex || (this._preview_temp_tex = d = new GL.Texture(b, b, {minFilter:gl.NEAREST})), a.copyTo(d);
    }
    a = this._preview_canvas;
    a || (this._preview_canvas = a = createCanvas(b, b));
    d && d.toCanvas(a);
    return a;
  }, c.prototype.getResources = function(a) {
    this.properties.name && (a[this.properties.name] = GL.Texture);
    return a;
  }, c.prototype.onGetInputs = function() {
    return [["in", "Texture"]];
  }, c.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["aspect", "number"]];
  }, c.replaceCode = function(a, b) {
    return a.replace(/\{\{[a-zA-Z0-9_]*\}\}/g, function(a) {
      a = a.replace(/[\{\}]/g, "");
      return b[a] || "";
    });
  }, L.registerNodeType("texture/texture", c), g.title = "Preview", g.desc = "Show a texture in the graph canvas", g.allow_preview = !1, g.prototype.onDrawBackground = function(a) {
    if (!this.flags.collapsed && (a.webgl || g.allow_preview)) {
      var b = this.getInputData(0);
      b && (b = !b.handle && a.webgl ? b : c.generateLowResTexturePreview(b), a.save(), this.properties.flipY && (a.translate(0, this.size[1]), a.scale(1, -1)), a.drawImage(b, 0, 0, this.size[0], this.size[1]), a.restore());
    }
  }, L.registerNodeType("texture/preview", g), n.title = "Save", n.desc = "Save a texture in the repository", n.prototype.getPreviewTexture = function() {
    return this._texture;
  }, n.prototype.onExecute = function() {
    var a = this.getInputData(0);
    a && (this.properties.generate_mipmaps && (a.bind(0), a.setParameter(gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR), gl.generateMipmap(a.texture_type), a.unbind(0)), this.properties.name && (c.storeTexture ? c.storeTexture(this.properties.name, a) : c.getTexturesContainer()[this.properties.name] = a), this._texture = a, this.setOutputData(0, a), this.setOutputData(1, this.properties.name));
  }, L.registerNodeType("texture/save", n), m.widgets_info = {uvcode:{widget:"code"}, pixelcode:{widget:"code"}, precision:{widget:"combo", values:c.MODE_VALUES}}, m.title = "Operation", m.desc = "Texture shader operation", m.presets = {}, m.prototype.getExtraMenuOptions = function(a) {
    var b = this;
    return [{content:b.properties.show ? "Hide Texture" : "Show Texture", callback:function() {
      b.properties.show = !b.properties.show;
    }}];
  }, m.prototype.onPropertyChanged = function() {
    this.has_error = !1;
  }, m.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._tex || this._tex.gl != a || (a.save(), a.drawImage(this._tex, 0, 0, this.size[0], this.size[1]), a.restore());
  }, m.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === c.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        var b = this.getInputData(1);
        if (this.properties.uvcode || this.properties.pixelcode) {
          var d = 512, f = 512;
          a ? (d = a.width, f = a.height) : b && (d = b.width, f = b.height);
          b || (b = GL.Texture.getWhiteTexture());
          var h = c.getTextureType(this.properties.precision, a);
          this._tex = a || this._tex ? c.getTargetTexture(a || this._tex, this._tex, this.properties.precision) : new GL.Texture(d, f, {type:h, format:gl.RGBA, filter:gl.LINEAR});
          h = "";
          this.properties.uvcode && (h = "uv = " + this.properties.uvcode, -1 != this.properties.uvcode.indexOf(";") && (h = this.properties.uvcode));
          var k = "";
          this.properties.pixelcode && (k = "result = " + this.properties.pixelcode, -1 != this.properties.pixelcode.indexOf(";") && (k = this.properties.pixelcode));
          var e = this._shader;
          if (!(this.has_error || e && this._shader_code == h + "|" + k)) {
            var g = c.replaceCode(m.pixel_shader, {UV_CODE:h, PIXEL_CODE:k});
            try {
              e = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, g), this.boxcolor = "#00FF00";
            } catch (aa) {
              GL.Shader.dumpErrorToConsole(aa, Shader.SCREEN_VERTEX_SHADER, g);
              this.boxcolor = "#FF0000";
              this.has_error = !0;
              return;
            }
            this._shader = e;
            this._shader_code = h + "|" + k;
          }
          if (this._shader) {
            var t = this.getInputData(2);
            null != t ? this.properties.value = t : t = parseFloat(this.properties.value);
            var q = this.graph.getTime();
            this._tex.drawTo(function() {
              gl.disable(gl.DEPTH_TEST);
              gl.disable(gl.CULL_FACE);
              gl.disable(gl.BLEND);
              a && a.bind(0);
              b && b.bind(1);
              var c = Mesh.getScreenQuad();
              e.uniforms({u_texture:0, u_textureB:1, value:t, texSize:[d, f, 1 / d, 1 / f], time:q}).draw(c);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    }
  }, m.pixel_shader = "precision highp float;\n\t\t\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tvarying vec2 v_coord;\n\t\tuniform vec4 texSize;\n\t\tuniform float time;\n\t\tuniform float value;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = v_coord;\n\t\t\t{{UV_CODE}};\n\t\t\tvec4 color4 = texture2D(u_texture, uv);\n\t\t\tvec3 color = color4.rgb;\n\t\t\tvec4 color4B = texture2D(u_textureB, uv);\n\t\t\tvec3 colorB = color4B.rgb;\n\t\t\tvec3 result = color;\n\t\t\tfloat alpha = 1.0;\n\t\t\t{{PIXEL_CODE}};\n\t\t\tgl_FragColor = vec4(result, alpha);\n\t\t}\n\t\t", 
  m.registerPreset = function(a, b) {
    m.presets[a] = b;
  }, m.registerPreset("", ""), m.registerPreset("bypass", "color"), m.registerPreset("add", "color + colorB * value"), m.registerPreset("substract", "(color - colorB) * value"), m.registerPreset("mate", "mix( color, colorB, color4B.a * value)"), m.registerPreset("invert", "vec3(1.0) - color"), m.registerPreset("multiply", "color * colorB * value"), m.registerPreset("divide", "(color / colorB) / value"), m.registerPreset("difference", "abs(color - colorB) * value"), m.registerPreset("max", "max(color, colorB) * value"), 
  m.registerPreset("min", "min(color, colorB) * value"), m.registerPreset("displace", "texture2D(u_texture, uv + (colorB.xy - vec2(0.5)) * value).xyz"), m.registerPreset("grayscale", "vec3(color.x + color.y + color.z) * value / 3.0"), m.registerPreset("saturation", "mix( vec3(color.x + color.y + color.z) / 3.0, color, value )"), m.registerPreset("normalmap", "\n\t\tfloat z0 = texture2D(u_texture, uv + vec2(-texSize.z, -texSize.w) ).x;\n\t\tfloat z1 = texture2D(u_texture, uv + vec2(0.0, -texSize.w) ).x;\n\t\tfloat z2 = texture2D(u_texture, uv + vec2(texSize.z, -texSize.w) ).x;\n\t\tfloat z3 = texture2D(u_texture, uv + vec2(-texSize.z, 0.0) ).x;\n\t\tfloat z4 = color.x;\n\t\tfloat z5 = texture2D(u_texture, uv + vec2(texSize.z, 0.0) ).x;\n\t\tfloat z6 = texture2D(u_texture, uv + vec2(-texSize.z, texSize.w) ).x;\n\t\tfloat z7 = texture2D(u_texture, uv + vec2(0.0, texSize.w) ).x;\n\t\tfloat z8 = texture2D(u_texture, uv + vec2(texSize.z, texSize.w) ).x;\n\t\tvec3 normal = vec3( z2 + 2.0*z4 + z7 - z0 - 2.0*z3 - z5, z5 + 2.0*z6 + z7 -z0 - 2.0*z1 - z2, 1.0 );\n\t\tnormal.xy *= value;\n\t\tresult.xyz = normalize(normal) * 0.5 + vec3(0.5);\n\t"), 
  m.registerPreset("threshold", "vec3(color.x > colorB.x * value ? 1.0 : 0.0,color.y > colorB.y * value ? 1.0 : 0.0,color.z > colorB.z * value ? 1.0 : 0.0)"), m.prototype.onInspect = function(a) {
    var b = this;
    a.addCombo("Presets", "", {values:Object.keys(m.presets), callback:function(d) {
      var c = m.presets[d];
      c && (b.setProperty("pixelcode", c), b.title = d, a.refresh());
    }});
  }, L.registerNodeType("texture/operation", m), u.title = "Shader", u.desc = "Texture shader", u.widgets_info = {code:{type:"code", lang:"glsl"}, precision:{widget:"combo", values:c.MODE_VALUES}}, u.prototype.onPropertyChanged = function(a, b) {
    if ("code" == a && (a = this.getShader())) {
      b = a.uniformInfo;
      if (this.inputs) {
        for (var d = {}, c = 0; c < this.inputs.length; ++c) {
          var f = this.getInputInfo(c);
          f && (b[f.name] && !d[f.name] ? d[f.name] = !0 : (this.removeInput(c), c--));
        }
      }
      for (c in b) {
        if (f = a.uniformInfo[c], null !== f.loc && "time" != c) {
          if (this._shader.samplers[c]) {
            b = "texture";
          } else {
            switch(f.size) {
              case 1:
                b = "number";
                break;
              case 2:
                b = "vec2";
                break;
              case 3:
                b = "vec3";
                break;
              case 4:
                b = "vec4";
                break;
              case 9:
                b = "mat3";
                break;
              case 16:
                b = "mat4";
                break;
              default:
                continue;
            }
          }
          d = this.findInputSlot(c);
          if (-1 != d && (f = this.getInputInfo(d))) {
            if (f.type == b) {
              continue;
            }
            this.removeInput(d, b);
          }
          this.addInput(c, b);
        }
      }
    }
  }, u.prototype.getShader = function() {
    if (this._shader && this._shader_code == this.properties.code) {
      return this._shader;
    }
    this._shader_code = this.properties.code;
    this._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, this.properties.code), this.boxcolor = "green";
    return this._shader;
  }, u.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getShader();
      if (a) {
        var b = 0, d = null;
        if (this.inputs) {
          for (var f = 0; f < this.inputs.length; ++f) {
            var h = this.getInputInfo(f), k = this.getInputData(f);
            null != k && (k.constructor === GL.Texture && (k.bind(b), d || (d = k), k = b, b++), a.setUniform(h.name, k));
          }
        }
        var e = this._uniforms;
        b = c.getTextureType(this.properties.precision, d);
        f = this.properties.width | 0;
        h = this.properties.height | 0;
        0 == f && (f = d ? d.width : gl.canvas.width);
        0 == h && (h = d ? d.height : gl.canvas.height);
        e.texSize[0] = f;
        e.texSize[1] = h;
        e.texSize[2] = 1 / f;
        e.texSize[3] = 1 / h;
        e.time = this.graph.getTime();
        e.u_value = this.properties.u_value;
        e.u_color.set(this.properties.u_color);
        this._tex && this._tex.type == b && this._tex.width == f && this._tex.height == h || (this._tex = new GL.Texture(f, h, {type:b, format:gl.RGBA, filter:gl.LINEAR}));
        this._tex.drawTo(function() {
          a.uniforms(e).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, this._tex);
      }
    }
  }, u.pixel_shader = "precision highp float;\n\nvarying vec2 v_coord;\nuniform float time; //time in seconds\nuniform vec4 texSize; //tex resolution\nuniform float u_value;\nuniform vec4 u_color;\n\nvoid main() {\n\tvec2 uv = v_coord;\n\tvec3 color = vec3(0.0);\n\t//your code here\n\tcolor.xy=uv;\n\n\tgl_FragColor = vec4(color, 1.0);\n}\n", L.registerNodeType("texture/shader", u), l.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, l.title = "Scale/Offset", l.desc = "Applies an scaling and offseting", 
  l.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (this.isOutputConnected(0) && a) {
      if (this.properties.precision === c.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        var b = a.width, d = a.height, f = this.precision === c.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT;
        this.precision === c.DEFAULT && (f = a.type);
        this._tex && this._tex.width == b && this._tex.height == d && this._tex.type == f || (this._tex = new GL.Texture(b, d, {type:f, format:gl.RGBA, filter:gl.LINEAR}));
        var h = this._shader;
        h || (h = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, l.pixel_shader));
        var k = this.getInputData(1);
        k ? (this.properties.scale[0] = k[0], this.properties.scale[1] = k[1]) : k = this.properties.scale;
        var e = this.getInputData(2);
        e ? (this.properties.offset[0] = e[0], this.properties.offset[1] = e[1]) : e = this.properties.offset;
        this._tex.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.BLEND);
          a.bind(0);
          var b = Mesh.getScreenQuad();
          h.uniforms({u_texture:0, u_scale:k, u_offset:e}).draw(b);
        });
        this.setOutputData(0, this._tex);
      }
    }
  }, l.pixel_shader = "precision highp float;\n\t\t\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tvarying vec2 v_coord;\n\t\tuniform vec2 u_scale;\n\t\tuniform vec2 u_offset;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = v_coord;\n\t\t\tuv = uv / u_scale - u_offset;\n\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\t\t}\n\t\t", L.registerNodeType("texture/scaleOffset", l), G.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, G.title = "Warp", G.desc = "Texture warp operation", 
  G.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === c.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        var b = this.getInputData(1), d = 512, f = 512;
        a ? (d = a.width, f = a.height) : b && (d = b.width, f = b.height);
        this._tex = a || this._tex ? c.getTargetTexture(a || this._tex, this._tex, this.properties.precision) : new GL.Texture(d, f, {type:this.precision === c.LOW ? gl.UNSIGNED_BYTE : gl.HIGH_PRECISION_FORMAT, format:gl.RGBA, filter:gl.LINEAR});
        var h = this._shader;
        h || (h = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, G.pixel_shader));
        d = this.getInputData(2);
        null != d ? this.properties.factor = d : d = parseFloat(this.properties.factor);
        var k = this._uniforms;
        k.u_factor = d;
        k.u_scale.set(this.properties.scale);
        k.u_offset.set(this.properties.offset);
        this._tex.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.CULL_FACE);
          gl.disable(gl.BLEND);
          a && a.bind(0);
          b && b.bind(1);
          var d = Mesh.getScreenQuad();
          h.uniforms(k).draw(d);
        });
        this.setOutputData(0, this._tex);
      }
    }
  }, G.pixel_shader = "precision highp float;\n\t\t\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tvarying vec2 v_coord;\n\t\tuniform float u_factor;\n\t\tuniform vec2 u_scale;\n\t\tuniform vec2 u_offset;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = v_coord;\n\t\t\tuv += ( texture2D(u_textureB, uv).rg - vec2(0.5)) * u_factor * u_scale + u_offset;\n\t\t\tgl_FragColor = texture2D(u_texture, uv);\n\t\t}\n\t\t", L.registerNodeType("texture/warp", G), A.title = "to Viewport", A.desc = 
  "Texture to viewport", A._prev_viewport = new Float32Array(4), A.prototype.onDrawBackground = function(a) {
    if (!(this.flags.collapsed || 40 >= this.size[1])) {
      var b = this.getInputData(0);
      b && a.drawImage(a == gl ? b : gl.canvas, 10, 30, this.size[0] - 20, this.size[1] - 40);
    }
  }, A.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      this.properties.disable_alpha ? gl.disable(gl.BLEND) : (gl.enable(gl.BLEND), this.properties.additive ? gl.blendFunc(gl.SRC_ALPHA, gl.ONE) : gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA));
      gl.disable(gl.DEPTH_TEST);
      var b = this.properties.gamma || 1.0;
      this.isInputConnected(1) && (b = this.getInputData(1));
      a.setParameter(gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST);
      var d = A._prev_viewport;
      d.set(gl.viewport_data);
      var c = this.properties.viewport;
      gl.viewport(d[0] + d[2] * c[0], d[1] + d[3] * c[1], d[2] * c[2], d[3] * c[3]);
      gl.getViewport();
      this.properties.antialiasing ? (A._shader || (A._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, A.aa_pixel_shader)), c = Mesh.getScreenQuad(), a.bind(0), A._shader.uniforms({u_texture:0, uViewportSize:[a.width, a.height], u_igamma:1 / b, inverseVP:[1 / a.width, 1 / a.height]}).draw(c)) : 1.0 != b ? (A._gamma_shader || (A._gamma_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, A.gamma_pixel_shader)), a.toViewport(A._gamma_shader, {u_texture:0, u_igamma:1 / b})) : a.toViewport();
      gl.viewport(d[0], d[1], d[2], d[3]);
    }
  }, A.prototype.onGetInputs = function() {
    return [["gamma", "number"]];
  }, A.aa_pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec2 uViewportSize;\n\t\tuniform vec2 inverseVP;\n\t\tuniform float u_igamma;\n\t\t#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\t\t#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\t\t#define FXAA_SPAN_MAX     8.0\n\t\t\n\t\t/* from mitsuhiko/webgl-meincraft based on the code on geeks3d.com */\n\t\tvec4 applyFXAA(sampler2D tex, vec2 fragCoord)\n\t\t{\n\t\t\tvec4 color = vec4(0.0);\n\t\t\t/*vec2 inverseVP = vec2(1.0 / uViewportSize.x, 1.0 / uViewportSize.y);*/\n\t\t\tvec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * inverseVP).xyz;\n\t\t\tvec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * inverseVP).xyz;\n\t\t\tvec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * inverseVP).xyz;\n\t\t\tvec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * inverseVP).xyz;\n\t\t\tvec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;\n\t\t\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\t\t\tfloat lumaNW = dot(rgbNW, luma);\n\t\t\tfloat lumaNE = dot(rgbNE, luma);\n\t\t\tfloat lumaSW = dot(rgbSW, luma);\n\t\t\tfloat lumaSE = dot(rgbSE, luma);\n\t\t\tfloat lumaM  = dot(rgbM,  luma);\n\t\t\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\t\t\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\t\t\n\t\t\tvec2 dir;\n\t\t\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\t\t\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\t\t\n\t\t\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t\t\t\n\t\t\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\t\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n\t\t\t\n\t\t\tvec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + \n\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n\t\t\tvec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + \n\t\t\t\ttexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\t\t\t\n\t\t\t//return vec4(rgbA,1.0);\n\t\t\tfloat lumaB = dot(rgbB, luma);\n\t\t\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\t\t\t\tcolor = vec4(rgbA, 1.0);\n\t\t\telse\n\t\t\t\tcolor = vec4(rgbB, 1.0);\n\t\t\tif(u_igamma != 1.0)\n\t\t\t\tcolor.xyz = pow( color.xyz, vec3(u_igamma) );\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tvoid main() {\n\t\t   gl_FragColor = applyFXAA( u_texture, v_coord * uViewportSize) ;\n\t\t}\n\t\t", 
  A.gamma_pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform float u_igamma;\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D( u_texture, v_coord);\n\t\t\tcolor.xyz = pow(color.xyz, vec3(u_igamma) );\n\t\t   gl_FragColor = color;\n\t\t}\n\t\t", L.registerNodeType("texture/toviewport", A), D.title = "Copy", D.desc = "Copy Texture", D.widgets_info = {size:{widget:"combo", values:[0, 32, 64, 128, 256, 512, 1024, 
  2048]}, precision:{widget:"combo", values:c.MODE_VALUES}}, D.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if ((a || this._temp_texture) && this.isOutputConnected(0)) {
      if (a) {
        var b = a.width, d = a.height;
        0 != this.properties.size && (d = b = this.properties.size);
        var f = this._temp_texture, h = a.type;
        this.properties.precision === c.LOW ? h = gl.UNSIGNED_BYTE : this.properties.precision === c.HIGH && (h = gl.HIGH_PRECISION_FORMAT);
        f && f.width == b && f.height == d && f.type == h || (f = gl.LINEAR, this.properties.generate_mipmaps && isPowerOfTwo(b) && isPowerOfTwo(d) && (f = gl.LINEAR_MIPMAP_LINEAR), this._temp_texture = new GL.Texture(b, d, {type:h, format:gl.RGBA, minFilter:f, magFilter:gl.LINEAR}));
        a.copyTo(this._temp_texture);
        this.properties.generate_mipmaps && (this._temp_texture.bind(0), gl.generateMipmap(this._temp_texture.texture_type), this._temp_texture.unbind(0));
      }
      this.setOutputData(0, this._temp_texture);
    }
  }, L.registerNodeType("texture/copy", D), B.title = "Downsample", B.desc = "Downsample Texture", B.widgets_info = {iterations:{type:"number", step:1, precision:0, min:0}, precision:{widget:"combo", values:c.MODE_VALUES}}, B.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if ((a || this._temp_texture) && this.isOutputConnected(0) && a && a.texture_type === GL.TEXTURE_2D) {
      if (1 > this.properties.iterations) {
        this.setOutputData(0, a);
      } else {
        var b = B._shader;
        b || (B._shader = b = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, B.pixel_shader));
        var d = a.width | 0, f = a.height | 0, h = a.type;
        this.properties.precision === c.LOW ? h = gl.UNSIGNED_BYTE : this.properties.precision === c.HIGH && (h = gl.HIGH_PRECISION_FORMAT);
        var k = this.properties.iterations || 1, e = a, g = [];
        h = {type:h, format:a.format};
        var t = vec2.create(), q = {u_offset:t};
        this._texture && GL.Texture.releaseTemporary(this._texture);
        for (var l = 0; l < k; ++l) {
          t[0] = 1 / d;
          t[1] = 1 / f;
          d = d >> 1 || 0;
          f = f >> 1 || 0;
          a = GL.Texture.getTemporary(d, f, h);
          g.push(a);
          e.setParameter(GL.TEXTURE_MAG_FILTER, GL.NEAREST);
          e.copyTo(a, b, q);
          if (1 == d && 1 == f) {
            break;
          }
          e = a;
        }
        this._texture = g.pop();
        for (l = 0; l < g.length; ++l) {
          GL.Texture.releaseTemporary(g[l]);
        }
        this.properties.generate_mipmaps && (this._texture.bind(0), gl.generateMipmap(this._texture.texture_type), this._texture.unbind(0));
        this.setOutputData(0, this._texture);
      }
    }
  }, B.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec2 u_offset;\n\t\tvarying vec2 v_coord;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D(u_texture, v_coord );\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, 0.0 ) );\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( 0.0, u_offset.y ) );\n\t\t\tcolor += texture2D(u_texture, v_coord + vec2( u_offset.x, u_offset.y ) );\n\t\t   gl_FragColor = color * 0.25;\n\t\t}\n\t\t", 
  L.registerNodeType("texture/downsample", B), F.title = "Resize", F.desc = "Resize Texture", F.widgets_info = {iterations:{type:"number", step:1, precision:0, min:0}, precision:{widget:"combo", values:c.MODE_VALUES}}, F.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if ((a || this._temp_texture) && this.isOutputConnected(0) && a && a.texture_type === GL.TEXTURE_2D) {
      var b = this.properties.size[0] | 0, d = this.properties.size[1] | 0;
      0 == b && (b = a.width);
      0 == d && (d = a.height);
      var f = a.type;
      this.properties.precision === c.LOW ? f = gl.UNSIGNED_BYTE : this.properties.precision === c.HIGH && (f = gl.HIGH_PRECISION_FORMAT);
      this._texture && this._texture.width == b && this._texture.height == d && this._texture.type == f || (this._texture = new GL.Texture(b, d, {type:f}));
      a.copyTo(this._texture);
      this.properties.generate_mipmaps && (this._texture.bind(0), gl.generateMipmap(this._texture.texture_type), this._texture.unbind(0));
      this.setOutputData(0, this._texture);
    }
  }, L.registerNodeType("texture/resize", F), e.title = "Average", e.desc = "Compute a partial average (32 random samples) of a texture and stores it as a 1x1 pixel texture.\n If high_quality is true, then it generates the mipmaps first and reads from the lower one.", e.prototype.onExecute = function() {
    this.properties.use_previous_frame || this.updateAverage();
    var a = this._luminance;
    this.setOutputData(0, this._temp_texture);
    this.setOutputData(1, a);
    this.setOutputData(2, (a[0] + a[1] + a[2]) / 3);
  }, e.prototype.onPreRenderExecute = function() {
    this.updateAverage();
  }, e.prototype.updateAverage = function() {
    var a = this.getInputData(0);
    if (a && (this.isOutputConnected(0) || this.isOutputConnected(1) || this.isOutputConnected(2))) {
      if (!e._shader) {
        e._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, e.pixel_shader);
        for (var b = new Float32Array(16), d = 0; d < b.length; ++d) {
          b[d] = Math.random();
        }
        e._shader.uniforms({u_samples_a:b.subarray(0, 16), u_samples_b:b.subarray(16, 32)});
      }
      d = this._temp_texture;
      b = gl.UNSIGNED_BYTE;
      a.type != b && (b = gl.FLOAT);
      d && d.type == b || (this._temp_texture = new GL.Texture(1, 1, {type:b, format:gl.RGBA, filter:gl.NEAREST}));
      this._uniforms.u_mipmap_offset = 0;
      this.properties.high_quality && (this._temp_pot2_texture && this._temp_pot2_texture.type == b || (this._temp_pot2_texture = new GL.Texture(512, 512, {type:b, format:gl.RGBA, minFilter:gl.LINEAR_MIPMAP_LINEAR, magFilter:gl.LINEAR})), a.copyTo(this._temp_pot2_texture), a = this._temp_pot2_texture, a.bind(0), gl.generateMipmap(GL.TEXTURE_2D), this._uniforms.u_mipmap_offset = 9);
      var c = e._shader, f = this._uniforms;
      f.u_mipmap_offset = this.properties.mipmap_offset;
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.BLEND);
      this._temp_texture.drawTo(function() {
        a.toViewport(c, f);
      });
      if (this.isOutputConnected(1) || this.isOutputConnected(2)) {
        if (d = this._temp_texture.getPixels()) {
          var h = this._luminance;
          b = this._temp_texture.type;
          h.set(d);
          b == gl.UNSIGNED_BYTE && vec4.scale(h, h, 1 / 255);
        }
      }
    }
  }, e.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tuniform mat4 u_samples_a;\n\t\tuniform mat4 u_samples_b;\n\t\tuniform sampler2D u_texture;\n\t\tuniform float u_mipmap_offset;\n\t\tvarying vec2 v_coord;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 color = vec4(0.0);\n\t\t\t//random average\n\t\t\tfor(int i = 0; i < 4; ++i)\n\t\t\t\tfor(int j = 0; j < 4; ++j)\n\t\t\t\t{\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( u_samples_a[i][j], u_samples_b[i][j] ), u_mipmap_offset );\n\t\t\t\t\tcolor += texture2D(u_texture, vec2( 1.0 - u_samples_a[i][j], 1.0 - u_samples_b[i][j] ), u_mipmap_offset );\n\t\t\t\t}\n\t\t   gl_FragColor = color * 0.03125;\n\t\t}\n\t\t", 
  L.registerNodeType("texture/average", e), z.title = "Smooth", z.desc = "Smooth texture over time", z.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      z._shader || (z._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, z.pixel_shader));
      var b = this._temp_texture;
      b && b.type == a.type && b.width == a.width && b.height == a.height || (b = {type:a.type, format:gl.RGBA, filter:gl.NEAREST}, this._temp_texture = new GL.Texture(a.width, a.height, b), this._temp_texture2 = new GL.Texture(a.width, a.height, b), a.copyTo(this._temp_texture2));
      b = this._temp_texture;
      var d = this._temp_texture2, c = z._shader, f = this._uniforms;
      f.u_factor = 1.0 - this.getInputOrProperty("factor");
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      b.drawTo(function() {
        d.bind(1);
        a.toViewport(c, f);
      });
      this.setOutputData(0, b);
      this._temp_texture = d;
      this._temp_texture2 = b;
    }
  }, z.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tuniform float u_factor;\n\t\tvarying vec2 v_coord;\n\t\t\n\t\tvoid main() {\n\t\t\tgl_FragColor = mix( texture2D( u_texture, v_coord ), texture2D( u_textureB, v_coord ), u_factor );\n\t\t}\n\t\t", L.registerNodeType("texture/temporal_smooth", z), H.title = "Lineal Avg Smooth", H.desc = "Smooth texture linearly over time", H["@samples"] = {type:"number", 
  min:1, max:64, step:1, precision:1}, H.prototype.getPreviewTexture = function() {
    return this._temp_texture2;
  }, H.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      H._shader || (H._shader_copy = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, H.pixel_shader_copy), H._shader_avg = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, H.pixel_shader_avg));
      var b = Math.clamp(this.properties.samples, 0, 64), d = this.frame, c = this.properties.frames_interval;
      if (0 == c || 0 == d % c) {
        d = this._temp_texture;
        d && d.type == a.type && d.width == b || (d = {type:a.type, format:gl.RGBA, filter:gl.NEAREST}, this._temp_texture = new GL.Texture(b, 1, d), this._temp_texture2 = new GL.Texture(b, 1, d), this._temp_texture_out = new GL.Texture(1, 1, d));
        var f = this._temp_texture, h = this._temp_texture2, k = H._shader_copy, e = H._shader_avg, g = this._uniforms;
        g.u_samples = b;
        g.u_isamples = 1.0 / b;
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        f.drawTo(function() {
          h.bind(1);
          a.toViewport(k, g);
        });
        this._temp_texture_out.drawTo(function() {
          f.toViewport(e, g);
        });
        this.setOutputData(0, this._temp_texture_out);
        this._temp_texture = h;
        this._temp_texture2 = f;
      } else {
        this.setOutputData(0, this._temp_texture_out);
      }
      this.setOutputData(1, this._temp_texture2);
      this.frame++;
    }
  }, H.pixel_shader_copy = "precision highp float;\n\t\tprecision highp float;\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tuniform float u_isamples;\n\t\tvarying vec2 v_coord;\n\t\t\n\t\tvoid main() {\n\t\t\tif( v_coord.x <= u_isamples )\n\t\t\t\tgl_FragColor = texture2D( u_texture, vec2(0.5) );\n\t\t\telse\n\t\t\t\tgl_FragColor = texture2D( u_textureB, v_coord - vec2(u_isamples,0.0) );\n\t\t}\n\t\t", H.pixel_shader_avg = "precision highp float;\n\t\tprecision highp float;\n\t\tuniform sampler2D u_texture;\n\t\tuniform int u_samples;\n\t\tuniform float u_isamples;\n\t\tvarying vec2 v_coord;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 color = vec4(0.0);\n\t\t\tfor(int i = 0; i < 64; ++i)\n\t\t\t{\n\t\t\t\tcolor += texture2D( u_texture, vec2( float(i)*u_isamples,0.0) );\n\t\t\t\tif(i == (u_samples - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgl_FragColor = color * u_isamples;\n\t\t}\n\t\t", 
  L.registerNodeType("texture/linear_avg_smooth", H), x.title = "Image to Texture", x.desc = "Uploads an image to the GPU", x.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      var b = a.videoWidth || a.width, d = a.videoHeight || a.height;
      if (a.gltexture) {
        this.setOutputData(0, a.gltexture);
      } else {
        var c = this._temp_texture;
        c && c.width == b && c.height == d || (this._temp_texture = new GL.Texture(b, d, {format:gl.RGBA, filter:gl.LINEAR}));
        try {
          this._temp_texture.uploadImage(a);
        } catch (Y) {
          console.error("image comes from an unsafe location, cannot be uploaded to webgl: " + Y);
          return;
        }
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, L.registerNodeType("texture/imageToTexture", x), K.widgets_info = {texture:{widget:"texture"}, precision:{widget:"combo", values:c.MODE_VALUES}}, K.title = "LUT", K.desc = "Apply LUT to Texture", K.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (this.properties.precision === c.PASS_THROUGH || !1 === this.properties.enabled) {
        this.setOutputData(0, a);
      } else {
        if (a) {
          var b = this.getInputData(1);
          b || (b = c.getTexture(this.properties.texture));
          if (b) {
            b.bind(0);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            var d = this.properties.intensity;
            this.isInputConnected(2) && (this.properties.intensity = d = this.getInputData(2));
            this._tex = c.getTargetTexture(a, this._tex, this.properties.precision);
            this._tex.drawTo(function() {
              b.bind(1);
              a.toViewport(K._shader, {u_texture:0, u_textureB:1, u_amount:d});
            });
            this.setOutputData(0, this._tex);
          } else {
            this.setOutputData(0, a);
          }
        }
      }
    }
  }, K.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tuniform float u_amount;\n\t\t\n\t\tvoid main() {\n\t\t\t lowp vec4 textureColor = clamp( texture2D(u_texture, v_coord), vec4(0.0), vec4(1.0) );\n\t\t\t mediump float blueColor = textureColor.b * 63.0;\n\t\t\t mediump vec2 quad1;\n\t\t\t quad1.y = floor(floor(blueColor) / 8.0);\n\t\t\t quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\t\t\t mediump vec2 quad2;\n\t\t\t quad2.y = floor(ceil(blueColor) / 8.0);\n\t\t\t quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\t\t\t highp vec2 texPos1;\n\t\t\t texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\t\t\t texPos1.y = 1.0 - ((quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\t\t\t highp vec2 texPos2;\n\t\t\t texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n\t\t\t texPos2.y = 1.0 - ((quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g));\n\t\t\t lowp vec4 newColor1 = texture2D(u_textureB, texPos1);\n\t\t\t lowp vec4 newColor2 = texture2D(u_textureB, texPos2);\n\t\t\t lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n\t\t\t gl_FragColor = vec4( mix( textureColor.rgb, newColor.rgb, u_amount), textureColor.w);\n\t\t}\n\t\t", 
  L.registerNodeType("texture/LUT", K), k.widgets_info = {texture:{widget:"texture"}, precision:{widget:"combo", values:c.MODE_VALUES}}, k.title = "Encode", k.desc = "Apply a texture atlas to encode a texture", k.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (this.properties.precision === c.PASS_THROUGH || !1 === this.properties.enabled) {
        this.setOutputData(0, a);
      } else {
        if (a) {
          var b = this.getInputData(1);
          b || (b = c.getTexture(this.properties.texture));
          if (b) {
            b.bind(0);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.properties.filter ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            var d = this._uniforms;
            d.u_row_simbols = Math.floor(this.properties.num_row_symbols);
            d.u_symbol_size = this.properties.symbol_size;
            d.u_brightness = this.properties.brightness;
            d.u_invert = this.properties.invert ? 1 : 0;
            d.u_colorize = this.properties.colorize ? 1 : 0;
            this._tex = c.getTargetTexture(a, this._tex, this.properties.precision);
            d.u_res[0] = this._tex.width;
            d.u_res[1] = this._tex.height;
            this._tex.bind(0);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            this._tex.drawTo(function() {
              b.bind(1);
              a.toViewport(k._shader, d);
            });
            this.properties.generate_mipmaps && (this._tex.bind(0), gl.generateMipmap(this._tex.texture_type), this._tex.unbind(0));
            this.setOutputData(0, this._tex);
          } else {
            this.setOutputData(0, a);
          }
        }
      }
    }
  }, k.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_textureB;\n\t\tuniform float u_row_simbols;\n\t\tuniform float u_symbol_size;\n\t\tuniform float u_brightness;\n\t\tuniform float u_invert;\n\t\tuniform float u_colorize;\n\t\tuniform vec2 u_res;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 total_symbols = u_res / u_symbol_size;\n\t\t\tvec2 uv = floor(v_coord * total_symbols) / total_symbols; //pixelate \n\t\t\tvec2 local_uv = mod(v_coord * u_res, u_symbol_size) / u_symbol_size;\n\t\t\tlowp vec4 textureColor = texture2D(u_texture, uv );\n\t\t\tfloat lum = clamp(u_brightness * (textureColor.x + textureColor.y + textureColor.z)/3.0,0.0,1.0);\n\t\t\tif( u_invert == 1.0 ) lum = 1.0 - lum;\n\t\t\tfloat index = floor( lum * (u_row_simbols * u_row_simbols - 1.0));\n\t\t\tfloat col = mod( index, u_row_simbols );\n\t\t\tfloat row = u_row_simbols - floor( index / u_row_simbols ) - 1.0;\n\t\t\tvec2 simbol_uv = ( vec2( col, row ) + local_uv ) / u_row_simbols;\n\t\t\tvec4 color = texture2D( u_textureB, simbol_uv );\n\t\t\tif(u_colorize == 1.0)\n\t\t\t\tcolor *= textureColor;\n\t\t\tgl_FragColor = color;\n\t\t}\n\t\t", 
  L.registerNodeType("texture/encode", k), q.title = "Texture to Channels", q.desc = "Split texture channels", q.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      this._channels || (this._channels = Array(4));
      for (var b = gl.RGB, d = 0, c = 0; 4 > c; c++) {
        this.isOutputConnected(c) ? (this._channels[c] && this._channels[c].width == a.width && this._channels[c].height == a.height && this._channels[c].type == a.type && this._channels[c].format == b || (this._channels[c] = new GL.Texture(a.width, a.height, {type:a.type, format:b, filter:gl.LINEAR})), d++) : this._channels[c] = null;
      }
      if (d) {
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var f = Mesh.getScreenQuad(), h = q._shader, k = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
        for (c = 0; 4 > c; c++) {
          this._channels[c] && (this._channels[c].drawTo(function() {
            a.bind(0);
            h.uniforms({u_texture:0, u_mask:k[c]}).draw(f);
          }), this.setOutputData(c, this._channels[c]));
        }
      }
    }
  }, q.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec4 u_mask;\n\t\t\n\t\tvoid main() {\n\t\t   gl_FragColor = vec4( vec3( length( texture2D(u_texture, v_coord) * u_mask )), 1.0 );\n\t\t}\n\t\t", L.registerNodeType("texture/textureChannels", q), t.title = "Channels to Texture", t.desc = "Split texture channels", t.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, t.prototype.onExecute = 
  function() {
    var a = c.getWhiteTexture(), b = this.getInputData(0) || a, d = this.getInputData(1) || a, f = this.getInputData(2) || a, h = this.getInputData(3) || a;
    gl.disable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
    var k = Mesh.getScreenQuad();
    t._shader || (t._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, t.pixel_shader));
    var e = t._shader;
    a = Math.max(b.width, d.width, f.width, h.width);
    var g = Math.max(b.height, d.height, f.height, h.height), q = this.properties.precision == c.HIGH ? c.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
    this._texture && this._texture.width == a && this._texture.height == g && this._texture.type == q || (this._texture = new GL.Texture(a, g, {type:q, format:gl.RGBA, filter:gl.LINEAR}));
    a = this._color;
    a[0] = this.properties.R;
    a[1] = this.properties.G;
    a[2] = this.properties.B;
    a[3] = this.properties.A;
    var l = this._uniforms;
    this._texture.drawTo(function() {
      b.bind(0);
      d.bind(1);
      f.bind(2);
      h.bind(3);
      e.uniforms(l).draw(k);
    });
    this.setOutputData(0, this._texture);
  }, t.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_textureR;\n\t\tuniform sampler2D u_textureG;\n\t\tuniform sampler2D u_textureB;\n\t\tuniform sampler2D u_textureA;\n\t\tuniform vec4 u_color;\n\t\t\n\t\tvoid main() {\n\t\t   gl_FragColor = u_color * vec4( \t\t\t\t\ttexture2D(u_textureR, v_coord).r,\t\t\t\t\ttexture2D(u_textureG, v_coord).r,\t\t\t\t\ttexture2D(u_textureB, v_coord).r,\t\t\t\t\ttexture2D(u_textureA, v_coord).r);\n\t\t}\n\t\t", 
  L.registerNodeType("texture/channelsTexture", t), a.title = "Color", a.desc = "Generates a 1x1 texture with a constant color", a.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, a.prototype.onDrawBackground = function(a) {
    var b = this.properties.color;
    a.fillStyle = "rgb(" + Math.floor(255 * Math.clamp(b[0], 0, 1)) + "," + Math.floor(255 * Math.clamp(b[1], 0, 1)) + "," + Math.floor(255 * Math.clamp(b[2], 0, 1)) + ")";
    this.flags.collapsed ? this.boxcolor = a.fillStyle : a.fillRect(0, 0, this.size[0], this.size[1]);
  }, a.prototype.onExecute = function() {
    var a = this.properties.precision == c.HIGH ? c.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
    this._tex && this._tex.type == a || (this._tex = new GL.Texture(1, 1, {format:gl.RGBA, type:a, minFilter:gl.NEAREST}));
    a = this.properties.color;
    if (this.inputs) {
      for (var b = 0; b < this.inputs.length; b++) {
        var d = this.inputs[b], f = this.getInputData(b);
        if (void 0 !== f) {
          switch(d.name) {
            case "RGB":
            case "RGBA":
              a.set(f);
              break;
            case "R":
              a[0] = f;
              break;
            case "G":
              a[1] = f;
              break;
            case "B":
              a[2] = f;
              break;
            case "A":
              a[3] = f;
          }
        }
      }
    }
    0.001 < vec4.sqrDist(this._tex_color, a) && (this._tex_color.set(a), this._tex.fill(a));
    this.setOutputData(0, this._tex);
  }, a.prototype.onGetInputs = function() {
    return [["RGB", "vec3"], ["RGBA", "vec4"], ["R", "number"], ["G", "number"], ["B", "number"], ["A", "number"]];
  }, L.registerNodeType("texture/color", a), b.title = "Gradient", b.desc = "Generates a gradient", b["@A"] = {type:"color"}, b["@B"] = {type:"color"}, b["@texture_size"] = {type:"enum", values:[32, 64, 128, 256, 512]}, b.prototype.onExecute = function() {
    gl.disable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
    var a = GL.Mesh.getScreenQuad(), d = b._shader, c = this.getInputData(0);
    c || (c = this.properties.A);
    var f = this.getInputData(1);
    f || (f = this.properties.B);
    for (var h = 2; h < this.inputs.length; h++) {
      var k = this.inputs[h], e = this.getInputData(h);
      void 0 !== e && (this.properties[k.name] = e);
    }
    var g = this._uniforms;
    this._uniforms.u_angle = this.properties.angle * DEG2RAD;
    this._uniforms.u_scale = this.properties.scale;
    vec3.copy(g.u_colorA, c);
    vec3.copy(g.u_colorB, f);
    c = parseInt(this.properties.texture_size);
    this._tex && this._tex.width == c || (this._tex = new GL.Texture(c, c, {format:gl.RGB, filter:gl.LINEAR}));
    this._tex.drawTo(function() {
      d.uniforms(g).draw(a);
    });
    this.setOutputData(0, this._tex);
  }, b.prototype.onGetInputs = function() {
    return [["angle", "number"], ["scale", "number"]];
  }, b.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform float u_angle;\n\t\tuniform float u_scale;\n\t\tuniform vec3 u_colorA;\n\t\tuniform vec3 u_colorB;\n\t\t\n\t\tvec2 rotate(vec2 v, float angle)\n\t\t{\n\t\t\tvec2 result;\n\t\t\tfloat _cos = cos(angle);\n\t\t\tfloat _sin = sin(angle);\n\t\t\tresult.x = v.x * _cos - v.y * _sin;\n\t\t\tresult.y = v.x * _sin + v.y * _cos;\n\t\t\treturn result;\n\t\t}\n\t\tvoid main() {\n\t\t\tfloat f = (rotate(u_scale * (v_coord - vec2(0.5)), u_angle) + vec2(0.5)).x;\n\t\t\tvec3 color = mix(u_colorA,u_colorB,clamp(f,0.0,1.0));\n\t\t   gl_FragColor = vec4(color,1.0);\n\t\t}\n\t\t", 
  L.registerNodeType("texture/gradient", b), d.title = "Mix", d.desc = "Generates a texture mixing two textures", d.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, d.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (this.isOutputConnected(0)) {
      if (this.properties.precision === c.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        var b = this.getInputData(1);
        if (a && b) {
          var f = this.getInputData(2), h = this.getInputData(3);
          this._tex = c.getTargetTexture(this.properties.size_from_biggest && b.width > a.width ? b : a, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var k = Mesh.getScreenQuad(), e = null, g = this._uniforms;
          f ? (e = d._shader_tex, e || (e = d._shader_tex = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, d.pixel_shader, {MIX_TEX:""}))) : (e = d._shader_factor, e || (e = d._shader_factor = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, d.pixel_shader)), h = null == h ? this.properties.factor : h, g.u_mix.set([h, h, h, h]));
          var t = this.properties.invert;
          this._tex.drawTo(function() {
            a.bind(t ? 1 : 0);
            b.bind(t ? 0 : 1);
            f && f.bind(2);
            e.uniforms(g).draw(k);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  }, d.prototype.onGetInputs = function() {
    return [["factor", "number"]];
  }, d.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_textureA;\n\t\tuniform sampler2D u_textureB;\n\t\t#ifdef MIX_TEX\n\t\t\tuniform sampler2D u_textureMix;\n\t\t#else\n\t\t\tuniform vec4 u_mix;\n\t\t#endif\n\t\t\n\t\tvoid main() {\n\t\t\t#ifdef MIX_TEX\n\t\t\t   vec4 f = texture2D(u_textureMix, v_coord);\n\t\t\t#else\n\t\t\t   vec4 f = u_mix;\n\t\t\t#endif\n\t\t   gl_FragColor = mix( texture2D(u_textureA, v_coord), texture2D(u_textureB, v_coord), f );\n\t\t}\n\t\t", 
  L.registerNodeType("texture/mix", d), f.title = "Edges", f.desc = "Detects edges", f.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, f.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (this.properties.precision === c.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        if (a) {
          this._tex = c.getTargetTexture(a, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var b = Mesh.getScreenQuad(), d = f._shader, h = this.properties.invert, e = this.properties.factor, k = this.properties.threshold ? 1 : 0;
          this._tex.drawTo(function() {
            a.bind(0);
            d.uniforms({u_texture:0, u_isize:[1 / a.width, 1 / a.height], u_factor:e, u_threshold:k, u_invert:h ? 1 : 0}).draw(b);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  }, f.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec2 u_isize;\n\t\tuniform int u_invert;\n\t\tuniform float u_factor;\n\t\tuniform float u_threshold;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 center = texture2D(u_texture, v_coord);\n\t\t\tvec4 up = texture2D(u_texture, v_coord + u_isize * vec2(0.0,1.0) );\n\t\t\tvec4 down = texture2D(u_texture, v_coord + u_isize * vec2(0.0,-1.0) );\n\t\t\tvec4 left = texture2D(u_texture, v_coord + u_isize * vec2(1.0,0.0) );\n\t\t\tvec4 right = texture2D(u_texture, v_coord + u_isize * vec2(-1.0,0.0) );\n\t\t\tvec4 diff = abs(center - up) + abs(center - down) + abs(center - left) + abs(center - right);\n\t\t\tdiff *= u_factor;\n\t\t\tif(u_invert == 1)\n\t\t\t\tdiff.xyz = vec3(1.0) - diff.xyz;\n\t\t\tif( u_threshold == 0.0 )\n\t\t\t\tgl_FragColor = vec4( diff.xyz, center.a );\n\t\t\telse\n\t\t\t\tgl_FragColor = vec4( diff.x > 0.5 ? 1.0 : 0.0, diff.y > 0.5 ? 1.0 : 0.0, diff.z > 0.5 ? 1.0 : 0.0, center.a );\n\t\t}\n\t\t", 
  L.registerNodeType("texture/edges", f), h.title = "Depth Range", h.desc = "Generates a texture with a depth range", h.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (a) {
        var b = gl.UNSIGNED_BYTE;
        this.properties.high_precision && (b = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
        this._temp_texture && this._temp_texture.type == b && this._temp_texture.width == a.width && this._temp_texture.height == a.height || (this._temp_texture = new GL.Texture(a.width, a.height, {type:b, format:gl.RGBA, filter:gl.LINEAR}));
        var d = this._uniforms;
        b = this.properties.distance;
        this.isInputConnected(1) && (b = this.getInputData(1), this.properties.distance = b);
        var c = this.properties.range;
        this.isInputConnected(2) && (c = this.getInputData(2), this.properties.range = c);
        d.u_distance = b;
        d.u_range = c;
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var f = Mesh.getScreenQuad();
        h._shader || (h._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, h.pixel_shader), h._shader_onlydepth = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, h.pixel_shader, {ONLY_DEPTH:""}));
        var e = this.properties.only_depth ? h._shader_onlydepth : h._shader;
        b = null;
        b = a.near_far_planes ? a.near_far_planes : window.LS && LS.Renderer._main_camera ? LS.Renderer._main_camera._uniforms.u_camera_planes : [0.1, 1000];
        d.u_camera_planes = b;
        this._temp_texture.drawTo(function() {
          a.bind(0);
          e.uniforms(d).draw(f);
        });
        this._temp_texture.near_far_planes = b;
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, h.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec2 u_camera_planes;\n\t\tuniform float u_distance;\n\t\tuniform float u_range;\n\t\t\n\t\tfloat LinearDepth()\n\t\t{\n\t\t\tfloat zNear = u_camera_planes.x;\n\t\t\tfloat zFar = u_camera_planes.y;\n\t\t\tfloat depth = texture2D(u_texture, v_coord).x;\n\t\t\tdepth = depth * 2.0 - 1.0;\n\t\t\treturn zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\t\t}\n\t\t\n\t\tvoid main() {\n\t\t\tfloat depth = LinearDepth();\n\t\t\t#ifdef ONLY_DEPTH\n\t\t\t   gl_FragColor = vec4(depth);\n\t\t\t#else\n\t\t\t\tfloat diff = abs(depth * u_camera_planes.y - u_distance);\n\t\t\t\tfloat dof = 1.0;\n\t\t\t\tif(diff <= u_range)\n\t\t\t\t\tdof = diff / u_range;\n\t\t\t   gl_FragColor = vec4(dof);\n\t\t\t#endif\n\t\t}\n\t\t", 
  L.registerNodeType("texture/depth_range", h), w.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, w.title = "Linear Depth", w.desc = "Creates a color texture with linear depth", w.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (a && (a.format == gl.DEPTH_COMPONENT || a.format == gl.DEPTH_STENCIL)) {
        var b = this.properties.precision == c.HIGH ? gl.HIGH_PRECISION_FORMAT : gl.UNSIGNED_BYTE;
        this._temp_texture && this._temp_texture.type == b && this._temp_texture.width == a.width && this._temp_texture.height == a.height || (this._temp_texture = new GL.Texture(a.width, a.height, {type:b, format:gl.RGB, filter:gl.LINEAR}));
        var d = this._uniforms;
        d.u_invert = this.properties.invert ? 1 : 0;
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        var f = Mesh.getScreenQuad();
        w._shader || (w._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, w.pixel_shader));
        var h = w._shader;
        b = null;
        b = a.near_far_planes ? a.near_far_planes : window.LS && LS.Renderer._main_camera ? LS.Renderer._main_camera._uniforms.u_camera_planes : [0.1, 1000];
        d.u_camera_planes = b;
        d.u_ires.set([0, 0]);
        this._temp_texture.drawTo(function() {
          a.bind(0);
          h.uniforms(d).draw(f);
        });
        this._temp_texture.near_far_planes = b;
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, w.pixel_shader = "precision highp float;\n\t\tprecision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec2 u_camera_planes;\n\t\tuniform int u_invert;\n\t\tuniform vec2 u_ires;\n\t\t\n\t\tvoid main() {\n\t\t\tfloat zNear = u_camera_planes.x;\n\t\t\tfloat zFar = u_camera_planes.y;\n\t\t\tfloat depth = texture2D(u_texture, v_coord + u_ires*0.5).x * 2.0 - 1.0;\n\t\t\tfloat f = zNear * (depth + 1.0) / (zFar + zNear - depth * (zFar - zNear));\n\t\t\tif( u_invert == 1 )\n\t\t\t\tf = 1.0 - f;\n\t\t\tgl_FragColor = vec4(vec3(f),1.0);\n\t\t}\n\t\t", 
  L.registerNodeType("texture/linear_depth", w), v.title = "Blur", v.desc = "Blur a texture", v.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, v.max_iterations = 20, v.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._final_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._final_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      var d = this.properties.iterations;
      this.isInputConnected(1) && (d = this.getInputData(1), this.properties.iterations = d);
      d = Math.min(Math.floor(d), v.max_iterations);
      if (0 == d) {
        this.setOutputData(0, a);
      } else {
        var c = this.properties.intensity;
        this.isInputConnected(2) && (c = this.getInputData(2), this.properties.intensity = c);
        var f = L.camera_aspect;
        f || void 0 === window.gl || (f = gl.canvas.height / gl.canvas.width);
        f || (f = 1);
        f = this.properties.preserve_aspect ? f : 1;
        var h = this.properties.scale || [1, 1];
        a.applyBlur(f * h[0], h[1], c, b);
        for (a = 1; a < d; ++a) {
          b.applyBlur(f * h[0] * (a + 1), h[1] * (a + 1), c);
        }
        this.setOutputData(0, b);
      }
    }
  }, L.registerNodeType("texture/blur", v), r.prototype.applyFX = function(a, b, d, c) {
    var f = a.width, h = a.height, e = {format:a.format, type:a.type, minFilter:GL.LINEAR, magFilter:GL.LINEAR, wrap:gl.CLAMP_TO_EDGE}, k = this._uniforms, g = this._textures, t = r._cut_shader;
    t || (t = r._cut_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, r.cut_pixel_shader));
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    k.u_threshold = this.threshold;
    var q = g[0] = GL.Texture.getTemporary(f, h, e);
    a.blit(q, t.uniforms(k));
    var l = q, I = this.iterations;
    I = Math.clamp(I, 1, 16) | 0;
    var E = k.u_texel_size, v = this.intensity;
    k.u_intensity = 1;
    k.u_delta = this.scale;
    t = r._shader;
    t || (t = r._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, r.scale_pixel_shader));
    for (var m = 1; m < I; m++) {
      f >>= 1;
      1 < (h | 0) && (h >>= 1);
      if (2 > f) {
        break;
      }
      q = g[m] = GL.Texture.getTemporary(f, h, e);
      E[0] = 1 / l.width;
      E[1] = 1 / l.height;
      l.blit(q, t.uniforms(k));
      l = q;
    }
    c && (E[0] = 1 / l.width, E[1] = 1 / l.height, k.u_intensity = v, k.u_delta = 1, l.blit(c, t.uniforms(k)));
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE);
    k.u_intensity = this.persistence;
    k.u_delta = 0.5;
    for (m -= 2; 0 <= m; m--) {
      q = g[m], g[m] = null, E[0] = 1 / l.width, E[1] = 1 / l.height, l.blit(q, t.uniforms(k)), GL.Texture.releaseTemporary(l), l = q;
    }
    gl.disable(gl.BLEND);
    d && l.blit(d);
    if (b) {
      var w = this.dirt_texture, z = this.dirt_factor;
      k.u_intensity = v;
      t = w ? r._dirt_final_shader : r._final_shader;
      t || (t = w ? r._dirt_final_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, r.final_pixel_shader, {USE_DIRT:""}) : r._final_shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, r.final_pixel_shader));
      b.drawTo(function() {
        a.bind(0);
        l.bind(1);
        w && (t.setUniform("u_dirt_factor", z), t.setUniform("u_dirt_texture", w.bind(2)));
        t.toViewport(k);
      });
    }
    GL.Texture.releaseTemporary(l);
  }, r.cut_pixel_shader = "precision highp float;\n\tvarying vec2 v_coord;\n\tuniform sampler2D u_texture;\n\tuniform float u_threshold;\n\tvoid main() {\n\t\tgl_FragColor = max( texture2D( u_texture, v_coord ) - vec4( u_threshold ), vec4(0.0) );\n\t}", r.scale_pixel_shader = "precision highp float;\n\tvarying vec2 v_coord;\n\tuniform sampler2D u_texture;\n\tuniform vec2 u_texel_size;\n\tuniform float u_delta;\n\tuniform float u_intensity;\n\t\n\tvec4 sampleBox(vec2 uv) {\n\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\t\tvec4 s = texture2D( u_texture, uv + o.xy ) + texture2D( u_texture, uv + o.zy) + texture2D( u_texture, uv + o.xw) + texture2D( u_texture, uv + o.zw);\n\t\treturn s * 0.25;\n\t}\n\tvoid main() {\n\t\tgl_FragColor = u_intensity * sampleBox( v_coord );\n\t}", 
  r.final_pixel_shader = "precision highp float;\n\tvarying vec2 v_coord;\n\tuniform sampler2D u_texture;\n\tuniform sampler2D u_glow_texture;\n\t#ifdef USE_DIRT\n\t\tuniform sampler2D u_dirt_texture;\n\t#endif\n\tuniform vec2 u_texel_size;\n\tuniform float u_delta;\n\tuniform float u_intensity;\n\tuniform float u_dirt_factor;\n\t\n\tvec4 sampleBox(vec2 uv) {\n\t\tvec4 o = u_texel_size.xyxy * vec2(-u_delta, u_delta).xxyy;\n\t\tvec4 s = texture2D( u_glow_texture, uv + o.xy ) + texture2D( u_glow_texture, uv + o.zy) + texture2D( u_glow_texture, uv + o.xw) + texture2D( u_glow_texture, uv + o.zw);\n\t\treturn s * 0.25;\n\t}\n\tvoid main() {\n\t\tvec4 glow = sampleBox( v_coord );\n\t\t#ifdef USE_DIRT\n\t\t\tglow = mix( glow, glow * texture2D( u_dirt_texture, v_coord ), u_dirt_factor );\n\t\t#endif\n\t\tgl_FragColor = texture2D( u_texture, v_coord ) + u_intensity * glow;\n\t}", 
  N.title = "Glow", N.desc = "Filters a texture giving it a glow effect", N.widgets_info = {iterations:{type:"number", min:0, max:16, step:1, precision:0}, threshold:{type:"number", min:0, max:10, step:0.01, precision:2}, precision:{widget:"combo", values:c.MODE_VALUES}}, N.prototype.onGetInputs = function() {
    return [["enabled", "boolean"], ["threshold", "number"], ["intensity", "number"], ["persistence", "number"], ["iterations", "number"], ["dirt_factor", "number"]];
  }, N.prototype.onGetOutputs = function() {
    return [["average", "Texture"]];
  }, N.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isAnyOutputConnected()) {
      if (this.properties.precision === c.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
        this.setOutputData(0, a);
      } else {
        var b = this.fx;
        b.threshold = this.getInputOrProperty("threshold");
        b.iterations = this.getInputOrProperty("iterations");
        b.intensity = this.getInputOrProperty("intensity");
        b.persistence = this.getInputOrProperty("persistence");
        b.dirt_texture = this.getInputData(1);
        b.dirt_factor = this.getInputOrProperty("dirt_factor");
        b.scale = this.properties.scale;
        var d = c.getTextureType(this.properties.precision, a), f = null;
        this.isOutputConnected(2) && (f = this._average_texture, f && f.type == a.type && f.format == a.format || (f = this._average_texture = new GL.Texture(1, 1, {type:a.type, format:a.format, filter:gl.LINEAR})));
        var h = null;
        this.isOutputConnected(1) && (h = this._glow_texture, h && h.width == a.width && h.height == a.height && h.type == d && h.format == a.format || (h = this._glow_texture = new GL.Texture(a.width, a.height, {type:d, format:a.format, filter:gl.LINEAR})));
        var k = null;
        this.isOutputConnected(0) && (k = this._final_texture, k && k.width == a.width && k.height == a.height && k.type == d && k.format == a.format || (k = this._final_texture = new GL.Texture(a.width, a.height, {type:d, format:a.format, filter:gl.LINEAR})));
        b.applyFX(a, k, h, f);
        this.isOutputConnected(0) && this.setOutputData(0, k);
        this.isOutputConnected(1) && this.setOutputData(1, f);
        this.isOutputConnected(2) && this.setOutputData(2, h);
      }
    }
  }, L.registerNodeType("texture/glow", N), O.title = "Kuwahara Filter", O.desc = "Filters a texture giving an artistic oil canvas painting", O.max_radius = 10, O._shaders = [], O.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      b = this.properties.radius;
      b = Math.min(Math.floor(b), O.max_radius);
      if (0 == b) {
        this.setOutputData(0, a);
      } else {
        var d = this.properties.intensity, c = L.camera_aspect;
        c || void 0 === window.gl || (c = gl.canvas.height / gl.canvas.width);
        c || (c = 1);
        c = this.properties.preserve_aspect ? c : 1;
        O._shaders[b] || (O._shaders[b] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, O.pixel_shader, {RADIUS:b.toFixed(0)}));
        var f = O._shaders[b], h = GL.Mesh.getScreenQuad();
        a.bind(0);
        this._temp_texture.drawTo(function() {
          f.uniforms({u_texture:0, u_intensity:d, u_resolution:[a.width, a.height], u_iResolution:[1 / a.width, 1 / a.height]}).draw(h);
        });
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, O.pixel_shader = "\nprecision highp float;\nvarying vec2 v_coord;\nuniform sampler2D u_texture;\nuniform float u_intensity;\nuniform vec2 u_resolution;\nuniform vec2 u_iResolution;\n#ifndef RADIUS\n\t#define RADIUS 7\n#endif\nvoid main() {\n\n\tconst int radius = RADIUS;\n\tvec2 fragCoord = v_coord;\n\tvec2 src_size = u_iResolution;\n\tvec2 uv = v_coord;\n\tfloat n = float((radius + 1) * (radius + 1));\n\tint i;\n\tint j;\n\tvec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n\tvec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n\tvec3 c;\n\t\n\tfor (int j = -radius; j <= 0; ++j)  {\n\t\tfor (int i = -radius; i <= 0; ++i)  {\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\t\t\tm0 += c;\n\t\t\ts0 += c * c;\n\t\t}\n\t}\n\t\n\tfor (int j = -radius; j <= 0; ++j)  {\n\t\tfor (int i = 0; i <= radius; ++i)  {\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\t\t\tm1 += c;\n\t\t\ts1 += c * c;\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= radius; ++j)  {\n\t\tfor (int i = 0; i <= radius; ++i)  {\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\t\t\tm2 += c;\n\t\t\ts2 += c * c;\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j <= radius; ++j)  {\n\t\tfor (int i = -radius; i <= 0; ++i)  {\n\t\t\tc = texture2D(u_texture, uv + vec2(i,j) * src_size).rgb;\n\t\t\tm3 += c;\n\t\t\ts3 += c * c;\n\t\t}\n\t}\n\t\n\tfloat min_sigma2 = 1e+2;\n\tm0 /= n;\n\ts0 = abs(s0 / n - m0 * m0);\n\t\n\tfloat sigma2 = s0.r + s0.g + s0.b;\n\tif (sigma2 < min_sigma2) {\n\t\tmin_sigma2 = sigma2;\n\t\tgl_FragColor = vec4(m0, 1.0);\n\t}\n\t\n\tm1 /= n;\n\ts1 = abs(s1 / n - m1 * m1);\n\t\n\tsigma2 = s1.r + s1.g + s1.b;\n\tif (sigma2 < min_sigma2) {\n\t\tmin_sigma2 = sigma2;\n\t\tgl_FragColor = vec4(m1, 1.0);\n\t}\n\t\n\tm2 /= n;\n\ts2 = abs(s2 / n - m2 * m2);\n\t\n\tsigma2 = s2.r + s2.g + s2.b;\n\tif (sigma2 < min_sigma2) {\n\t\tmin_sigma2 = sigma2;\n\t\tgl_FragColor = vec4(m2, 1.0);\n\t}\n\t\n\tm3 /= n;\n\ts3 = abs(s3 / n - m3 * m3);\n\t\n\tsigma2 = s3.r + s3.g + s3.b;\n\tif (sigma2 < min_sigma2) {\n\t\tmin_sigma2 = sigma2;\n\t\tgl_FragColor = vec4(m3, 1.0);\n\t}\n}\n", 
  L.registerNodeType("texture/kuwahara", O), M.title = "XDoG Filter", M.desc = "Filters a texture giving an artistic ink style", M.max_radius = 10, M._shaders = [], M.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      M._xdog_shader || (M._xdog_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, M.xdog_pixel_shader));
      var d = M._xdog_shader, c = GL.Mesh.getScreenQuad(), f = this.properties.sigma, h = this.properties.k, k = this.properties.p, e = this.properties.epsilon, g = this.properties.phi;
      a.bind(0);
      this._temp_texture.drawTo(function() {
        d.uniforms({src:0, sigma:f, k:h, p:k, epsilon:e, phi:g, cvsWidth:a.width, cvsHeight:a.height}).draw(c);
      });
      this.setOutputData(0, this._temp_texture);
    }
  }, M.xdog_pixel_shader = "\nprecision highp float;\nuniform sampler2D src;\n\nuniform float cvsHeight;\nuniform float cvsWidth;\n\nuniform float sigma;\nuniform float k;\nuniform float p;\nuniform float epsilon;\nuniform float phi;\nvarying vec2 v_coord;\n\nfloat cosh(float val)\n{\n\tfloat tmp = exp(val);\n\tfloat cosH = (tmp + 1.0 / tmp) / 2.0;\n\treturn cosH;\n}\n\nfloat tanh(float val)\n{\n\tfloat tmp = exp(val);\n\tfloat tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n\treturn tanH;\n}\n\nfloat sinh(float val)\n{\n\tfloat tmp = exp(val);\n\tfloat sinH = (tmp - 1.0 / tmp) / 2.0;\n\treturn sinH;\n}\n\nvoid main(void){\n\tvec3 destColor = vec3(0.0);\n\tfloat tFrag = 1.0 / cvsHeight;\n\tfloat sFrag = 1.0 / cvsWidth;\n\tvec2 Frag = vec2(sFrag,tFrag);\n\tvec2 uv = gl_FragCoord.st;\n\tfloat twoSigmaESquared = 2.0 * sigma * sigma;\n\tfloat twoSigmaRSquared = twoSigmaESquared * k * k;\n\tint halfWidth = int(ceil( 1.0 * sigma * k ));\n\n\tconst int MAX_NUM_ITERATION = 99999;\n\tvec2 sum = vec2(0.0);\n\tvec2 norm = vec2(0.0);\n\n\tfor(int cnt=0;cnt<MAX_NUM_ITERATION;cnt++){\n\t\tif(cnt > (2*halfWidth+1)*(2*halfWidth+1)){break;}\n\t\tint i = int(cnt / (2*halfWidth+1)) - halfWidth;\n\t\tint j = cnt - halfWidth - int(cnt / (2*halfWidth+1)) * (2*halfWidth+1);\n\n\t\tfloat d = length(vec2(i,j));\n\t\tvec2 kernel = vec2( exp( -d * d / twoSigmaESquared ), \n\t\t\t\t\t\t\texp( -d * d / twoSigmaRSquared ));\n\n\t\tvec2 L = texture2D(src, (uv + vec2(i,j)) * Frag).xx;\n\n\t\tnorm += kernel;\n\t\tsum += kernel * L;\n\t}\n\n\tsum /= norm;\n\n\tfloat H = 100.0 * ((1.0 + p) * sum.x - p * sum.y);\n\tfloat edge = ( H > epsilon )? 1.0 : 1.0 + tanh( phi * (H - epsilon));\n\tdestColor = vec3(edge);\n\tgl_FragColor = vec4(destColor, 1.0);\n}", 
  L.registerNodeType("texture/xDoG", M), C.title = "Webcam", C.desc = "Webcam texture", C.is_webcam_open = !1, C.prototype.openStream = function() {
    if (navigator.getUserMedia) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!1, video:{facingMode:this.properties.facingMode}}).then(this.streamReady.bind(this)).catch(function(b) {
        C.is_webcam_open = !1;
        console.log("Webcam rejected", b);
        a._webcam_stream = !1;
        a.boxcolor = "red";
        a.trigger("stream_error");
      });
      var a = this;
    }
  }, C.prototype.closeStream = function() {
    if (this._webcam_stream) {
      var a = this._webcam_stream.getTracks();
      if (a.length) {
        for (var b = 0; b < a.length; ++b) {
          a[b].stop();
        }
      }
      C.is_webcam_open = !1;
      this._video = this._webcam_stream = null;
      this.boxcolor = "black";
      this.trigger("stream_closed");
    }
  }, C.prototype.streamReady = function(a) {
    this._webcam_stream = a;
    this.boxcolor = "green";
    var b = this._video;
    b || (b = document.createElement("video"), b.autoplay = !0, b.srcObject = a, this._video = b, b.onloadedmetadata = function(a) {
      C.is_webcam_open = !0;
      console.log(a);
    });
    this.trigger("stream_ready", b);
  }, C.prototype.onPropertyChanged = function(a, b) {
    "facingMode" == a && (this.properties.facingMode = b, this.closeStream(), this.openStream());
  }, C.prototype.onRemoved = function() {
    if (this._webcam_stream) {
      var a = this._webcam_stream.getTracks();
      if (a.length) {
        for (var b = 0; b < a.length; ++b) {
          a[b].stop();
        }
      }
      this._video = this._webcam_stream = null;
    }
  }, C.prototype.onDrawBackground = function(a) {
    this.flags.collapsed || 20 >= this.size[1] || !this._video || (a.save(), a.webgl ? this._video_texture && a.drawImage(this._video_texture, 0, 0, this.size[0], this.size[1]) : a.drawImage(this._video, 0, 0, this.size[0], this.size[1]), a.restore());
  }, C.prototype.onExecute = function() {
    null != this._webcam_stream || this._waiting_confirmation || this.openStream();
    if (this._video && this._video.videoWidth) {
      var a = this._video.videoWidth, b = this._video.videoHeight, d = this._video_texture;
      d && d.width == a && d.height == b || (this._video_texture = new GL.Texture(a, b, {format:gl.RGB, filter:gl.LINEAR}));
      this._video_texture.uploadImage(this._video);
      this._video_texture.version = ++this.version;
      this.properties.texture_name && (c.getTexturesContainer()[this.properties.texture_name] = this._video_texture);
      this.setOutputData(0, this._video_texture);
      for (a = 1; a < this.outputs.length; ++a) {
        if (this.outputs[a]) {
          switch(this.outputs[a].name) {
            case "width":
              this.setOutputData(a, this._video.videoWidth);
              break;
            case "height":
              this.setOutputData(a, this._video.videoHeight);
          }
        }
      }
    }
  }, C.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["stream_ready", L.EVENT], ["stream_closed", L.EVENT], ["stream_error", L.EVENT]];
  }, L.registerNodeType("texture/webcam", C), J.title = "Lens FX", J.desc = "distortion and chromatic aberration", J.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, J.prototype.onGetInputs = function() {
    return [["enabled", "boolean"]];
  }, J.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      if (this.properties.precision === c.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
        this.setOutputData(0, a);
      } else {
        var b = this._temp_texture;
        b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
        var d = J._shader;
        d || (d = J._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, J.pixel_shader));
        var f = this.getInputData(1);
        null == f && (f = this.properties.factor);
        var h = this._uniforms;
        h.u_factor = f;
        gl.disable(gl.DEPTH_TEST);
        b.drawTo(function() {
          a.bind(0);
          d.uniforms(h).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, b);
      }
    }
  }, J.pixel_shader = "precision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform float u_factor;\n\t\tvec2 barrelDistortion(vec2 coord, float amt) {\n\t\t\tvec2 cc = coord - 0.5;\n\t\t\tfloat dist = dot(cc, cc);\n\t\t\treturn coord + cc * dist * amt;\n\t\t}\n\t\t\n\t\tfloat sat( float t )\n\t\t{\n\t\t\treturn clamp( t, 0.0, 1.0 );\n\t\t}\n\t\t\n\t\tfloat linterp( float t ) {\n\t\t\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n\t\t}\n\t\t\n\t\tfloat remap( float t, float a, float b ) {\n\t\t\treturn sat( (t - a) / (b - a) );\n\t\t}\n\t\t\n\t\tvec4 spectrum_offset( float t ) {\n\t\t\tvec4 ret;\n\t\t\tfloat lo = step(t,0.5);\n\t\t\tfloat hi = 1.0-lo;\n\t\t\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\t\t\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\t\t\n\t\t\treturn pow( ret, vec4(1.0/2.2) );\n\t\t}\n\t\t\n\t\tconst float max_distort = 2.2;\n\t\tconst int num_iter = 12;\n\t\tconst float reci_num_iter_f = 1.0 / float(num_iter);\n\t\t\n\t\tvoid main()\n\t\t{\t\n\t\t\tvec2 uv=v_coord;\n\t\t\tvec4 sumcol = vec4(0.0);\n\t\t\tvec4 sumw = vec4(0.0);\t\n\t\t\tfor ( int i=0; i<num_iter;++i )\n\t\t\t{\n\t\t\t\tfloat t = float(i) * reci_num_iter_f;\n\t\t\t\tvec4 w = spectrum_offset( t );\n\t\t\t\tsumw += w;\n\t\t\t\tsumcol += w * texture2D( u_texture, barrelDistortion(uv, .6 * max_distort*t * u_factor ) );\n\t\t\t}\n\t\t\tgl_FragColor = sumcol / sumw;\n\t\t}", 
  L.registerNodeType("texture/lensfx", J), E.title = "Data->Tex", E.desc = "Generates or applies a curve to a texture", E.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, E.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (a) {
        var b = this.properties.channels, d = this.properties.width, f = this.properties.height;
        d && f || (d = Math.floor(a.length / b), f = 1);
        var h = gl.RGBA;
        3 == b ? h = gl.RGB : 1 == b && (h = gl.LUMINANCE);
        b = this._temp_texture;
        var k = c.getTextureType(this.properties.precision);
        b && b.width == d && b.height == f && b.type == k || (b = this._temp_texture = new GL.Texture(d, f, {type:k, format:h, filter:gl.LINEAR}));
        b.uploadData(a);
        this.setOutputData(0, b);
      }
    }
  }, L.registerNodeType("texture/fromdata", E), I.title = "Curve", I.desc = "Generates or applies a curve to a texture", I.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, I.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0), b = this._temp_texture;
      if (a) {
        var d = c.getTextureType(this.properties.precision, a);
        b && b.type == d && b.width == a.width && b.height == a.height && b.format == a.format || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:d, format:a.format, filter:gl.LINEAR}));
        var f = I._shader;
        f || (f = I._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, I.pixel_shader));
        !this._must_update && this._curve_texture || this.updateCurve();
        var h = this._uniforms, k = this._curve_texture;
        b.drawTo(function() {
          gl.disable(gl.DEPTH_TEST);
          a.bind(0);
          k.bind(1);
          f.uniforms(h).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, b);
      } else {
        !this._must_update && this._curve_texture || this.updateCurve(), this.setOutputData(0, this._curve_texture);
      }
    }
  }, I.prototype.sampleCurve = function(a, b) {
    if (b = b || this._points.RGB) {
      for (var d = 0; d < b.length - 1; ++d) {
        var c = b[d], f = b[d + 1];
        if (!(f[0] < a)) {
          b = f[0] - c[0];
          if (0.00001 > Math.abs(b)) {
            return c[1];
          }
          a = (a - c[0]) / b;
          return c[1] * (1.0 - a) + f[1] * a;
        }
      }
      return 0;
    }
  }, I.prototype.updateCurve = function() {
    for (var a = this._values, b = a.length / 4, d = this.properties.split_channels, c = 0; c < b; ++c) {
      if (d) {
        a[4 * c] = Math.clamp(255 * this.sampleCurve(c / b, this._points.R), 0, 255), a[4 * c + 1] = Math.clamp(255 * this.sampleCurve(c / b, this._points.G), 0, 255), a[4 * c + 2] = Math.clamp(255 * this.sampleCurve(c / b, this._points.B), 0, 255);
      } else {
        var f = this.sampleCurve(c / b);
        a[4 * c] = a[4 * c + 1] = a[4 * c + 2] = Math.clamp(255 * f, 0, 255);
      }
      a[4 * c + 3] = 255;
    }
    this._curve_texture || (this._curve_texture = new GL.Texture(256, 1, {format:gl.RGBA, magFilter:gl.LINEAR, wrap:gl.CLAMP_TO_EDGE}));
    this._curve_texture.uploadData(a, null, !0);
  }, I.prototype.onSerialize = function(a) {
    var b = {}, d;
    for (d in this._points) {
      b[d] = this._points[d].concat();
    }
    a.curves = b;
  }, I.prototype.onConfigure = function(a) {
    this._points = a.curves;
    this.curve_editor && (curve_editor.points = this._points);
    this._must_update = !0;
  }, I.prototype.onMouseDown = function(a, b, d) {
    if (this.curve_editor) {
      return (a = this.curve_editor.onMouseDown([b[0], b[1] - this.curve_offset], d)) && this.captureInput(!0), a;
    }
  }, I.prototype.onMouseMove = function(a, b, d) {
    if (this.curve_editor) {
      return this.curve_editor.onMouseMove([b[0], b[1] - this.curve_offset], d);
    }
  }, I.prototype.onMouseUp = function(a, b, d) {
    if (this.curve_editor) {
      return this.curve_editor.onMouseUp([b[0], b[1] - this.curve_offset], d);
    }
    this.captureInput(!1);
  }, I.channel_line_colors = {RGB:"#666", R:"#F33", G:"#3F3", B:"#33F"}, I.prototype.onDrawBackground = function(a, b) {
    if (!this.flags.collapsed) {
      this.curve_editor || (this.curve_editor = new L.CurveEditor(this._points.R));
      a.save();
      a.translate(0, this.curve_offset);
      var d = this.widgets[1].value;
      this.properties.split_channels ? ("RGB" == d && (this.widgets[1].value = d = "R", this.widgets[1].disabled = !1), this.curve_editor.points = this._points.R, this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, "#111", I.channel_line_colors.R, !0), a.globalCompositeOperation = "lighten", this.curve_editor.points = this._points.G, this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, null, I.channel_line_colors.G, !0), this.curve_editor.points = 
      this._points.B, this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, null, I.channel_line_colors.B, !0), a.globalCompositeOperation = "source-over") : (this.widgets[1].value = d = "RGB", this.widgets[1].disabled = !0);
      this.curve_editor.points = this._points[d];
      this.curve_editor.draw(a, [this.size[0], this.size[1] - this.curve_offset], b, this.properties.split_channels ? null : "#111", I.channel_line_colors[d]);
      a.restore();
    }
  }, I.pixel_shader = "precision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform sampler2D u_curve;\n\t\tuniform float u_range;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D( u_texture, v_coord ) * u_range;\n\t\t\tcolor.x = texture2D( u_curve, vec2( color.x, 0.5 ) ).x;\n\t\t\tcolor.y = texture2D( u_curve, vec2( color.y, 0.5 ) ).y;\n\t\t\tcolor.z = texture2D( u_curve, vec2( color.z, 0.5 ) ).z;\n\t\t\t//color.w = texture2D( u_curve, vec2( color.w, 0.5 ) ).w;\n\t\t\tgl_FragColor = color;\n\t\t}", 
  L.registerNodeType("texture/curve", I), P.title = "Exposition", P.desc = "Controls texture exposition", P.widgets_info = {exposition:{widget:"slider", min:0, max:3}, precision:{widget:"combo", values:c.MODE_VALUES}}, P.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      var b = this._temp_texture;
      b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
      var d = P._shader;
      d || (d = P._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, P.pixel_shader));
      var c = this.getInputData(1);
      null != c && (this.properties.exposition = c);
      var f = this._uniforms;
      b.drawTo(function() {
        gl.disable(gl.DEPTH_TEST);
        a.bind(0);
        d.uniforms(f).draw(GL.Mesh.getScreenQuad());
      });
      this.setOutputData(0, b);
    }
  }, P.pixel_shader = "precision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform float u_exposition;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D( u_texture, v_coord );\n\t\t\tgl_FragColor = vec4( color.xyz * u_exposition, color.a );\n\t\t}", L.registerNodeType("texture/exposition", P), Q.title = "Tone Mapping", Q.desc = "Applies Tone Mapping to convert from high to low", Q.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}}, Q.prototype.onGetInputs = 
  function() {
    return [["enabled", "boolean"]];
  }, Q.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      if (this.properties.precision === c.PASS_THROUGH || !1 === this.getInputOrProperty("enabled")) {
        this.setOutputData(0, a);
      } else {
        var b = this._temp_texture;
        b && b.width == a.width && b.height == a.height && b.type == a.type || (b = this._temp_texture = new GL.Texture(a.width, a.height, {type:a.type, format:gl.RGBA, filter:gl.LINEAR}));
        var d = this.getInputData(1);
        null == d && (d = this.properties.average_lum);
        var f = this._uniforms, h = null;
        d.constructor === Number ? (this.properties.average_lum = d, f.u_average_lum = this.properties.average_lum, h = Q._shader, h || (h = Q._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, Q.pixel_shader))) : d.constructor === GL.Texture && (f.u_average_texture = d.bind(1), h = Q._shader_texture, h || (h = Q._shader_texture = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, Q.pixel_shader, {AVG_TEXTURE:""})));
        f.u_lumwhite2 = this.properties.lum_white * this.properties.lum_white;
        f.u_scale = this.properties.scale;
        f.u_igamma = 1 / this.properties.gamma;
        gl.disable(gl.DEPTH_TEST);
        b.drawTo(function() {
          a.bind(0);
          h.uniforms(f).draw(GL.Mesh.getScreenQuad());
        });
        this.setOutputData(0, this._temp_texture);
      }
    }
  }, Q.pixel_shader = "precision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform float u_scale;\n\t\t#ifdef AVG_TEXTURE\n\t\t\tuniform sampler2D u_average_texture;\n\t\t#else\n\t\t\tuniform float u_average_lum;\n\t\t#endif\n\t\tuniform float u_lumwhite2;\n\t\tuniform float u_igamma;\n\t\tvec3 RGB2xyY (vec3 rgb)\n\t\t{\n\t\t\t const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805,\n\t\t\t\t\t\t\t\t\t   0.2126, 0.7152, 0.0722,\n\t\t\t\t\t\t\t\t\t   0.0193, 0.1192, 0.9505);\n\t\t\tvec3 XYZ = RGB2XYZ * rgb;\n\t\t\t\n\t\t\tfloat f = (XYZ.x + XYZ.y + XYZ.z);\n\t\t\treturn vec3(XYZ.x / f,\n\t\t\t\t\t\tXYZ.y / f,\n\t\t\t\t\t\tXYZ.y);\n\t\t}\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D( u_texture, v_coord );\n\t\t\tvec3 rgb = color.xyz;\n\t\t\tfloat average_lum = 0.0;\n\t\t\t#ifdef AVG_TEXTURE\n\t\t\t\tvec3 pixel = texture2D(u_average_texture,vec2(0.5)).xyz;\n\t\t\t\taverage_lum = (pixel.x + pixel.y + pixel.z) / 3.0;\n\t\t\t#else\n\t\t\t\taverage_lum = u_average_lum;\n\t\t\t#endif\n\t\t\t//Ld - this part of the code is the same for both versions\n\t\t\tfloat lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));\n\t\t\tfloat L = (u_scale / average_lum) * lum;\n\t\t\tfloat Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);\n\t\t\t//first\n\t\t\t//vec3 xyY = RGB2xyY(rgb);\n\t\t\t//xyY.z *= Ld;\n\t\t\t//rgb = xyYtoRGB(xyY);\n\t\t\t//second\n\t\t\trgb = (rgb / lum) * Ld;\n\t\t\trgb = max(rgb,vec3(0.001));\n\t\t\trgb = pow( rgb, vec3( u_igamma ) );\n\t\t\tgl_FragColor = vec4( rgb, color.a );\n\t\t}", 
  L.registerNodeType("texture/tonemapping", Q), S.title = "Perlin", S.desc = "Generates a perlin noise texture", S.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}, width:{type:"number", precision:0, step:1}, height:{type:"number", precision:0, step:1}, octaves:{type:"number", precision:0, step:1, min:1, max:50}}, S.prototype.onGetInputs = function() {
    return [["seed", "number"], ["persistence", "number"], ["octaves", "number"], ["scale", "number"], ["amplitude", "number"], ["offset", "vec2"]];
  }, S.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.properties.width | 0, b = this.properties.height | 0;
      0 == a && (a = gl.viewport_data[2]);
      0 == b && (b = gl.viewport_data[3]);
      var d = c.getTextureType(this.properties.precision), f = this._texture;
      f && f.width == a && f.height == b && f.type == d || (f = this._texture = new GL.Texture(a, b, {type:d, format:gl.RGB, filter:gl.LINEAR}));
      var h = this.getInputOrProperty("persistence"), k = this.getInputOrProperty("octaves"), e = this.getInputOrProperty("offset"), g = this.getInputOrProperty("scale"), t = this.getInputOrProperty("amplitude"), q = this.getInputOrProperty("seed");
      d = "" + a + b + d + h + k + g + q + e[0] + e[1] + t;
      if (d != this._key) {
        this._key = d;
        var l = this._uniforms;
        l.u_persistence = h;
        l.u_octaves = k;
        l.u_offset.set(e);
        l.u_scale = g;
        l.u_amplitude = t;
        l.u_seed = 128 * q;
        l.u_viewport[0] = a;
        l.u_viewport[1] = b;
        var I = S._shader;
        I || (I = S._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, S.pixel_shader));
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        f.drawTo(function() {
          I.uniforms(l).draw(GL.Mesh.getScreenQuad());
        });
      }
      this.setOutputData(0, f);
    }
  }, S.pixel_shader = "precision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform vec2 u_offset;\n\t\tuniform float u_scale;\n\t\tuniform float u_persistence;\n\t\tuniform int u_octaves;\n\t\tuniform float u_amplitude;\n\t\tuniform vec2 u_viewport;\n\t\tuniform float u_seed;\n\t\t#define M_PI 3.14159265358979323846\n\t\t\n\t\tfloat rand(vec2 c){\treturn fract(sin(dot(c.xy ,vec2( 12.9898 + u_seed,78.233 + u_seed))) * 43758.5453); }\n\t\t\n\t\tfloat noise(vec2 p, float freq ){\n\t\t\tfloat unit = u_viewport.x/freq;\n\t\t\tvec2 ij = floor(p/unit);\n\t\t\tvec2 xy = mod(p,unit)/unit;\n\t\t\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\t\t\txy = .5*(1.-cos(M_PI*xy));\n\t\t\tfloat a = rand((ij+vec2(0.,0.)));\n\t\t\tfloat b = rand((ij+vec2(1.,0.)));\n\t\t\tfloat c = rand((ij+vec2(0.,1.)));\n\t\t\tfloat d = rand((ij+vec2(1.,1.)));\n\t\t\tfloat x1 = mix(a, b, xy.x);\n\t\t\tfloat x2 = mix(c, d, xy.x);\n\t\t\treturn mix(x1, x2, xy.y);\n\t\t}\n\t\t\n\t\tfloat pNoise(vec2 p, int res){\n\t\t\tfloat persistance = u_persistence;\n\t\t\tfloat n = 0.;\n\t\t\tfloat normK = 0.;\n\t\t\tfloat f = 4.;\n\t\t\tfloat amp = 1.0;\n\t\t\tint iCount = 0;\n\t\t\tfor (int i = 0; i<50; i++){\n\t\t\t\tn+=amp*noise(p, f);\n\t\t\t\tf*=2.;\n\t\t\t\tnormK+=amp;\n\t\t\t\tamp*=persistance;\n\t\t\t\tif (iCount >= res)\n\t\t\t\t\tbreak;\n\t\t\t\tiCount++;\n\t\t\t}\n\t\t\tfloat nf = n/normK;\n\t\t\treturn nf*nf*nf*nf;\n\t\t}\n\t\tvoid main() {\n\t\t\tvec2 uv = v_coord * u_scale * u_viewport + u_offset * u_scale;\n\t\t\tvec4 color = vec4( pNoise( uv, u_octaves ) * u_amplitude );\n\t\t\tgl_FragColor = color;\n\t\t}", 
  L.registerNodeType("texture/perlin", S), R.title = "Canvas2D", R.desc = "Executes Canvas2D code inside a texture or the viewport.", R.help = "Set width and height to 0 to match viewport size.", R.default_code = "//vars: canvas,ctx,time\nctx.fillStyle='red';\nctx.fillRect(0,0,50,50);\n", R.widgets_info = {precision:{widget:"combo", values:c.MODE_VALUES}, code:{type:"code"}, width:{type:"number", precision:0, step:1}, height:{type:"number", precision:0, step:1}}, R.prototype.onPropertyChanged = function(a, 
  b) {
    "code" == a && this.compileCode(b);
  }, R.prototype.compileCode = function(a) {
    this._func = null;
    if (L.allow_scripts) {
      try {
        this._func = new Function("canvas", "ctx", "time", "script", "v", a), this.boxcolor = "#00FF00";
      } catch (X) {
        this.boxcolor = "#FF0000", console.error("Error parsing script"), console.error(X);
      }
    }
  }, R.prototype.onExecute = function() {
    var a = this._func;
    a && this.isOutputConnected(0) && this.executeDraw(a);
  }, R.prototype.executeDraw = function(a) {
    var b = this.properties.width || gl.canvas.width, d = this.properties.height || gl.canvas.height, f = this._temp_texture, h = c.getTextureType(this.properties.precision);
    f && f.width == b && f.height == d && f.type == h || (f = this._temp_texture = new GL.Texture(b, d, {format:gl.RGBA, filter:gl.LINEAR, type:h}));
    var k = this.getInputData(0), e = this.properties, g = this, t = this.graph.getTime(), q = gl, l = gl.canvas;
    if (this.properties.use_html_canvas || !y.enableWebGLCanvas) {
      this._canvas ? (l = this._canvas, q = this._ctx) : (l = this._canvas = createCanvas(b.height), q = this._ctx = l.getContext("2d")), l.width = b, l.height = d;
    }
    if (q == gl) {
      f.drawTo(function() {
        gl.start2D();
        e.clear && (gl.clearColor(0, 0, 0, 0), gl.clear(gl.COLOR_BUFFER_BIT));
        try {
          a.draw ? a.draw.call(g, l, q, t, a, k) : a.call(g, l, q, t, a, k), g.boxcolor = "#00FF00";
        } catch (V) {
          g.boxcolor = "#FF0000", console.error("Error executing script"), console.error(V);
        }
        gl.finish2D();
      });
    } else {
      e.clear && q.clearRect(0, 0, l.width, l.height);
      try {
        a.draw ? a.draw.call(this, l, q, t, a, k) : a.call(this, l, q, t, a, k), this.boxcolor = "#00FF00";
      } catch (V) {
        this.boxcolor = "#FF0000", console.error("Error executing script"), console.error(V);
      }
      f.uploadImage(l);
    }
    this.setOutputData(0, f);
  }, L.registerNodeType("texture/canvas2D", R), T.title = "Matte", T.desc = "Extracts background", T.widgets_info = {key_color:{widget:"color"}, precision:{widget:"combo", values:c.MODE_VALUES}}, T.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (this.properties.precision === c.PASS_THROUGH) {
        this.setOutputData(0, a);
      } else {
        if (a) {
          this._tex = c.getTargetTexture(a, this._tex, this.properties.precision);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          this._uniforms || (this._uniforms = {u_texture:0, u_key_color:this.properties.key_color, u_threshold:1, u_slope:1});
          var b = this._uniforms, d = Mesh.getScreenQuad(), f = T._shader;
          f || (f = T._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, T.pixel_shader));
          b.u_key_color = this.properties.key_color;
          b.u_threshold = this.properties.threshold;
          b.u_slope = this.properties.slope;
          this._tex.drawTo(function() {
            a.bind(0);
            f.uniforms(b).draw(d);
          });
          this.setOutputData(0, this._tex);
        }
      }
    }
  }, T.pixel_shader = "precision highp float;\n\t\tvarying vec2 v_coord;\n\t\tuniform sampler2D u_texture;\n\t\tuniform vec3 u_key_color;\n\t\tuniform float u_threshold;\n\t\tuniform float u_slope;\n\t\t\n\t\tvoid main() {\n\t\t\tvec3 color = texture2D( u_texture, v_coord ).xyz;\n\t\t\tfloat diff = length( normalize(color) - normalize(u_key_color) );\n\t\t\tfloat edge = u_threshold * (1.0 - u_slope);\n\t\t\tfloat alpha = smoothstep( edge, u_threshold, diff);\n\t\t\tgl_FragColor = vec4( color, alpha );\n\t\t}", 
  L.registerNodeType("texture/matte", T), U.title = "CubemapToTexture2D", U.desc = "Transforms a CUBEMAP texture into a TEXTURE2D in Polar Representation", U.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputData(0);
      if (a && a.texture_type == GL.TEXTURE_CUBE_MAP) {
        !this._last_tex || this._last_tex.height == a.height && this._last_tex.type == a.type || (this._last_tex = null);
        var b = this.getInputOrProperty("yaw");
        this._last_tex = GL.Texture.cubemapToTexture2D(a, a.height, this._last_tex, !0, b);
        this.setOutputData(0, this._last_tex);
      }
    }
  }, L.registerNodeType("texture/cubemapToTexture2D", U));
})(this);
(function(y) {
  var c = y.LiteGraph, g = y.LGraphTexture;
  if ("undefined" != typeof GL) {
    var n = function() {
      this.addInput("Tex.", "Texture");
      this.addInput("intensity", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {intensity:1, invert:!1, precision:g.DEFAULT};
      n._shader || (n._shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, n.pixel_shader));
    }, m = function() {
      this.addInput("Texture", "Texture");
      this.addInput("value1", "number");
      this.addInput("value2", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {fx:"halftone", value1:1, value2:1, precision:g.DEFAULT};
    }, u = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Blurred", "Texture");
      this.addInput("Mask", "Texture");
      this.addInput("Threshold", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {shape:"", size:10, alpha:1.0, threshold:1.0, high_precision:!1};
    }, l = function() {
      this.addInput("Texture", "Texture");
      this.addInput("Aberration", "number");
      this.addInput("Distortion", "number");
      this.addInput("Blur", "number");
      this.addOutput("Texture", "Texture");
      this.properties = {aberration:1.0, distortion:1.0, blur:1.0, precision:g.DEFAULT};
      l._shader || (l._shader = new GL.Shader(GL.Shader.SCREEN_VERTEX_SHADER, l.pixel_shader), l._texture = new GL.Texture(3, 1, {format:gl.RGB, wrap:gl.CLAMP_TO_EDGE, magFilter:gl.LINEAR, minFilter:gl.LINEAR, pixel_data:[255, 0, 0, 0, 255, 0, 0, 0, 255]}));
    };
    l.title = "Lens";
    l.desc = "Camera Lens distortion";
    l.widgets_info = {precision:{widget:"combo", values:g.MODE_VALUES}};
    l.prototype.onExecute = function() {
      var c = this.getInputData(0);
      if (this.properties.precision === g.PASS_THROUGH) {
        this.setOutputData(0, c);
      } else {
        if (c) {
          this._tex = g.getTargetTexture(c, this._tex, this.properties.precision);
          var m = this.properties.aberration;
          this.isInputConnected(1) && (m = this.getInputData(1), this.properties.aberration = m);
          var n = this.properties.distortion;
          this.isInputConnected(2) && (n = this.getInputData(2), this.properties.distortion = n);
          var u = this.properties.blur;
          this.isInputConnected(3) && (u = this.getInputData(3), this.properties.blur = u);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var y = Mesh.getScreenQuad(), e = l._shader;
          this._tex.drawTo(function() {
            c.bind(0);
            e.uniforms({u_texture:0, u_aberration:m, u_distortion:n, u_blur:u}).draw(y);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    l.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform float u_aberration;\n\r\n\t\t\tuniform float u_distortion;\n\r\n\t\t\tuniform float u_blur;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = v_coord;\n\r\n\t\t\t\tfloat dist = distance(vec2(0.5), coord);\n\r\n\t\t\t\tvec2 dist_coord = coord - vec2(0.5);\n\r\n\t\t\t\tfloat percent = 1.0 + ((0.5 - dist) / 0.5) * u_distortion;\n\r\n\t\t\t\tdist_coord *= percent;\n\r\n\t\t\t\tcoord = dist_coord + vec2(0.5);\n\r\n\t\t\t\tvec4 color = texture2D(u_texture,coord, u_blur * dist);\n\r\n\t\t\t\tcolor.r = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0+0.01*u_aberration), u_blur * dist ).r;\n\r\n\t\t\t\tcolor.b = texture2D(u_texture,vec2(0.5) + dist_coord * (1.0-0.01*u_aberration), u_blur * dist ).b;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n\r\n\t\t\t";
    c.registerNodeType("fx/lens", l);
    y.LGraphFXLens = l;
    u.title = "Bokeh";
    u.desc = "applies an Bokeh effect";
    u.widgets_info = {shape:{widget:"texture"}};
    u.prototype.onExecute = function() {
      var c = this.getInputData(0), l = this.getInputData(1), m = this.getInputData(2);
      if (c && m && this.properties.shape) {
        l || (l = c);
        var n = g.getTexture(this.properties.shape);
        if (n) {
          var y = this.properties.threshold;
          this.isInputConnected(3) && (y = this.getInputData(3), this.properties.threshold = y);
          var e = gl.UNSIGNED_BYTE;
          this.properties.high_precision && (e = gl.half_float_ext ? gl.HALF_FLOAT_OES : gl.FLOAT);
          this._temp_texture && this._temp_texture.type == e && this._temp_texture.width == c.width && this._temp_texture.height == c.height || (this._temp_texture = new GL.Texture(c.width, c.height, {type:e, format:gl.RGBA, filter:gl.LINEAR}));
          var z = u._first_shader;
          z || (z = u._first_shader = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, u._first_pixel_shader));
          var H = u._second_shader;
          H || (H = u._second_shader = new GL.Shader(u._second_vertex_shader, u._second_pixel_shader));
          var x = this._points_mesh;
          x && x._width == c.width && x._height == c.height && 2 == x._spacing || (x = this.createPointsMesh(c.width, c.height, 2));
          var K = Mesh.getScreenQuad(), k = this.properties.size, q = this.properties.alpha;
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.BLEND);
          this._temp_texture.drawTo(function() {
            c.bind(0);
            l.bind(1);
            m.bind(2);
            z.uniforms({u_texture:0, u_texture_blur:1, u_mask:2, u_texsize:[c.width, c.height]}).draw(K);
          });
          this._temp_texture.drawTo(function() {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE);
            c.bind(0);
            n.bind(3);
            H.uniforms({u_texture:0, u_mask:2, u_shape:3, u_alpha:q, u_threshold:y, u_pointSize:k, u_itexsize:[1.0 / c.width, 1.0 / c.height]}).draw(x, gl.POINTS);
          });
          this.setOutputData(0, this._temp_texture);
        }
      } else {
        this.setOutputData(0, c);
      }
    };
    u.prototype.createPointsMesh = function(c, g, l) {
      for (var m = Math.round(c / l), n = Math.round(g / l), e = new Float32Array(m * n * 2), z = -1, u = 2 / c * l, x = 2 / g * l, y = 0; y < n; ++y) {
        for (var k = -1, q = 0; q < m; ++q) {
          var t = y * m * 2 + 2 * q;
          e[t] = k;
          e[t + 1] = z;
          k += u;
        }
        z += x;
      }
      this._points_mesh = GL.Mesh.load({vertices2D:e});
      this._points_mesh._width = c;
      this._points_mesh._height = g;
      this._points_mesh._spacing = l;
      return this._points_mesh;
    };
    u._first_pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_texture_blur;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec4 blurred_color = texture2D(u_texture_blur, v_coord);\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, v_coord).x;\n\r\n\t\t\t   gl_FragColor = mix(color, blurred_color, mask);\n\r\n\t\t\t}\n\r\n\t\t\t";
    u._second_vertex_shader = "precision highp float;\n\r\n\t\t\tattribute vec2 a_vertex2D;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_mask;\n\r\n\t\t\tuniform vec2 u_itexsize;\n\r\n\t\t\tuniform float u_pointSize;\n\r\n\t\t\tuniform float u_threshold;\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = a_vertex2D * 0.5 + 0.5;\n\r\n\t\t\t\tv_color = texture2D( u_texture, coord );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(u_itexsize.x, 0.0) );\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + vec2(0.0, u_itexsize.y));\n\r\n\t\t\t\tv_color += texture2D( u_texture, coord + u_itexsize);\n\r\n\t\t\t\tv_color *= 0.25;\n\r\n\t\t\t\tfloat mask = texture2D(u_mask, coord).x;\n\r\n\t\t\t\tfloat luminance = length(v_color) * mask;\n\r\n\t\t\t\t/*luminance /= (u_pointSize*u_pointSize)*0.01 */;\n\r\n\t\t\t\tluminance -= u_threshold;\n\r\n\t\t\t\tif(luminance < 0.0)\n\r\n\t\t\t\t{\n\r\n\t\t\t\t\tgl_Position.x = -100.0;\n\r\n\t\t\t\t\treturn;\n\r\n\t\t\t\t}\n\r\n\t\t\t\tgl_PointSize = u_pointSize;\n\r\n\t\t\t\tgl_Position = vec4(a_vertex2D,0.0,1.0);\n\r\n\t\t\t}\n\r\n\t\t\t";
    u._second_pixel_shader = "precision highp float;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t\tuniform sampler2D u_shape;\n\r\n\t\t\tuniform float u_alpha;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D( u_shape, gl_PointCoord );\n\r\n\t\t\t\tcolor *= v_color * u_alpha;\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
    c.registerNodeType("fx/bokeh", u);
    y.LGraphFXBokeh = u;
    m.title = "FX";
    m.desc = "applies an FX from a list";
    m.widgets_info = {fx:{widget:"combo", values:["halftone", "pixelate", "lowpalette", "noise", "gamma"]}, precision:{widget:"combo", values:g.MODE_VALUES}};
    m.shaders = {};
    m.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var c = this.getInputData(0);
        if (this.properties.precision === g.PASS_THROUGH) {
          this.setOutputData(0, c);
        } else {
          if (c) {
            this._tex = g.getTargetTexture(c, this._tex, this.properties.precision);
            var l = this.properties.value1;
            this.isInputConnected(1) && (l = this.getInputData(1), this.properties.value1 = l);
            var n = this.properties.value2;
            this.isInputConnected(2) && (n = this.getInputData(2), this.properties.value2 = n);
            var u = this.properties.fx, F = m.shaders[u];
            if (!F) {
              var e = m["pixel_shader_" + u];
              if (!e) {
                return;
              }
              F = m.shaders[u] = new GL.Shader(Shader.SCREEN_VERTEX_SHADER, e);
            }
            gl.disable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            var z = Mesh.getScreenQuad();
            var H = y.LS && LS.Renderer._current_camera ? [LS.Renderer._current_camera.near, LS.Renderer._current_camera.far] : [1, 100];
            var x = null;
            "noise" == u && (x = g.getNoiseTexture());
            this._tex.drawTo(function() {
              c.bind(0);
              "noise" == u && x.bind(1);
              F.uniforms({u_texture:0, u_noise:1, u_size:[c.width, c.height], u_rand:[Math.random(), Math.random()], u_value1:l, u_value2:n, u_camera_planes:H}).draw(z);
            });
            this.setOutputData(0, this._tex);
          }
        }
      }
    };
    m.pixel_shader_halftone = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tfloat pattern() {\n\r\n\t\t\t\tfloat s = sin(u_value1 * 3.1415), c = cos(u_value1 * 3.1415);\n\r\n\t\t\t\tvec2 tex = v_coord * u_size.xy;\n\r\n\t\t\t\tvec2 point = vec2(\n\r\n\t\t\t\t   c * tex.x - s * tex.y ,\n\r\n\t\t\t\t   s * tex.x + c * tex.y \n\r\n\t\t\t\t) * u_value2;\n\r\n\t\t\t\treturn (sin(point.x) * sin(point.y)) * 4.0;\n\r\n\t\t\t}\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat average = (color.r + color.g + color.b) / 3.0;\n\r\n\t\t\t\tgl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\r\n\t\t\t}\n";
    m.pixel_shader_pixelate = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec2 coord = vec2( floor(v_coord.x * u_value1) / u_value1, floor(v_coord.y * u_value2) / u_value2 );\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, coord);\n\r\n\t\t\t\tgl_FragColor = color;\n\r\n\t\t\t}\n";
    m.pixel_shader_lowpalette = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform vec2 u_camera_planes;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tgl_FragColor = floor(color * u_value1) / u_value1;\n\r\n\t\t\t}\n";
    m.pixel_shader_noise = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform sampler2D u_noise;\n\r\n\t\t\tuniform vec2 u_size;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\tuniform float u_value2;\n\r\n\t\t\tuniform vec2 u_rand;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tvec3 noise = texture2D(u_noise, v_coord * vec2(u_size.x / 512.0, u_size.y / 512.0) + u_rand).xyz - vec3(0.5);\n\r\n\t\t\t\tgl_FragColor = vec4( color.xyz + noise * u_value1, color.a );\n\r\n\t\t\t}\n";
    m.pixel_shader_gamma = "precision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_value1;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tfloat gamma = 1.0 / u_value1;\n\r\n\t\t\t\tgl_FragColor = vec4( pow( color.xyz, vec3(gamma) ), color.a );\n\r\n\t\t\t}\n";
    c.registerNodeType("fx/generic", m);
    y.LGraphFXGeneric = m;
    n.title = "Vigneting";
    n.desc = "Vigneting";
    n.widgets_info = {precision:{widget:"combo", values:g.MODE_VALUES}};
    n.prototype.onExecute = function() {
      var c = this.getInputData(0);
      if (this.properties.precision === g.PASS_THROUGH) {
        this.setOutputData(0, c);
      } else {
        if (c) {
          this._tex = g.getTargetTexture(c, this._tex, this.properties.precision);
          var l = this.properties.intensity;
          this.isInputConnected(1) && (l = this.getInputData(1), this.properties.intensity = l);
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          var m = Mesh.getScreenQuad(), u = n._shader, y = this.properties.invert;
          this._tex.drawTo(function() {
            c.bind(0);
            u.uniforms({u_texture:0, u_intensity:l, u_isize:[1 / c.width, 1 / c.height], u_invert:y ? 1 : 0}).draw(m);
          });
          this.setOutputData(0, this._tex);
        }
      }
    };
    n.pixel_shader = "precision highp float;\n\r\n\t\t\tprecision highp float;\n\r\n\t\t\tvarying vec2 v_coord;\n\r\n\t\t\tuniform sampler2D u_texture;\n\r\n\t\t\tuniform float u_intensity;\n\r\n\t\t\tuniform int u_invert;\n\r\n\t\t\t\n\r\n\t\t\tvoid main() {\n\r\n\t\t\t\tfloat luminance = 1.0 - length( v_coord - vec2(0.5) ) * 1.414;\n\r\n\t\t\t\tvec4 color = texture2D(u_texture, v_coord);\n\r\n\t\t\t\tif(u_invert == 1)\n\r\n\t\t\t\t\tluminance = 1.0 - luminance;\n\r\n\t\t\t\tluminance = mix(1.0, luminance, u_intensity);\n\r\n\t\t\t   gl_FragColor = vec4( luminance * color.xyz, color.a);\n\r\n\t\t\t}\n\r\n\t\t\t";
    c.registerNodeType("fx/vigneting", n);
    y.LGraphFXVigneting = n;
  }
})(this);
(function(y) {
  function c() {
    O.length = 0;
    for (var a in r) {
      var b = r[a], d = b.indexOf(" "), c = b.substr(0, d), f = b.indexOf("(", d);
      d = b.substr(d, f - d).trim();
      b = b.substr(f + 1, b.length - f - 2).split(",");
      for (var h in b) {
        f = b[h].split(" ").filter(function(a) {
          return a;
        }), b[h] = {type:f[0].trim(), name:f[1].trim()}, "=" == f[2] && (b[h].value = f[3].trim());
      }
      N[a] = {return_type:c, func:d, params:b};
      O.push(d);
    }
  }
  function g(a, b) {
    b.color = "#345";
    b.filter = "shader";
    b.prototype.clearDestination = function() {
      this.shader_destination = {};
    };
    b.prototype.propagateDestination = function(a) {
      this.shader_destination[a] = !0;
      if (this.inputs) {
        for (var b = 0; b < this.inputs.length; ++b) {
          var d = this.getInputNode(b);
          d && d.propagateDestination(a);
        }
      }
    };
    b.prototype.onPropertyChanged || (b.prototype.onPropertyChanged = function() {
      this.graph && this.graph._version++;
    });
    h.registerNodeType("shader::" + a, b);
  }
  function n(a, b) {
    return "VAR_" + (b || "TEMP") + "_" + a.id;
  }
  function m(a, b) {
    if (!a.inputs) {
      return null;
    }
    b = a.getInputLink(b);
    return b ? (a = a.graph.getNodeById(b.origin_id)) ? a.getOutputVarName ? a.getOutputVarName(b.origin_slot) : "link_" + a.id + "_" + b.origin_slot : null : null;
  }
  function u(a, b) {
    return a.isOutputConnected(b) ? "link_" + a.id + "_" + b : null;
  }
  function l() {
    this.fs_template = this.vs_template = "";
    this.buffer_names = {uvs:"v_coord"};
    this.extra = {};
    this._functions = {};
    this._uniforms = {};
    this._codeparts = {};
    this._uniform_value = null;
  }
  function G() {
    this.subgraph = new h.LGraph;
    this.subgraph._subgraph_node = this;
    this.subgraph._is_subgraph = !0;
    this.subgraph.filter = "shader";
    this.addInput("in", "texture");
    this.addOutput("out", "texture");
    this.properties = {width:0, height:0, alpha:!1, precision:"undefined" != typeof LGraphTexture ? LGraphTexture.DEFAULT : 2};
    var a = this.subgraph.findNodesByType("shader::input/uniform")[0];
    a.pos = [200, 300];
    var b = h.createNode("shader::texture/sampler2D");
    b.pos = [400, 300];
    this.subgraph.add(b);
    var d = h.createNode("shader::output/fragcolor");
    d.pos = [600, 300];
    this.subgraph.add(d);
    a.connect(0, b);
    b.connect(0, d);
    this.size = [180, 60];
    this.redraw_on_mouse = !0;
    this._uniforms = {};
    this._shader = null;
    this._context = new l;
    this._context.vs_template = "#define VERTEX\n" + GL.Shader.SCREEN_VERTEX_SHADER;
    this._context.fs_template = G.template;
  }
  function A() {
    this.addOutput("out", "");
    this.properties = {name:"", type:""};
  }
  function D() {
    this.addOutput("out", "vec2");
    this.properties = {name:"coord", type:"vec2"};
  }
  function B() {
    this.addInput("tex", "sampler2D");
    this.addInput("uv", "vec2");
    this.addOutput("rgba", "vec4");
    this.addOutput("rgb", "vec3");
  }
  function F() {
    this.addOutput("", "float");
    this.properties = {type:"float", value:0};
    this.addWidget("combo", "type", "float", null, {values:v, property:"type"});
    this.updateWidgets();
  }
  function e() {
    this.addInput("xy", "vec2");
    this.addInput("x", "float");
    this.addInput("y", "float");
    this.addOutput("xy", "vec2");
    this.addOutput("x", "float");
    this.addOutput("y", "float");
    this.properties = {x:0, y:0};
  }
  function z() {
    this.addInput("xyz", "vec3");
    this.addInput("x", "float");
    this.addInput("y", "float");
    this.addInput("z", "float");
    this.addInput("xy", "vec2");
    this.addInput("xz", "vec2");
    this.addInput("yz", "vec2");
    this.addOutput("xyz", "vec3");
    this.addOutput("x", "float");
    this.addOutput("y", "float");
    this.addOutput("z", "float");
    this.addOutput("xy", "vec2");
    this.addOutput("xz", "vec2");
    this.addOutput("yz", "vec2");
    this.properties = {x:0, y:0, z:0};
  }
  function H() {
    this.addInput("xyzw", "vec4");
    this.addInput("xyz", "vec3");
    this.addInput("x", "float");
    this.addInput("y", "float");
    this.addInput("z", "float");
    this.addInput("w", "float");
    this.addInput("xy", "vec2");
    this.addInput("yz", "vec2");
    this.addInput("zw", "vec2");
    this.addOutput("xyzw", "vec4");
    this.addOutput("xyz", "vec3");
    this.addOutput("x", "float");
    this.addOutput("y", "float");
    this.addOutput("z", "float");
    this.addOutput("xy", "vec2");
    this.addOutput("yz", "vec2");
    this.addOutput("zw", "vec2");
    this.properties = {x:0, y:0, z:0, w:0};
  }
  function x() {
    this.addInput("color", w.ALL_TYPES);
    this.block_delete = !0;
  }
  function K() {
    this.addInput("A", w.ALL_TYPES);
    this.addInput("B", w.ALL_TYPES);
    this.addOutput("out", "");
    this.properties = {operation:"*"};
    this.addWidget("combo", "op.", this.properties.operation, {property:"operation", values:K.operations});
  }
  function k() {
    this.addInput("A", w.ALL_TYPES);
    this.addInput("B", w.ALL_TYPES);
    this.addOutput("out", "");
    this.properties = {func:"floor"};
    this._current = "floor";
    this.addWidget("combo", "func", this.properties.func, {property:"func", values:O});
  }
  function q() {
    this.addInput("A", w.ALL_TYPES);
    this.addInput("B", w.ALL_TYPES);
    this.addOutput("C", "vec4");
    this.properties = {code:"C = A+B", type:"vec4"};
    this.addWidget("text", "code", this.properties.code, {property:"code"});
    this.addWidget("combo", "type", this.properties.type, {values:["float", "vec2", "vec3", "vec4"], property:"type"});
  }
  function t() {
    this.addOutput("out", "float");
  }
  function a() {
    this.addInput("out", w.ALL_TYPES);
    this.addInput("scale", "float");
    this.addOutput("out", "float");
    this.properties = {type:"noise", scale:1};
    this.addWidget("combo", "type", this.properties.type, {property:"type", values:a.NOISE_TYPES});
    this.addWidget("number", "scale", this.properties.scale, {property:"scale"});
  }
  function b() {
    this.addOutput("out", "float");
  }
  function d() {
    this.addInput("in", "T");
    this.addOutput("out", "float");
  }
  function f() {
    this.addInput("", w.ALL_TYPES);
    this.addOutput("", "");
    this.properties = {min_value:0, max_value:1, min_value2:0, max_value2:1};
    this.addWidget("number", "min", 0, {step:0.1, property:"min_value"});
    this.addWidget("number", "max", 1, {step:0.1, property:"max_value"});
    this.addWidget("number", "min2", 0, {step:0.1, property:"min_value2"});
    this.addWidget("number", "max2", 1, {step:0.1, property:"max_value2"});
  }
  if ("undefined" != typeof GL) {
    var h = y.LiteGraph, w = h.Shaders = {};
    w.GLSL_types = "float vec2 vec3 vec4 mat3 mat4 sampler2D samplerCube".split(" ");
    var v = w.GLSL_types_const = ["float", "vec2", "vec3", "vec4"], r = {radians:"T radians(T degrees)", degrees:"T degrees(T radians)", sin:"T sin(T angle)", cos:"T cos(T angle)", tan:"T tan(T angle)", asin:"T asin(T x)", acos:"T acos(T x)", atan:"T atan(T x)", atan2:"T atan(T x,T y)", pow:"T pow(T x,T y)", exp:"T exp(T x)", log:"T log(T x)", exp2:"T exp2(T x)", log2:"T log2(T x)", sqrt:"T sqrt(T x)", inversesqrt:"T inversesqrt(T x)", abs:"T abs(T x)", sign:"T sign(T x)", floor:"T floor(T x)", round:"T round(T x)", 
    ceil:"T ceil(T x)", fract:"T fract(T x)", mod:"T mod(T x,T y)", min:"T min(T x,T y)", max:"T max(T x,T y)", clamp:"T clamp(T x,T minVal = 0.0,T maxVal = 1.0)", mix:"T mix(T x,T y,T a)", step:"T step(T edge, T edge2, T x)", smoothstep:"T smoothstep(T edge, T edge2, T x)", length:"float length(T x)", distance:"float distance(T p0, T p1)", normalize:"T normalize(T x)", dot:"float dot(T x,T y)", cross:"vec3 cross(vec3 x,vec3 y)", reflect:"vec3 reflect(vec3 V,vec3 N)", refract:"vec3 refract(vec3 V,vec3 N, float IOR)"}, 
    N = {}, O = [];
    c();
    w.ALL_TYPES = "float,vec2,vec3,vec4";
    w.registerShaderNode = g;
    w.getInputLinkID = m;
    w.getOutputLinkID = u;
    w.getShaderNodeVarName = n;
    w.parseGLSLDescriptions = c;
    var M = h.valueToGLSL = function(a, b, d) {
      var c = 5;
      null != d && (c = d);
      if (!b) {
        if (a.constructor === Number) {
          b = "float";
        } else {
          if (a.length) {
            switch(a.length) {
              case 2:
                b = "vec2";
                break;
              case 3:
                b = "vec3";
                break;
              case 4:
                b = "vec4";
                break;
              case 9:
                b = "mat3";
                break;
              case 16:
                b = "mat4";
                break;
              default:
                throw "unknown type for glsl value size";
            }
          } else {
            throw "unknown type for glsl value: " + a.constructor;
          }
        }
      }
      switch(b) {
        case "float":
          return a.toFixed(c);
        case "vec2":
          return "vec2(" + a[0].toFixed(c) + "," + a[1].toFixed(c) + ")";
        case "color3":
        case "vec3":
          return "vec3(" + a[0].toFixed(c) + "," + a[1].toFixed(c) + "," + a[2].toFixed(c) + ")";
        case "color4":
        case "vec4":
          return "vec4(" + a[0].toFixed(c) + "," + a[1].toFixed(c) + "," + a[2].toFixed(c) + "," + a[3].toFixed(c) + ")";
        case "mat3":
          return "mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)";
        case "mat4":
          return "mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0)";
        default:
          throw "unknown glsl type in valueToGLSL:", b;
      }
    }, C = h.varToTypeGLSL = function(a, b, d) {
      if (b == d) {
        return a;
      }
      if (null == a) {
        switch(d) {
          case "float":
            return "0.0";
          case "vec2":
            return "vec2(0.0)";
          case "vec3":
            return "vec3(0.0)";
          case "vec4":
            return "vec4(0.0,0.0,0.0,1.0)";
          default:
            return null;
        }
      }
      if (!d) {
        throw "error: no output type specified";
      }
      if ("float" == d) {
        switch(b) {
          case "vec2":
          case "vec3":
          case "vec4":
            return a + ".x";
          default:
            return "0.0";
        }
      } else {
        if ("vec2" == d) {
          switch(b) {
            case "float":
              return "vec2(" + a + ")";
            case "vec3":
            case "vec4":
              return a + ".xy";
            default:
              return "vec2(0.0)";
          }
        } else {
          if ("vec3" == d) {
            switch(b) {
              case "float":
                return "vec3(" + a + ")";
              case "vec2":
                return "vec3(" + a + ",0.0)";
              case "vec4":
                return a + ".xyz";
              default:
                return "vec3(0.0)";
            }
          } else {
            if ("vec4" == d) {
              switch(b) {
                case "float":
                  return "vec4(" + a + ")";
                case "vec2":
                  return "vec4(" + a + ",0.0,1.0)";
                case "vec3":
                  return "vec4(" + a + ",1.0)";
                default:
                  return "vec4(0.0,0.0,0.0,1.0)";
              }
            }
          }
        }
      }
      throw "type cannot be converted";
    }, J = h.convertVarToGLSLType = function(a, b, d) {
      if (b == d) {
        return a;
      }
      if ("float" == b) {
        return d + "(" + a + ")";
      }
      if ("vec2" == d) {
        return "vec2(" + a + ".xy)";
      }
      if ("vec3" == d) {
        if ("vec2" == b) {
          return "vec3(" + a + ",0.0)";
        }
        if ("vec4" == b) {
          return "vec4(" + a + ".xyz)";
        }
      }
      if ("vec4" == d) {
        if ("vec2" == b) {
          return "vec4(" + a + ",0.0,0.0)";
        }
        if ("vec3" == d) {
          return "vec4(" + a + ",1.0)";
        }
      }
      return null;
    };
    l.prototype.clear = function() {
      this._uniforms = {};
      this._functions = {};
      this._codeparts = {};
      this._uniform_value = null;
      this.extra = {};
    };
    l.prototype.addUniform = function(a, b, d) {
      this._uniforms[a] = b;
      null != d && (this._uniform_value || (this._uniform_value = {}), this._uniform_value[a] = d);
    };
    l.prototype.addFunction = function(a, b) {
      this._functions[a] = b;
    };
    l.prototype.addCode = function(a, b, d) {
      d = d || {"":""};
      for (var c in d) {
        d = c ? c + "_" + a : a, this._codeparts[d] = this._codeparts[d] ? this._codeparts[d] + (b + "\n") : b + "\n";
      }
    };
    l.prototype.computeCodeBlocks = function(a, b) {
      this.clear();
      var d = a.findNodesByType("shader::output/vertex");
      d = d && d.length ? d[0] : null;
      var c = a.findNodesByType("shader::output/fragcolor");
      c = c && c.length ? c[0] : null;
      if (!c) {
        return null;
      }
      a.sendEventToAllNodes("clearDestination");
      d && d.propagateDestination("vs");
      c && c.propagateDestination("fs");
      a.sendEventToAllNodes("onGetCode", this);
      a = "";
      for (var f in this._uniforms) {
        a += "uniform " + this._uniforms[f] + " " + f + ";\n";
      }
      if (b) {
        for (f in b) {
          a += "uniform " + b[f] + " " + f + ";\n";
        }
      }
      b = "";
      for (f in this._functions) {
        b += "//" + f + "\n" + this._functions[f] + "\n";
      }
      f = this._codeparts;
      f.uniforms = a;
      f.functions = b;
      return f;
    };
    l.prototype.computeShaderCode = function(a) {
      var b = this.computeCodeBlocks(a);
      a = GL.Shader.replaceCodeUsingContext(this.vs_template, b);
      b = GL.Shader.replaceCodeUsingContext(this.fs_template, b);
      return {vs_code:a, fs_code:b};
    };
    l.prototype.computeShader = function(a, b) {
      a = this.computeShaderCode(a);
      console.log(a.vs_code, a.fs_code);
      if (!h.catch_exceptions) {
        return this._shader_error = !0, b ? b.updateShader(a.vs_code, a.fs_code) : b = new GL.Shader(a.vs_code, a.fs_code), this._shader_error = !1, b;
      }
      try {
        return b ? b.updateShader(a.vs_code, a.fs_code) : b = new GL.Shader(a.vs_code, a.fs_code), this._shader_error = !1, b;
      } catch (P) {
        this._shader_error || (console.error(P), -1 != P.indexOf("Fragment shader") ? console.log(a.fs_code.split("\n").map(function(a, b) {
          return b + ".- " + a;
        }).join("\n")) : console.log(a.vs_code)), this._shader_error = !0;
      }
      return null;
    };
    l.prototype.getShader = function(a) {
      if (this._shader && this._shader._version == a._version) {
        return this._shader;
      }
      var b = this.computeShader(a, this._shader);
      if (!b) {
        return null;
      }
      this._shader = b;
      b._version = a._version;
      return b;
    };
    l.prototype.fillUniforms = function(a, b) {
      if (this._uniform_value) {
        for (var d in this._uniform_value) {
          var c = this._uniform_value[d];
          null != c && (c.constructor === Function ? a[d] = c.call(this, b) : c.constructor !== GL.Texture && (a[d] = c));
        }
      }
    };
    h.ShaderContext = h.Shaders.Context = l;
    G.template = "\n\r\n#define FRAGMENT\n\r\nprecision highp float;\n\r\nvarying vec2 v_coord;\n\r\n{{varying}}\n\r\n{{uniforms}}\n\r\n{{functions}}\n\r\n{{fs_functions}}\n\r\nvoid main() {\n\n\r\nvec2 uv = v_coord;\n\r\nvec4 fragcolor = vec4(0.0);\n\r\nvec4 fragcolor1 = vec4(0.0);\n\r\n{{fs_code}}\n\r\ngl_FragColor = fragcolor;\n\r\n}\n\r\n\t";
    G.widgets_info = {precision:{widget:"combo", values:LGraphTexture.MODE_VALUES}};
    G.title = "ShaderGraph";
    G.desc = "Builds a shader using a graph";
    G.input_node_type = "input/uniform";
    G.output_node_type = "output/fragcolor";
    G.title_color = "#345";
    G.prototype.onSerialize = function(a) {
      a.subgraph = this.subgraph.serialize();
    };
    G.prototype.onConfigure = function(a) {
      this.subgraph.configure(a.subgraph);
    };
    G.prototype.onExecute = function() {
      if (this.isOutputConnected(0)) {
        var a = this.getInputData(0);
        a && a.constructor != GL.Texture && (a = null);
        var b = this.properties.width | 0, d = this.properties.height | 0;
        0 == b && (b = a ? a.width : gl.viewport_data[2]);
        0 == d && (d = a ? a.height : gl.viewport_data[3]);
        var c = LGraphTexture.getTextureType(this.properties.precision, a);
        a = this._texture;
        a && a.width == b && a.height == d && a.type == c || (a = this._texture = new GL.Texture(b, d, {type:c, format:this.alpha ? gl.RGBA : gl.RGB, filter:gl.LINEAR}));
        var f = this.getShader(this.subgraph);
        if (f) {
          var h = this._uniforms;
          this._context.fillUniforms(h);
          b = 0;
          if (this.inputs) {
            for (d = 0; d < this.inputs.length; ++d) {
              c = this.inputs[d];
              var k = this.getInputData(d);
              "texture" == c.type && (k || (k = GL.Texture.getWhiteTexture()), k = k.bind(b++));
              null != k && (h["u_" + c.name] = k);
            }
          }
          var e = GL.Mesh.getScreenQuad();
          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.BLEND);
          a.drawTo(function() {
            f.uniforms(h);
            f.draw(e);
          });
          this.setOutputData(0, a);
        }
      }
    };
    G.prototype.onInputAdded = function(a) {
      var b = h.createNode("shader::input/uniform");
      b.setProperty("name", a.name);
      b.setProperty("type", a.type);
      this.subgraph.add(b);
    };
    G.prototype.onInputRemoved = function(a, b) {
      a = this.subgraph.findNodesByType("shader::input/uniform");
      for (var d = 0; d < a.length; ++d) {
        var c = a[d];
        c.properties.name == b.name && this.subgraph.remove(c);
      }
    };
    G.prototype.computeSize = function() {
      return [200, Math.max(this.inputs ? this.inputs.length : 0, this.outputs ? this.outputs.length : 0) * h.NODE_SLOT_HEIGHT + h.NODE_TITLE_HEIGHT + 10];
    };
    G.prototype.getShader = function() {
      var a = this._context.getShader(this.subgraph);
      this.boxcolor = a ? null : "red";
      return a;
    };
    G.prototype.onDrawBackground = function(a, b, d, c) {
      if (!this.flags.collapsed) {
        b = this.getOutputData(0);
        d = this.inputs ? this.inputs.length * h.NODE_SLOT_HEIGHT : 0;
        b && a == b.gl && this.size[1] > d + h.NODE_TITLE_HEIGHT && a.drawImage(b, 10, f, this.size[0] - 20, this.size[1] - d - h.NODE_TITLE_HEIGHT);
        var f = this.size[1] - h.NODE_TITLE_HEIGHT + 0.5;
        c = h.isInsideRectangle(c[0], c[1], this.pos[0], this.pos[1] + f, this.size[0], h.NODE_TITLE_HEIGHT);
        a.fillStyle = c ? "#555" : "#222";
        a.beginPath();
        this._shape == h.BOX_SHAPE ? a.rect(0, f, this.size[0] + 1, h.NODE_TITLE_HEIGHT) : a.roundRect(0, f, this.size[0] + 1, h.NODE_TITLE_HEIGHT, 0, 8);
        a.fill();
        a.textAlign = "center";
        a.font = "24px Arial";
        a.fillStyle = c ? "#DDD" : "#999";
        a.fillText("+", 0.5 * this.size[0], f + 24);
      }
    };
    G.prototype.onMouseDown = function(a, b, d) {
      b[1] > this.size[1] - h.NODE_TITLE_HEIGHT + 0.5 && d.showSubgraphPropertiesDialog(this);
    };
    G.prototype.onDrawSubgraphBackground = function(a) {
    };
    G.prototype.getExtraMenuOptions = function(a) {
      var b = this;
      return [{content:"Print Code", callback:function() {
        var a = b._context.computeShaderCode();
        console.log(a.vs_code, a.fs_code);
      }}];
    };
    h.registerNodeType("texture/shaderGraph", G);
    A.title = "Uniform";
    A.desc = "Input data for the shader";
    A.prototype.getTitle = function() {
      return this.properties.name && this.flags.collapsed ? this.properties.type + " " + this.properties.name : "Uniform";
    };
    A.prototype.onPropertyChanged = function(a, b) {
      this.outputs[0].name = this.properties.type + " " + this.properties.name;
    };
    A.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = this.properties.type;
        if (!b) {
          if (!a.onGetPropertyInfo) {
            return;
          }
          b = a.onGetPropertyInfo(this.property.name);
          if (!b) {
            return;
          }
          b = b.type;
        }
        "number" == b ? b = "float" : "texture" == b && (b = "sampler2D");
        -1 != w.GLSL_types.indexOf(b) && (a.addUniform("u_" + this.properties.name, b), this.setOutputData(0, b));
      }
    };
    A.prototype.getOutputVarName = function(a) {
      return "u_" + this.properties.name;
    };
    g("input/uniform", A);
    D.title = "Attribute";
    D.desc = "Input data from mesh attribute";
    D.prototype.getTitle = function() {
      return "att. " + this.properties.name;
    };
    D.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = this.properties.type;
        b && -1 != w.GLSL_types.indexOf(b) && ("number" == b && (b = "float"), "coord" != this.properties.name && a.addCode("varying", " varying " + b + " v_" + this.properties.name + ";"), this.setOutputData(0, b));
      }
    };
    D.prototype.getOutputVarName = function(a) {
      return "v_" + this.properties.name;
    };
    g("input/attribute", D);
    B.title = "Sampler2D";
    B.desc = "Reads a pixel from a texture";
    B.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = m(this, 0), d = n(this), c = "vec4 " + d + " = vec4(0.0);\n";
        if (b) {
          var f = m(this, 1) || a.buffer_names.uvs;
          c += d + " = texture2D(" + b + "," + f + ");\n";
        }
        u(this, 0) && (c += "vec4 " + u(this, 0) + " = " + d + ";\n");
        u(this, 1) && (c += "vec3 " + u(this, 1) + " = " + d + ".xyz;\n");
        a.addCode("code", c, this.shader_destination);
        this.setOutputData(0, "vec4");
        this.setOutputData(1, "vec3");
      }
    };
    g("texture/sampler2D", B);
    F.title = "const";
    F.prototype.getTitle = function() {
      return this.flags.collapsed ? M(this.properties.value, this.properties.type, 2) : "Const";
    };
    F.prototype.onPropertyChanged = function(a, b) {
      "type" == a && (this.outputs[0].type != b && (this.disconnectOutput(0), this.outputs[0].type = b), this.widgets.length = 1, this.updateWidgets());
      "value" == a && (b.length ? (this.widgets[1].value = b[1], 2 < b.length && (this.widgets[2].value = b[2]), 3 < b.length && (this.widgets[3].value = b[3])) : this.widgets[1].value = b);
    };
    F.prototype.updateWidgets = function(a) {
      var b = this;
      a = this.properties.value;
      var d = {step:0.01};
      switch(this.properties.type) {
        case "float":
          this.properties.value = 0;
          this.addWidget("number", "v", 0, {step:0.01, property:"value"});
          break;
        case "vec2":
          this.properties.value = a && 2 == a.length ? [a[0], a[1]] : [0, 0, 0];
          this.addWidget("number", "x", this.properties.value[0], function(a) {
            b.properties.value[0] = a;
          }, d);
          this.addWidget("number", "y", this.properties.value[1], function(a) {
            b.properties.value[1] = a;
          }, d);
          break;
        case "vec3":
          this.properties.value = a && 3 == a.length ? [a[0], a[1], a[2]] : [0, 0, 0];
          this.addWidget("number", "x", this.properties.value[0], function(a) {
            b.properties.value[0] = a;
          }, d);
          this.addWidget("number", "y", this.properties.value[1], function(a) {
            b.properties.value[1] = a;
          }, d);
          this.addWidget("number", "z", this.properties.value[2], function(a) {
            b.properties.value[2] = a;
          }, d);
          break;
        case "vec4":
          this.properties.value = a && 4 == a.length ? [a[0], a[1], a[2], a[3]] : [0, 0, 0, 0];
          this.addWidget("number", "x", this.properties.value[0], function(a) {
            b.properties.value[0] = a;
          }, d);
          this.addWidget("number", "y", this.properties.value[1], function(a) {
            b.properties.value[1] = a;
          }, d);
          this.addWidget("number", "z", this.properties.value[2], function(a) {
            b.properties.value[2] = a;
          }, d);
          this.addWidget("number", "w", this.properties.value[3], function(a) {
            b.properties.value[3] = a;
          }, d);
          break;
        default:
          console.error("unknown type for constant");
      }
    };
    F.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = M(this.properties.value, this.properties.type), d = u(this, 0);
        d && (a.addCode("code", "\t" + this.properties.type + " " + d + " = " + b + ";", this.shader_destination), this.setOutputData(0, this.properties.type));
      }
    };
    g("const/const", F);
    e.title = "vec2";
    e.varmodes = ["xy", "x", "y"];
    e.prototype.onPropertyChanged = function() {
      this.graph && this.graph._version++;
    };
    e.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = this.properties, d = n(this);
        b = "\tvec2 " + d + " = " + M([b.x, b.y]) + ";\n";
        for (var c = 0; c < e.varmodes.length; ++c) {
          var f = e.varmodes[c], h = m(this, c);
          h && (b += "\t" + d + "." + f + " = " + h + ";\n");
        }
        for (c = 0; c < e.varmodes.length; ++c) {
          if (f = e.varmodes[c], h = u(this, c)) {
            var k = v[f.length - 1];
            b += "\t" + k + " " + h + " = " + d + "." + f + ";\n";
            this.setOutputData(c, k);
          }
        }
        a.addCode("code", b, this.shader_destination);
      }
    };
    g("const/vec2", e);
    z.title = "vec3";
    z.varmodes = "xyz x y z xy xz yz".split(" ");
    z.prototype.onPropertyChanged = function() {
      this.graph && this.graph._version++;
    };
    z.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = this.properties, d = n(this);
        b = "vec3 " + d + " = " + M([b.x, b.y, b.z]) + ";\n";
        for (var c = 0; c < z.varmodes.length; ++c) {
          var f = z.varmodes[c], h = m(this, c);
          h && (b += "\t" + d + "." + f + " = " + h + ";\n");
        }
        for (c = 0; c < z.varmodes.length; ++c) {
          if (f = z.varmodes[c], h = u(this, c)) {
            var k = v[f.length - 1];
            b += "\t" + k + " " + h + " = " + d + "." + f + ";\n";
            this.setOutputData(c, k);
          }
        }
        a.addCode("code", b, this.shader_destination);
      }
    };
    g("const/vec3", z);
    H.title = "vec4";
    H.varmodes = "xyzw xyz x y z w xy yz zw".split(" ");
    H.prototype.onPropertyChanged = function() {
      this.graph && this.graph._version++;
    };
    H.prototype.onGetCode = function(a) {
      if (this.shader_destination) {
        var b = this.properties, d = n(this);
        b = "vec4 " + d + " = " + M([b.x, b.y, b.z, b.w]) + ";\n";
        for (var c = 0; c < H.varmodes.length; ++c) {
          var f = H.varmodes[c], h = m(this, c);
          h && (b += "\t" + d + "." + f + " = " + h + ";\n");
        }
        for (c = 0; c < H.varmodes.length; ++c) {
          if (f = H.varmodes[c], h = u(this, c)) {
            var k = v[f.length - 1];
            b += "\t" + k + " " + h + " = " + d + "." + f + ";\n";
            this.setOutputData(c, k);
          }
        }
        a.addCode("code", b, this.shader_destination);
      }
    };
    g("const/vec4", H);
    x.title = "FragColor";
    x.desc = "Pixel final color";
    x.prototype.onGetCode = function(a) {
      var b = m(this, 0);
      if (b) {
        var d = this.getInputData(0);
        b = C(b, d, "vec4");
        a.addCode("fs_code", "fragcolor = " + b + ";");
      }
    };
    g("output/fragcolor", x);
    K.title = "Operation";
    K.operations = ["+", "-", "*", "/"];
    K.prototype.getTitle = function() {
      return this.flags.collapsed ? "A" + this.properties.operation + "B" : "Operation";
    };
    K.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        for (var b = [], d = 0; 3 > d; ++d) {
          b.push({name:m(this, d), type:this.getInputData(d) || "float"});
        }
        var c = u(this, 0);
        if (c) {
          var f = b[0].type, h = this.properties.operation, k = [];
          for (d = 0; 2 > d; ++d) {
            var e = b[d].name;
            null == e && (e = null != p.value ? p.value : "(1.0)", b[d].type = "float");
            b[d].type != f && ("float" != b[d].type || "*" != h && "/" != h) && (e = J(e, b[d].type, f));
            k.push(e);
          }
          a.addCode("code", f + " " + c + " = " + k[0] + h + k[1] + ";", this.shader_destination);
          this.setOutputData(0, f);
        }
      }
    };
    g("math/operation", K);
    k.title = "Func";
    k.prototype.onPropertyChanged = function(a, b) {
      this.graph && this.graph._version++;
      if ("func" == a && (a = N[b])) {
        for (b = a.params.length; b < this.inputs.length; ++b) {
          this.removeInput(b);
        }
        for (b = 0; b < a.params.length; ++b) {
          var d = a.params[b];
          this.inputs[b] ? this.inputs[b].name = d.name + (d.value ? " (" + d.value + ")" : "") : this.addInput(d.name, w.ALL_TYPES);
        }
      }
    };
    k.prototype.getTitle = function() {
      return this.flags.collapsed ? this.properties.func : "Func";
    };
    k.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        for (var b = [], d = 0; 3 > d; ++d) {
          b.push({name:m(this, d), type:this.getInputData(d) || "float"});
        }
        var c = u(this, 0);
        if (c) {
          var f = N[this.properties.func];
          if (f) {
            var h = b[0].type, k = f.return_type;
            "T" == k && (k = h);
            var e = [];
            for (d = 0; d < f.params.length; ++d) {
              var g = f.params[d], t = b[d].name;
              null == t && (t = null != g.value ? g.value : "(1.0)", b[d].type = "float");
              if ("T" == g.type && b[d].type != h || "T" != g.type && b[d].type != h) {
                t = J(t, b[d].type, h);
              }
              e.push(t);
            }
            a.addFunction("round", "float round(float v){ return floor(v+0.5); }\nvec2 round(vec2 v){ return floor(v+vec2(0.5));}\nvec3 round(vec3 v){ return floor(v+vec3(0.5));}\nvec4 round(vec4 v){ return floor(v+vec4(0.5)); }\n");
            a.addCode("code", k + " " + c + " = " + f.func + "(" + e.join(",") + ");", this.shader_destination);
            this.setOutputData(0, k);
          }
        }
      }
    };
    g("math/func", k);
    q.title = "Snippet";
    q.prototype.onPropertyChanged = function(a, b) {
      this.graph && this.graph._version++;
      "type" == a && this.outputs[0].type != b && (this.disconnectOutput(0), this.outputs[0].type = b);
    };
    q.prototype.getTitle = function() {
      return this.flags.collapsed ? this.properties.code : "Snippet";
    };
    q.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        var b = m(this, 0);
        b || (b = "1.0");
        var d = m(this, 1);
        d || (d = "1.0");
        var c = u(this, 0);
        if (c) {
          var f = this.getInputData(0) || "float", h = this.getInputData(1) || "float", k = this.properties.type;
          if ("T" == f || "T" == h) {
            return null;
          }
          var e = "funcSnippet" + this.id;
          f = "\n" + k + " " + e + "( " + f + " A, " + h + " B) {\n" + ("\t" + k + " C = " + k + "(0.0);\n") + ("\t" + this.properties.code + ";\n");
          f += "\treturn C;\n}\n";
          a.addCode("functions", f, this.shader_destination);
          a.addCode("code", k + " " + c + " = " + e + "(" + b + "," + d + ");", this.shader_destination);
          this.setOutputData(0, k);
        }
      }
    };
    g("utils/snippet", q);
    t.title = "Rand";
    t.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        var b = u(this, 0);
        a.addUniform("u_rand" + this.id, "float", function() {
          return Math.random();
        });
        a.addCode("code", "float " + b + " = u_rand" + this.id + ";", this.shader_destination);
        this.setOutputData(0, "float");
      }
    };
    g("input/rand", t);
    a.NOISE_TYPES = ["noise", "rand"];
    a.title = "noise";
    a.prototype.onGetCode = function(b) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        var d = m(this, 0), c = u(this, 0), f = this.getInputData(0);
        d || (f = "vec2", d = b.buffer_names.uvs);
        b.addFunction("noise", a.shader_functions);
        b.addUniform("u_noise_scale" + this.id, "float", this.properties.scale);
        "float" == f ? b.addCode("code", "float " + c + " = snoise( vec2(" + d + ") * u_noise_scale" + this.id + ");", this.shader_destination) : "vec2" == f || "vec3" == f ? b.addCode("code", "float " + c + " = snoise(" + d + " * u_noise_scale" + this.id + ");", this.shader_destination) : "vec4" == f && b.addCode("code", "float " + c + " = snoise(" + d + ".xyz * u_noise_scale" + this.id + ");", this.shader_destination);
        this.setOutputData(0, "float");
      }
    };
    g("math/noise", a);
    a.shader_functions = "\n\r\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\r\n\n\r\nfloat snoise(vec2 v){\n\r\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,-0.577350269189626, 0.024390243902439);\n\r\n  vec2 i  = floor(v + dot(v, C.yy) );\n\r\n  vec2 x0 = v -   i + dot(i, C.xx);\n\r\n  vec2 i1;\n\r\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\r\n  vec4 x12 = x0.xyxy + C.xxzz;\n\r\n  x12.xy -= i1;\n\r\n  i = mod(i, 289.0);\n\r\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\r\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n\r\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)), 0.0);\n\r\n  m = m*m ;\n\r\n  m = m*m ;\n\r\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n\r\n  vec3 h = abs(x) - 0.5;\n\r\n  vec3 ox = floor(x + 0.5);\n\r\n  vec3 a0 = x - ox;\n\r\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\r\n  vec3 g;\n\r\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n\r\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\r\n  return 130.0 * dot(m, g);\n\r\n}\n\r\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\r\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\r\n\n\r\nfloat snoise(vec3 v){ \n\r\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\r\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\r\n\n\r\n// First corner\n\r\n  vec3 i  = floor(v + dot(v, C.yyy) );\n\r\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\r\n\n\r\n// Other corners\n\r\n  vec3 g = step(x0.yzx, x0.xyz);\n\r\n  vec3 l = 1.0 - g;\n\r\n  vec3 i1 = min( g.xyz, l.zxy );\n\r\n  vec3 i2 = max( g.xyz, l.zxy );\n\r\n\n\r\n  //  x0 = x0 - 0. + 0.0 * C \n\r\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n\r\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n\r\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\r\n\n\r\n// Permutations\n\r\n  i = mod(i, 289.0 ); \n\r\n  vec4 p = permute( permute( permute( \n\r\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\r\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n\r\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\r\n\n\r\n// Gradients\n\r\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n\r\n  float n_ = 1.0/7.0; // N=7\n\r\n  vec3  ns = n_ * D.wyz - D.xzx;\n\r\n\n\r\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\r\n\n\r\n  vec4 x_ = floor(j * ns.z);\n\r\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\r\n\n\r\n  vec4 x = x_ *ns.x + ns.yyyy;\n\r\n  vec4 y = y_ *ns.x + ns.yyyy;\n\r\n  vec4 h = 1.0 - abs(x) - abs(y);\n\r\n\n\r\n  vec4 b0 = vec4( x.xy, y.xy );\n\r\n  vec4 b1 = vec4( x.zw, y.zw );\n\r\n\n\r\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n\r\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n\r\n  vec4 sh = -step(h, vec4(0.0));\n\r\n\n\r\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\r\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\r\n\n\r\n  vec3 p0 = vec3(a0.xy,h.x);\n\r\n  vec3 p1 = vec3(a0.zw,h.y);\n\r\n  vec3 p2 = vec3(a1.xy,h.z);\n\r\n  vec3 p3 = vec3(a1.zw,h.w);\n\r\n\n\r\n//Normalise gradients\n\r\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\r\n  p0 *= norm.x;\n\r\n  p1 *= norm.y;\n\r\n  p2 *= norm.z;\n\r\n  p3 *= norm.w;\n\r\n\n\r\n// Mix final noise value\n\r\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\r\n  m = m * m;\n\r\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n\r\n}\n\r\n\n\r\nvec3 hash3( vec2 p ){\n\r\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\r\n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\r\n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\r\n\treturn fract(sin(q)*43758.5453);\n\r\n}\n\r\nvec4 hash4( vec3 p ){\n\r\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,257.3)), \n\r\n\t\t\t\t   dot(p,vec3(269.5,183.3,335.1)), \n\r\n\t\t\t\t   dot(p,vec3(314.5,235.1,467.3)), \n\r\n\t\t\t\t   dot(p,vec3(419.2,371.9,114.9)) );\n\r\n\treturn fract(sin(q)*43758.5453);\n\r\n}\n\r\n\n\r\nfloat iqnoise( in vec2 x, float u, float v ){\n\r\n    vec2 p = floor(x);\n\r\n    vec2 f = fract(x);\n\r\n\t\n\r\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\r\n\t\n\r\n\tfloat va = 0.0;\n\r\n\tfloat wt = 0.0;\n\r\n    for( int j=-2; j<=2; j++ )\n\r\n    for( int i=-2; i<=2; i++ )\n\r\n    {\n\r\n        vec2 g = vec2( float(i),float(j) );\n\r\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\r\n\t\tvec2 r = g - f + o.xy;\n\r\n\t\tfloat d = dot(r,r);\n\r\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\r\n\t\tva += o.z*ww;\n\r\n\t\twt += ww;\n\r\n    }\n\r\n\t\n\r\n    return va/wt;\n\r\n}\n\r\n";
    b.title = "Time";
    b.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        var b = u(this, 0);
        a.addUniform("u_time" + this.id, "float", function() {
          return 0.001 * getTime();
        });
        a.addCode("code", "float " + b + " = u_time" + this.id + ";", this.shader_destination);
        this.setOutputData(0, "float");
      }
    };
    g("input/time", b);
    d.title = "Dither";
    d.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        var b = m(this, 0), c = u(this, 0), f = this.getInputData(0);
        b = C(b, f, "float");
        a.addFunction("dither8x8", d.dither_func);
        a.addCode("code", "float " + c + " = dither8x8(" + b + ");", this.shader_destination);
        this.setOutputData(0, "float");
      }
    };
    d.dither_values = [0.515625, 0.140625, 0.640625, 0.046875, 0.546875, 0.171875, 0.671875, 0.765625, 0.265625, 0.890625, 0.390625, 0.796875, 0.296875, 0.921875, 0.421875, 0.203125, 0.703125, 0.078125, 0.578125, 0.234375, 0.734375, 0.109375, 0.609375, 0.953125, 0.453125, 0.828125, 0.328125, 0.984375, 0.484375, 0.859375, 0.359375, 0.0625, 0.5625, 0.1875, 0.6875, 0.03125, 0.53125, 0.15625, 0.65625, 0.8125, 0.3125, 0.9375, 0.4375, 0.78125, 0.28125, 0.90625, 0.40625, 0.25, 0.75, 0.125, 0.625, 0.21875, 
    0.71875, 0.09375, 0.59375, 1.0001, 0.5, 0.875, 0.375, 0.96875, 0.46875, 0.84375, 0.34375];
    d.dither_func = "\n\r\n\t\tfloat dither8x8(float brightness) {\n\r\n\t\t  vec2 position = vec2(0.0);\n\r\n\t\t  #ifdef FRAGMENT\n\r\n\t\t\tposition = gl_FragCoord.xy;\n\r\n\t\t  #endif\n\r\n\t\t  int x = int(mod(position.x, 8.0));\n\r\n\t\t  int y = int(mod(position.y, 8.0));\n\r\n\t\t  int index = x + y * 8;\n\r\n\t\t  float limit = 0.0;\n\r\n\t\t  if (x < 8) {\n\r\n\t\t\tif(index==0) limit = 0.015625;\n\r\n\t\t\t" + d.dither_values.map(function(a, b) {
      return "else if(index== " + (b + 1) + ") limit = " + a + ";";
    }).join("\n") + "\n\r\n\t\t  }\n\r\n\t\t  return brightness < limit ? 0.0 : 1.0;\n\r\n\t\t}\n";
    g("math/dither", d);
    f.title = "Remap";
    f.prototype.onPropertyChanged = function() {
      this.graph && this.graph._version++;
    };
    f.prototype.onConnectionsChange = function() {
      var a = this.getInputDataType(0);
      this.outputs[0].type = a || "T";
    };
    f.prototype.onGetCode = function(a) {
      if (this.shader_destination && this.isOutputConnected(0)) {
        var b = m(this, 0), d = u(this, 0);
        if (b || d) {
          var c = this.getInputDataType(0);
          this.outputs[0].type = c;
          if ("T" == c) {
            console.warn("node type is T and cannot be resolved");
          } else {
            if (b) {
              var f = M(this.properties.min_value), h = M(this.properties.max_value), k = M(this.properties.min_value2), e = M(this.properties.max_value2);
              a.addCode("code", c + " " + d + " = ( (" + b + " - " + f + ") / (" + h + " - " + f + ") ) * (" + e + " - " + k + ") + " + k + ";", this.shader_destination);
              this.setOutputData(0, c);
            } else {
              a.addCode("code", "\t" + c + " " + d + " = " + c + "(0.0);\n");
            }
          }
        }
      }
    };
    g("math/remap", f);
  }
})(this);
(function(y) {
  function c(c) {
    this.cmd = this.channel = 0;
    this.data = new Uint32Array(3);
    c && this.setup(c);
  }
  function g(c, e) {
    navigator.requestMIDIAccess ? (this.on_ready = c, this.state = {note:[], cc:[]}, this.input_ports = null, this.input_ports_info = [], this.output_ports = null, this.output_ports_info = [], navigator.requestMIDIAccess().then(this.onMIDISuccess.bind(this), this.onMIDIFailure.bind(this))) : (this.error = "not suppoorted", e ? e("Not supported") : console.error("MIDI NOT SUPPORTED, enable by chrome://flags"));
  }
  function n() {
    this.addOutput("on_midi", x.EVENT);
    this.addOutput("out", "midi");
    this.properties = {port:0};
    this._current_midi_event = this._last_midi_event = null;
    this.boxcolor = "#AAA";
    this._last_time = 0;
    var c = this;
    new g(function(k) {
      c._midi = k;
      if (c._waiting) {
        c.onStart();
      }
      c._waiting = !1;
    });
  }
  function m() {
    this.addInput("send", x.EVENT);
    this.properties = {port:0};
    var c = this;
    new g(function(k) {
      c._midi = k;
      c.widget.options.values = c.getMIDIOutputs();
    });
    this.widget = this.addWidget("combo", "Device", this.properties.port, {property:"port", values:this.getMIDIOutputs.bind(this)});
    this.size = [340, 60];
  }
  function u() {
    this.addInput("on_midi", x.EVENT);
    this._str = "";
    this.size = [200, 40];
  }
  function l() {
    this.properties = {channel:-1, cmd:-1, min_value:-1, max_value:-1};
    var c = this;
    this._learning = !1;
    this.addWidget("button", "Learn", "", function() {
      c._learning = !0;
      c.boxcolor = "#FA3";
    });
    this.addInput("in", x.EVENT);
    this.addOutput("on_midi", x.EVENT);
    this.boxcolor = "#AAA";
  }
  function G() {
    this.properties = {channel:0, cmd:144, value1:1, value2:1};
    this.addInput("send", x.EVENT);
    this.addInput("assign", x.EVENT);
    this.addOutput("on_midi", x.EVENT);
    this.midi_event = new c;
    this.gate = !1;
  }
  function A() {
    this.properties = {cc:1, value:0};
    this.addOutput("value", "number");
  }
  function D() {
    this.addInput("generate", x.ACTION);
    this.addInput("scale", "string");
    this.addInput("octave", "number");
    this.addOutput("note", x.EVENT);
    this.properties = {notes:"A,A#,B,C,C#,D,D#,E,F,F#,G,G#", octave:2, duration:0.5, mode:"sequence"};
    this.notes_pitches = D.processScale(this.properties.notes);
    this.sequence_index = 0;
  }
  function B() {
    this.properties = {amount:0};
    this.addInput("in", x.ACTION);
    this.addInput("amount", "number");
    this.addOutput("out", x.EVENT);
    this.midi_event = new c;
  }
  function F() {
    this.properties = {scale:"A,A#,B,C,C#,D,D#,E,F,F#,G,G#"};
    this.addInput("note", x.ACTION);
    this.addInput("scale", "string");
    this.addOutput("out", x.EVENT);
    this.valid_notes = Array(12);
    this.offset_notes = Array(12);
    this.processScale(this.properties.scale);
  }
  function e() {
    this.properties = {url:"", autoplay:!0};
    this.addInput("play", x.ACTION);
    this.addInput("pause", x.ACTION);
    this.addOutput("note", x.EVENT);
    this._midi = null;
    this._current_time = 0;
    this._playing = !1;
    "undefined" == typeof MidiParser && (console.error("midi-parser.js not included, LGMidiPlay requires that library: https://raw.githubusercontent.com/colxi/midi-parser-js/master/src/main.js"), this.boxcolor = "red");
  }
  function z() {
    this.properties = {volume:0.5, duration:1};
    this.addInput("note", x.ACTION);
    this.addInput("volume", "number");
    this.addInput("duration", "number");
    this.addOutput("note", x.EVENT);
    "undefined" == typeof AudioSynth ? (console.error("Audiosynth.js not included, LGMidiPlay requires that library"), this.boxcolor = "red") : this.instrument = (this.synth = new AudioSynth).createInstrument("piano");
  }
  function H() {
    this.properties = {num_octaves:2, start_octave:2};
    this.addInput("note", x.ACTION);
    this.addInput("reset", x.ACTION);
    this.addOutput("note", x.EVENT);
    this.size = [400, 100];
    this.keys = [];
    this._last_key = -1;
  }
  var x = y.LiteGraph;
  x.MIDIEvent = c;
  c.prototype.fromJSON = function(c) {
    this.setup(c.data);
  };
  c.prototype.setup = function(k) {
    var e = k;
    k.constructor === Object && (e = k.data);
    this.data.set(e);
    this.status = k = e[0];
    e = k & 240;
    this.cmd = 240 <= k ? k : e;
    this.cmd == c.NOTEON && 0 == this.velocity && (this.cmd = c.NOTEOFF);
    this.cmd_str = c.commands[this.cmd] || "";
    if (e >= c.NOTEON || e <= c.NOTEOFF) {
      this.channel = k & 15;
    }
  };
  Object.defineProperty(c.prototype, "velocity", {get:function() {
    return this.cmd == c.NOTEON ? this.data[2] : -1;
  }, set:function(c) {
    this.data[2] = c;
  }, enumerable:!0});
  c.notes = "A A# B C C# D D# E F F# G G#".split(" ");
  c.note_to_index = {A:0, "A#":1, B:2, C:3, "C#":4, D:5, "D#":6, E:7, F:8, "F#":9, G:10, "G#":11};
  Object.defineProperty(c.prototype, "note", {get:function() {
    return this.cmd != c.NOTEON ? -1 : c.toNoteString(this.data[1], !0);
  }, set:function(c) {
    throw "notes cannot be assigned this way, must modify the data[1]";
  }, enumerable:!0});
  Object.defineProperty(c.prototype, "octave", {get:function() {
    return this.cmd != c.NOTEON ? -1 : Math.floor((this.data[1] - 24) / 12 + 1);
  }, set:function(c) {
    throw "octave cannot be assigned this way, must modify the data[1]";
  }, enumerable:!0});
  c.prototype.getPitch = function() {
    return 440 * Math.pow(2, (this.data[1] - 69) / 12);
  };
  c.computePitch = function(c) {
    return 440 * Math.pow(2, (c - 69) / 12);
  };
  c.prototype.getCC = function() {
    return this.data[1];
  };
  c.prototype.getCCValue = function() {
    return this.data[2];
  };
  c.prototype.getPitchBend = function() {
    return this.data[1] + (this.data[2] << 7) - 8192;
  };
  c.computePitchBend = function(c, e) {
    return c + (e << 7) - 8192;
  };
  c.prototype.setCommandFromString = function(k) {
    this.cmd = c.computeCommandFromString(k);
  };
  c.computeCommandFromString = function(k) {
    if (!k) {
      return 0;
    }
    if (k && k.constructor === Number) {
      return k;
    }
    k = k.toUpperCase();
    switch(k) {
      case "NOTE ON":
      case "NOTEON":
        return c.NOTEON;
      case "NOTE OFF":
      case "NOTEOFF":
        return c.NOTEON;
      case "KEY PRESSURE":
      case "KEYPRESSURE":
        return c.KEYPRESSURE;
      case "CONTROLLER CHANGE":
      case "CONTROLLERCHANGE":
      case "CC":
        return c.CONTROLLERCHANGE;
      case "PROGRAM CHANGE":
      case "PROGRAMCHANGE":
      case "PC":
        return c.PROGRAMCHANGE;
      case "CHANNEL PRESSURE":
      case "CHANNELPRESSURE":
        return c.CHANNELPRESSURE;
      case "PITCH BEND":
      case "PITCHBEND":
        return c.PITCHBEND;
      case "TIME TICK":
      case "TIMETICK":
        return c.TIMETICK;
      default:
        return Number(k);
    }
  };
  c.toNoteString = function(k, e) {
    k = Math.round(k);
    var g = Math.floor((k - 24) / 12 + 1);
    k = (k - 21) % 12;
    0 > k && (k = 12 + k);
    return c.notes[k] + (e ? "" : g);
  };
  c.NoteStringToPitch = function(k) {
    k = k.toUpperCase();
    var e = k[0], g = 4;
    "#" == k[1] ? (e += "#", 2 < k.length && (g = Number(k[2]))) : 1 < k.length && (g = Number(k[1]));
    k = c.note_to_index[e];
    return null == k ? null : 12 * (g - 1) + k + 21;
  };
  c.prototype.toString = function() {
    var k = "" + this.channel + ". ";
    switch(this.cmd) {
      case c.NOTEON:
        k += "NOTEON " + c.toNoteString(this.data[1]);
        break;
      case c.NOTEOFF:
        k += "NOTEOFF " + c.toNoteString(this.data[1]);
        break;
      case c.CONTROLLERCHANGE:
        k += "CC " + this.data[1] + " " + this.data[2];
        break;
      case c.PROGRAMCHANGE:
        k += "PC " + this.data[1];
        break;
      case c.PITCHBEND:
        k += "PITCHBEND " + this.getPitchBend();
        break;
      case c.KEYPRESSURE:
        k += "KEYPRESS " + this.data[1];
    }
    return k;
  };
  c.prototype.toHexString = function() {
    for (var c = "", e = 0; e < this.data.length; e++) {
      c += this.data[e].toString(16) + " ";
    }
  };
  c.prototype.toJSON = function() {
    return {data:[this.data[0], this.data[1], this.data[2]], object_class:"MIDIEvent"};
  };
  c.NOTEOFF = 128;
  c.NOTEON = 144;
  c.KEYPRESSURE = 160;
  c.CONTROLLERCHANGE = 176;
  c.PROGRAMCHANGE = 192;
  c.CHANNELPRESSURE = 208;
  c.PITCHBEND = 224;
  c.TIMETICK = 248;
  c.commands = {128:"note off", 144:"note on", 160:"key pressure", 176:"controller change", 192:"program change", 208:"channel pressure", 224:"pitch bend", 240:"system", 242:"Song pos", 243:"Song select", 246:"Tune request", 248:"time tick", 250:"Start Song", 251:"Continue Song", 252:"Stop Song", 254:"Sensing", 255:"Reset"};
  c.commands_short = {128:"NOTEOFF", 144:"NOTEOFF", 160:"KEYP", 176:"CC", 192:"PC", 208:"CP", 224:"PB", 240:"SYS", 242:"POS", 243:"SELECT", 246:"TUNEREQ", 248:"TT", 250:"START", 251:"CONTINUE", 252:"STOP", 254:"SENS", 255:"RESET"};
  c.commands_reversed = {};
  for (var K in c.commands) {
    c.commands_reversed[c.commands[K]] = K;
  }
  g.input = null;
  g.MIDIEvent = c;
  g.prototype.onMIDISuccess = function(c) {
    console.log("MIDI ready!");
    console.log(c);
    this.midi = c;
    this.updatePorts();
    if (this.on_ready) {
      this.on_ready(this);
    }
  };
  g.prototype.updatePorts = function() {
    var c = this.midi;
    this.input_ports = c.inputs;
    this.input_ports_info = [];
    this.output_ports = c.outputs;
    this.output_ports_info = [];
    c = 0;
    for (var e = this.input_ports.values(), g = e.next(); g && !1 === g.done;) {
      g = g.value, this.input_ports_info.push(g), console.log("Input port [type:'" + g.type + "'] id:'" + g.id + "' manufacturer:'" + g.manufacturer + "' name:'" + g.name + "' version:'" + g.version + "'"), c++, g = e.next();
    }
    this.num_input_ports = c;
    c = 0;
    e = this.output_ports.values();
    for (g = e.next(); g && !1 === g.done;) {
      g = g.value, this.output_ports_info.push(g), console.log("Output port [type:'" + g.type + "'] id:'" + g.id + "' manufacturer:'" + g.manufacturer + "' name:'" + g.name + "' version:'" + g.version + "'"), c++, g = e.next();
    }
    this.num_output_ports = c;
  };
  g.prototype.onMIDIFailure = function(c) {
    console.error("Failed to get MIDI access - " + c);
  };
  g.prototype.openInputPort = function(e, l) {
    e = this.input_ports.get("input-" + e);
    if (!e) {
      return !1;
    }
    g.input = this;
    var k = this;
    e.onmidimessage = function(a) {
      var b = new c(a.data);
      k.updateState(b);
      l && l(a.data, b);
      if (g.on_message) {
        g.on_message(a.data, b);
      }
    };
    console.log("port open: ", e);
    return !0;
  };
  g.parseMsg = function(c) {
  };
  g.prototype.updateState = function(e) {
    switch(e.cmd) {
      case c.NOTEON:
        this.state.note[e.value1 | 0] = e.value2;
        break;
      case c.NOTEOFF:
        this.state.note[e.value1 | 0] = 0;
        break;
      case c.CONTROLLERCHANGE:
        this.state.cc[e.getCC()] = e.getCCValue();
    }
  };
  g.prototype.sendMIDI = function(e, l) {
    l && (e = this.output_ports_info[e]) && (g.output = this, l.constructor === c ? e.send(l.data) : e.send(l));
  };
  n.MIDIInterface = g;
  n.title = "MIDI Input";
  n.desc = "Reads MIDI from a input port";
  n.color = "#243";
  n.prototype.getPropertyInfo = function(c) {
    if (this._midi && "port" == c) {
      c = {};
      for (var e = 0; e < this._midi.input_ports_info.length; ++e) {
        var k = this._midi.input_ports_info[e];
        c[e] = e + ".- " + k.name + " version:" + k.version;
      }
      return {type:"enum", values:c};
    }
  };
  n.prototype.onStart = function() {
    this._midi ? this._midi.openInputPort(this.properties.port, this.onMIDIEvent.bind(this)) : this._waiting = !0;
  };
  n.prototype.onMIDIEvent = function(e, g) {
    this._last_midi_event = g;
    this.boxcolor = "#AFA";
    this._last_time = x.getTime();
    this.trigger("on_midi", g);
    g.cmd == c.NOTEON ? this.trigger("on_noteon", g) : g.cmd == c.NOTEOFF ? this.trigger("on_noteoff", g) : g.cmd == c.CONTROLLERCHANGE ? this.trigger("on_cc", g) : g.cmd == c.PROGRAMCHANGE ? this.trigger("on_pc", g) : g.cmd == c.PITCHBEND && this.trigger("on_pitchbend", g);
  };
  n.prototype.onDrawBackground = function(c) {
    this.boxcolor = "#AAA";
    if (!this.flags.collapsed && this._last_midi_event) {
      c.fillStyle = "white";
      var e = x.getTime();
      e = 1.0 - Math.max(0, 0.001 * (e - this._last_time));
      if (0 < e) {
        var k = c.globalAlpha;
        c.globalAlpha *= e;
        c.font = "12px Tahoma";
        c.fillText(this._last_midi_event.toString(), 2, 0.5 * this.size[1] + 3);
        c.globalAlpha = k;
      }
    }
  };
  n.prototype.onExecute = function() {
    if (this.outputs) {
      for (var c = this._last_midi_event, e = 0; e < this.outputs.length; ++e) {
        switch(this.outputs[e].name) {
          case "midi":
            var g = this._midi;
            break;
          case "last_midi":
            g = c;
            break;
          default:
            continue;
        }
        this.setOutputData(e, g);
      }
    }
  };
  n.prototype.onGetOutputs = function() {
    return [["last_midi", "midi"], ["on_midi", x.EVENT], ["on_noteon", x.EVENT], ["on_noteoff", x.EVENT], ["on_cc", x.EVENT], ["on_pc", x.EVENT], ["on_pitchbend", x.EVENT]];
  };
  x.registerNodeType("midi/input", n);
  m.MIDIInterface = g;
  m.title = "MIDI Output";
  m.desc = "Sends MIDI to output channel";
  m.color = "#243";
  m.prototype.onGetPropertyInfo = function(c) {
    if (this._midi && "port" == c) {
      return {type:"enum", values:this.getMIDIOutputs()};
    }
  };
  m.default_ports = {0:"unknown"};
  m.prototype.getMIDIOutputs = function() {
    var c = {};
    if (!this._midi) {
      return m.default_ports;
    }
    if (this._midi.output_ports_info) {
      for (var e = 0; e < this._midi.output_ports_info.length; ++e) {
        var g = this._midi.output_ports_info[e];
        g && (c[e] = e + ".- " + g.name + " version:" + g.version);
      }
    }
    return c;
  };
  m.prototype.onAction = function(c, e) {
    this._midi && ("send" == c && this._midi.sendMIDI(this.properties.port, e), this.trigger("midi", e));
  };
  m.prototype.onGetInputs = function() {
    return [["send", x.ACTION]];
  };
  m.prototype.onGetOutputs = function() {
    return [["on_midi", x.EVENT]];
  };
  x.registerNodeType("midi/output", m);
  u.title = "MIDI Show";
  u.desc = "Shows MIDI in the graph";
  u.color = "#243";
  u.prototype.getTitle = function() {
    return this.flags.collapsed ? this._str : this.title;
  };
  u.prototype.onAction = function(e, g) {
    g && (this._str = g.constructor === c ? g.toString() : "???");
  };
  u.prototype.onDrawForeground = function(c) {
    this._str && !this.flags.collapsed && (c.font = "30px Arial", c.fillText(this._str, 10, 0.8 * this.size[1]));
  };
  u.prototype.onGetInputs = function() {
    return [["in", x.ACTION]];
  };
  u.prototype.onGetOutputs = function() {
    return [["on_midi", x.EVENT]];
  };
  x.registerNodeType("midi/show", u);
  l.title = "MIDI Filter";
  l.desc = "Filters MIDI messages";
  l.color = "#243";
  l["@cmd"] = {type:"enum", title:"Command", values:c.commands_reversed};
  l.prototype.getTitle = function() {
    var e = -1 == this.properties.cmd ? "Nothing" : c.commands_short[this.properties.cmd] || "Unknown";
    -1 != this.properties.min_value && -1 != this.properties.max_value && (e += " " + (this.properties.min_value == this.properties.max_value ? this.properties.max_value : this.properties.min_value + ".." + this.properties.max_value));
    return "Filter: " + e;
  };
  l.prototype.onPropertyChanged = function(e, g) {
    "cmd" == e && (e = Number(g), isNaN(e) && (e = c.commands[g] || 0), this.properties.cmd = e);
  };
  l.prototype.onAction = function(e, g) {
    if (g && g.constructor === c) {
      if (this._learning) {
        this._learning = !1, this.boxcolor = "#AAA", this.properties.channel = g.channel, this.properties.cmd = g.cmd, this.properties.min_value = this.properties.max_value = g.data[1];
      } else {
        if (-1 != this.properties.channel && g.channel != this.properties.channel || -1 != this.properties.cmd && g.cmd != this.properties.cmd || -1 != this.properties.min_value && g.data[1] < this.properties.min_value || -1 != this.properties.max_value && g.data[1] > this.properties.max_value) {
          return;
        }
      }
      this.trigger("on_midi", g);
    }
  };
  x.registerNodeType("midi/filter", l);
  G.title = "MIDIEvent";
  G.desc = "Create a MIDI Event";
  G.color = "#243";
  G.prototype.onAction = function(e, g) {
    "assign" == e ? (this.properties.channel = g.channel, this.properties.cmd = g.cmd, this.properties.value1 = g.data[1], this.properties.value2 = g.data[2], g.cmd == c.NOTEON ? this.gate = !0 : g.cmd == c.NOTEOFF && (this.gate = !1)) : (g = this.midi_event, g.channel = this.properties.channel, this.properties.cmd && this.properties.cmd.constructor === String ? g.setCommandFromString(this.properties.cmd) : g.cmd = this.properties.cmd, g.data[0] = g.cmd | g.channel, g.data[1] = Number(this.properties.value1), 
    g.data[2] = Number(this.properties.value2), this.trigger("on_midi", g));
  };
  G.prototype.onExecute = function() {
    var e = this.properties;
    if (this.inputs) {
      for (var g = 0; g < this.inputs.length; ++g) {
        var l = this.inputs[g];
        if (-1 != l.link) {
          switch(l.name) {
            case "note":
              l = this.getInputData(g);
              null != l && (l.constructor === String && (l = c.NoteStringToPitch(l)), this.properties.value1 = (l | 0) % 255);
              break;
            case "cmd":
              l = this.getInputData(g);
              null != l && (this.properties.cmd = l);
              break;
            case "value1":
              l = this.getInputData(g);
              null != l && (this.properties.value1 = Math.clamp(l | 0, 0, 127));
              break;
            case "value2":
              l = this.getInputData(g), null != l && (this.properties.value2 = Math.clamp(l | 0, 0, 127));
          }
        }
      }
    }
    if (this.outputs) {
      for (g = 0; g < this.outputs.length; ++g) {
        switch(this.outputs[g].name) {
          case "midi":
            l = new c;
            l.setup([e.cmd, e.value1, e.value2]);
            l.channel = e.channel;
            break;
          case "command":
            l = e.cmd;
            break;
          case "cc":
            l = e.value1;
            break;
          case "cc_value":
            l = e.value2;
            break;
          case "note":
            l = e.cmd == c.NOTEON || e.cmd == c.NOTEOFF ? e.value1 : null;
            break;
          case "velocity":
            l = e.cmd == c.NOTEON ? e.value2 : null;
            break;
          case "pitch":
            l = e.cmd == c.NOTEON ? c.computePitch(e.value1) : null;
            break;
          case "pitchbend":
            l = e.cmd == c.PITCHBEND ? c.computePitchBend(e.value1, e.value2) : null;
            break;
          case "gate":
            l = this.gate;
            break;
          default:
            continue;
        }
        null !== l && this.setOutputData(g, l);
      }
    }
  };
  G.prototype.onPropertyChanged = function(e, g) {
    "cmd" == e && (this.properties.cmd = c.computeCommandFromString(g));
  };
  G.prototype.onGetInputs = function() {
    return [["cmd", "number"], ["note", "number"], ["value1", "number"], ["value2", "number"]];
  };
  G.prototype.onGetOutputs = function() {
    return [["midi", "midi"], ["on_midi", x.EVENT], ["command", "number"], ["note", "number"], ["velocity", "number"], ["cc", "number"], ["cc_value", "number"], ["pitch", "number"], ["gate", "bool"], ["pitchbend", "number"]];
  };
  x.registerNodeType("midi/event", G);
  A.title = "MIDICC";
  A.desc = "gets a Controller Change";
  A.color = "#243";
  A.prototype.onExecute = function() {
    g.input && (this.properties.value = g.input.state.cc[this.properties.cc]);
    this.setOutputData(0, this.properties.value);
  };
  x.registerNodeType("midi/cc", A);
  D.title = "MIDI Generator";
  D.desc = "Generates a random MIDI note";
  D.color = "#243";
  D.processScale = function(e) {
    e = e.split(",");
    for (var g = 0; g < e.length; ++g) {
      var k = e[g];
      e[g] = 2 == k.length && "#" != k[1] || 2 < k.length ? -x.MIDIEvent.NoteStringToPitch(k) : c.note_to_index[k] || 0;
    }
    return e;
  };
  D.prototype.onPropertyChanged = function(c, e) {
    "notes" == c && (this.notes_pitches = D.processScale(e));
  };
  D.prototype.onExecute = function() {
    var c = this.getInputData(2);
    null != c && (this.properties.octave = c);
    if (c = this.getInputData(1)) {
      this.notes_pitches = D.processScale(c);
    }
  };
  D.prototype.onAction = function(e, g) {
    var k = 0;
    g = this.notes_pitches.length;
    e = 0;
    "sequence" == this.properties.mode ? e = this.sequence_index = (this.sequence_index + 1) % g : "random" == this.properties.mode && (e = Math.floor(Math.random() * g));
    g = this.notes_pitches[e];
    k = 0 <= g ? g + 12 * (this.properties.octave - 1) + 33 : -g;
    g = new c;
    g.setup([c.NOTEON, k, 10]);
    e = this.properties.duration || 1;
    this.trigger("note", g);
    setTimeout(function() {
      var a = new c;
      a.setup([c.NOTEOFF, k, 0]);
      this.trigger("note", a);
    }.bind(this), 1000 * e);
  };
  x.registerNodeType("midi/generator", D);
  B.title = "MIDI Transpose";
  B.desc = "Transpose a MIDI note";
  B.color = "#243";
  B.prototype.onAction = function(e, g) {
    g && g.constructor === c && (g.data[0] == c.NOTEON || g.data[0] == c.NOTEOFF ? (this.midi_event = new c, this.midi_event.setup(g.data), this.midi_event.data[1] = Math.round(this.midi_event.data[1] + this.properties.amount), this.trigger("out", this.midi_event)) : this.trigger("out", g));
  };
  B.prototype.onExecute = function() {
    var c = this.getInputData(1);
    null != c && (this.properties.amount = c);
  };
  x.registerNodeType("midi/transpose", B);
  F.title = "MIDI Quantize Pitch";
  F.desc = "Transpose a MIDI note tp fit an scale";
  F.color = "#243";
  F.prototype.onPropertyChanged = function(c, e) {
    "scale" == c && this.processScale(e);
  };
  F.prototype.processScale = function(c) {
    this._current_scale = c;
    this.notes_pitches = D.processScale(c);
    for (c = 0; 12 > c; ++c) {
      this.valid_notes[c] = -1 != this.notes_pitches.indexOf(c);
    }
    for (c = 0; 12 > c; ++c) {
      if (this.valid_notes[c]) {
        this.offset_notes[c] = 0;
      } else {
        for (var e = 1; 12 > e; ++e) {
          if (this.valid_notes[(c - e) % 12]) {
            this.offset_notes[c] = -e;
            break;
          }
          if (this.valid_notes[(c + e) % 12]) {
            this.offset_notes[c] = e;
            break;
          }
        }
      }
    }
  };
  F.prototype.onAction = function(e, g) {
    g && g.constructor === c && (g.data[0] == c.NOTEON || g.data[0] == c.NOTEOFF ? (this.midi_event = new c, this.midi_event.setup(g.data), this.midi_event.data[1] += this.offset_notes[c.note_to_index[g.note]], this.trigger("out", this.midi_event)) : this.trigger("out", g));
  };
  F.prototype.onExecute = function() {
    var c = this.getInputData(1);
    null != c && c != this._current_scale && this.processScale(c);
  };
  x.registerNodeType("midi/quantize", F);
  e.title = "MIDI fromFile";
  e.desc = "Plays a MIDI file";
  e.color = "#243";
  e.prototype.onAction = function(c) {
    "play" == c ? this.play() : "pause" == c && (this._playing = !this._playing);
  };
  e.prototype.onPropertyChanged = function(c, e) {
    "url" == c && this.loadMIDIFile(e);
  };
  e.prototype.onExecute = function() {
    if (this._midi && this._playing) {
      this._current_time += this.graph.elapsed_time;
      for (var e = 100 * this._current_time, g = 0; g < this._midi.tracks; ++g) {
        var l = this._midi.track[g];
        l._last_pos || (l._last_pos = 0, l._time = 0);
        var a = l.event[l._last_pos];
        if (a && l._time + a.deltaTime <= e && (l._last_pos++, l._time += a.deltaTime, a.data)) {
          l = a.type << 4 + a.channel;
          var b = new c;
          b.setup([l, a.data[0], a.data[1]]);
          this.trigger("note", b);
        }
      }
    }
  };
  e.prototype.play = function() {
    this._playing = !0;
    this._current_time = 0;
    if (this._midi) {
      for (var c = 0; c < this._midi.tracks; ++c) {
        var e = this._midi.track[c];
        e._last_pos = 0;
        e._time = 0;
      }
    }
  };
  e.prototype.loadMIDIFile = function(c) {
    var e = this;
    x.fetchFile(c, "arraybuffer", function(c) {
      e.boxcolor = "#AFA";
      e._midi = MidiParser.parse(new Uint8Array(c));
      e.properties.autoplay && e.play();
    }, function(c) {
      e.boxcolor = "#FAA";
      e._midi = null;
    });
  };
  e.prototype.onDropFile = function(c) {
    this.properties.url = "";
    this.loadMIDIFile(c);
  };
  x.registerNodeType("midi/fromFile", e);
  z.title = "MIDI Play";
  z.desc = "Plays a MIDI note";
  z.color = "#243";
  z.prototype.onAction = function(e, g) {
    if (g && g.constructor === c) {
      if (this.instrument && g.data[0] == c.NOTEON) {
        e = g.note;
        if (!e || "undefined" == e || e.constructor !== String) {
          return;
        }
        this.instrument.play(e, g.octave, this.properties.duration, this.properties.volume);
      }
      this.trigger("note", g);
    }
  };
  z.prototype.onExecute = function() {
    var c = this.getInputData(1);
    null != c && (this.properties.volume = c);
    c = this.getInputData(2);
    null != c && (this.properties.duration = c);
  };
  x.registerNodeType("midi/play", z);
  H.title = "MIDI Keys";
  H.desc = "Keyboard to play notes";
  H.color = "#243";
  H.keys = [{x:0, w:1, h:1, t:0}, {x:0.75, w:0.5, h:0.6, t:1}, {x:1, w:1, h:1, t:0}, {x:1.75, w:0.5, h:0.6, t:1}, {x:2, w:1, h:1, t:0}, {x:2.75, w:0.5, h:0.6, t:1}, {x:3, w:1, h:1, t:0}, {x:4, w:1, h:1, t:0}, {x:4.75, w:0.5, h:0.6, t:1}, {x:5, w:1, h:1, t:0}, {x:5.75, w:0.5, h:0.6, t:1}, {x:6, w:1, h:1, t:0}];
  H.prototype.onDrawForeground = function(c) {
    if (!this.flags.collapsed) {
      var e = 12 * this.properties.num_octaves;
      this.keys.length = e;
      var g = this.size[0] / (7 * this.properties.num_octaves), a = this.size[1];
      c.globalAlpha = 1;
      for (var b = 0; 2 > b; b++) {
        for (var d = 0; d < e; ++d) {
          var f = H.keys[d % 12];
          if (f.t == b) {
            var h = 7 * Math.floor(d / 12) * g + f.x * g;
            c.fillStyle = 0 == b ? this.keys[d] ? "#CCC" : "white" : this.keys[d] ? "#333" : "black";
            c.fillRect(h + 1, 0, g * f.w - 2, a * f.h);
          }
        }
      }
    }
  };
  H.prototype.getKeyIndex = function(c) {
    for (var e = this.size[0] / (7 * this.properties.num_octaves), g = this.size[1], a = 1; 0 <= a; a--) {
      for (var b = 0; b < this.keys.length; ++b) {
        var d = H.keys[b % 12];
        if (d.t == a) {
          var f = 7 * Math.floor(b / 12) * e + d.x * e, h = e * d.w;
          d = g * d.h;
          if (!(c[0] < f || c[0] > f + h || c[1] > d)) {
            return b;
          }
        }
      }
    }
    return -1;
  };
  H.prototype.onAction = function(e, g) {
    if ("reset" == e) {
      for (g = 0; g < this.keys.length; ++g) {
        this.keys[g] = !1;
      }
    } else {
      g && g.constructor === c && (e = g.data[1] - (12 * (this.properties.start_octave - 1) + 29), 0 <= e && e < this.keys.length && (g.data[0] == c.NOTEON ? this.keys[e] = !0 : g.data[0] == c.NOTEOFF && (this.keys[e] = !1)), this.trigger("note", g));
    }
  };
  H.prototype.onMouseDown = function(e, g) {
    if (!(0 > g[1])) {
      return e = this.getKeyIndex(g), this.keys[e] = !0, this._last_key = e, e = 12 * (this.properties.start_octave - 1) + 29 + e, g = new c, g.setup([c.NOTEON, e, 100]), this.trigger("note", g), !0;
    }
  };
  H.prototype.onMouseMove = function(e, g) {
    if (!(0 > g[1] || -1 == this._last_key)) {
      this.setDirtyCanvas(!0);
      e = this.getKeyIndex(g);
      if (this._last_key == e) {
        return !0;
      }
      this.keys[this._last_key] = !1;
      g = 12 * (this.properties.start_octave - 1) + 29 + this._last_key;
      var k = new c;
      k.setup([c.NOTEOFF, g, 100]);
      this.trigger("note", k);
      this.keys[e] = !0;
      g = 12 * (this.properties.start_octave - 1) + 29 + e;
      k = new c;
      k.setup([c.NOTEON, g, 100]);
      this.trigger("note", k);
      this._last_key = e;
      return !0;
    }
  };
  H.prototype.onMouseUp = function(e, g) {
    if (!(0 > g[1])) {
      return e = this.getKeyIndex(g), this.keys[e] = !1, this._last_key = -1, e = 12 * (this.properties.start_octave - 1) + 29 + e, g = new c, g.setup([c.NOTEOFF, e, 100]), this.trigger("note", g), !0;
    }
  };
  x.registerNodeType("midi/keys", H);
})(this);
(function(y) {
  function c() {
    this.properties = {src:"", gain:0.5, loop:!0, autoplay:!0, playbackRate:1};
    this._loading_audio = !1;
    this._audiobuffer = null;
    this._audionodes = [];
    this._last_sourcenode = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = q.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
    this.properties.src && this.loadSound(this.properties.src);
  }
  function g() {
    this.properties = {gain:0.5};
    this._audionodes = [];
    this._media_stream = null;
    this.addOutput("out", "audio");
    this.addInput("gain", "number");
    this.audionode = q.getAudioContext().createGain();
    this.audionode.graphnode = this;
    this.audionode.gain.value = this.properties.gain;
  }
  function n() {
    this.properties = {fftSize:2048, minDecibels:-100, maxDecibels:-10, smoothingTimeConstant:0.5};
    this.audionode = q.getAudioContext().createAnalyser();
    this.audionode.graphnode = this;
    this.audionode.fftSize = this.properties.fftSize;
    this.audionode.minDecibels = this.properties.minDecibels;
    this.audionode.maxDecibels = this.properties.maxDecibels;
    this.audionode.smoothingTimeConstant = this.properties.smoothingTimeConstant;
    this.addInput("in", "audio");
    this.addOutput("freqs", "array");
    this.addOutput("samples", "array");
    this._time_bin = this._freq_bin = null;
  }
  function m() {
    this.properties = {gain:1};
    this.audionode = q.getAudioContext().createGain();
    this.addInput("in", "audio");
    this.addInput("gain", "number");
    this.addOutput("out", "audio");
  }
  function u() {
    this.properties = {impulse_src:"", normalize:!0};
    this.audionode = q.getAudioContext().createConvolver();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function l() {
    this.properties = {threshold:-50, knee:40, ratio:12, reduction:-20, attack:0, release:0.25};
    this.audionode = q.getAudioContext().createDynamicsCompressor();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function G() {
    this.properties = {};
    this.audionode = q.getAudioContext().createWaveShaper();
    this.addInput("in", "audio");
    this.addInput("shape", "waveshape");
    this.addOutput("out", "audio");
  }
  function A() {
    this.properties = {gain1:0.5, gain2:0.5};
    this.audionode = q.getAudioContext().createGain();
    this.audionode1 = q.getAudioContext().createGain();
    this.audionode1.gain.value = this.properties.gain1;
    this.audionode2 = q.getAudioContext().createGain();
    this.audionode2.gain.value = this.properties.gain2;
    this.audionode1.connect(this.audionode);
    this.audionode2.connect(this.audionode);
    this.addInput("in1", "audio");
    this.addInput("in1 gain", "number");
    this.addInput("in2", "audio");
    this.addInput("in2 gain", "number");
    this.addOutput("out", "audio");
  }
  function D() {
    this.properties = {A:0.1, D:0.1, S:0.1, R:0.1};
    this.audionode = q.getAudioContext().createGain();
    this.audionode.gain.value = 0;
    this.addInput("in", "audio");
    this.addInput("gate", "bool");
    this.addOutput("out", "audio");
    this.gate = !1;
  }
  function B() {
    this.properties = {delayTime:0.5};
    this.audionode = q.getAudioContext().createDelay(10);
    this.audionode.delayTime.value = this.properties.delayTime;
    this.addInput("in", "audio");
    this.addInput("time", "number");
    this.addOutput("out", "audio");
  }
  function F() {
    this.properties = {frequency:350, detune:0, Q:1};
    this.addProperty("type", "lowpass", "enum", {values:"lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ")});
    this.audionode = q.getAudioContext().createBiquadFilter();
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function e() {
    this.properties = {frequency:440, detune:0, type:"sine"};
    this.addProperty("type", "sine", "enum", {values:["sine", "square", "sawtooth", "triangle", "custom"]});
    this.audionode = q.getAudioContext().createOscillator();
    this.addOutput("out", "audio");
  }
  function z() {
    this.properties = {continuous:!0, mark:-1};
    this.addInput("data", "array");
    this.addInput("mark", "number");
    this.size = [300, 200];
    this._last_buffer = null;
  }
  function H() {
    this.properties = {band:440, amplitude:1};
    this.addInput("freqs", "array");
    this.addOutput("signal", "number");
  }
  function x() {
    if (!x.default_code) {
      var c = x.default_function.toString(), a = c.indexOf("{") + 1, b = c.lastIndexOf("}");
      x.default_code = c.substr(a, b - a);
    }
    this.properties = {code:x.default_code};
    c = q.getAudioContext();
    c.createScriptProcessor ? this.audionode = c.createScriptProcessor(4096, 1, 1) : (console.warn("ScriptProcessorNode deprecated"), this.audionode = c.createGain());
    this.processCode();
    x._bypass_function || (x._bypass_function = this.audionode.onaudioprocess);
    this.addInput("in", "audio");
    this.addOutput("out", "audio");
  }
  function K() {
    this.audionode = q.getAudioContext().destination;
    this.addInput("in", "audio");
  }
  var k = y.LiteGraph, q = {};
  y.LGAudio = q;
  q.getAudioContext = function() {
    if (!this._audio_context) {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!window.AudioContext) {
        return console.error("AudioContext not supported by browser"), null;
      }
      this._audio_context = new AudioContext;
      this._audio_context.onmessage = function(c) {
        console.log("msg", c);
      };
      this._audio_context.onended = function(c) {
        console.log("ended", c);
      };
      this._audio_context.oncomplete = function(c) {
        console.log("complete", c);
      };
    }
    return this._audio_context;
  };
  q.connect = function(c, a) {
    try {
      c.connect(a);
    } catch (b) {
      console.warn("LGraphAudio:", b);
    }
  };
  q.disconnect = function(c, a) {
    try {
      c.disconnect(a);
    } catch (b) {
      console.warn("LGraphAudio:", b);
    }
  };
  q.changeAllAudiosConnections = function(c, a) {
    if (c.inputs) {
      for (var b = 0; b < c.inputs.length; ++b) {
        var d = c.graph.links[c.inputs[b].link];
        if (d) {
          var f = c.graph.getNodeById(d.origin_id);
          f = f.getAudioNodeInOutputSlot ? f.getAudioNodeInOutputSlot(d.origin_slot) : f.audionode;
          d = c.getAudioNodeInInputSlot ? c.getAudioNodeInInputSlot(b) : c.audionode;
          a ? q.connect(f, d) : q.disconnect(f, d);
        }
      }
    }
    if (c.outputs) {
      for (b = 0; b < c.outputs.length; ++b) {
        for (var h = c.outputs[b], e = 0; e < h.links.length; ++e) {
          if (d = c.graph.links[h.links[e]]) {
            f = c.getAudioNodeInOutputSlot ? c.getAudioNodeInOutputSlot(b) : c.audionode;
            var g = c.graph.getNodeById(d.target_id);
            d = g.getAudioNodeInInputSlot ? g.getAudioNodeInInputSlot(d.target_slot) : g.audionode;
            a ? q.connect(f, d) : q.disconnect(f, d);
          }
        }
      }
    }
  };
  q.onConnectionsChange = function(c, a, b, d) {
    c == k.OUTPUT && (c = null, d && (c = this.graph.getNodeById(d.target_id)), c && (a = this.getAudioNodeInOutputSlot ? this.getAudioNodeInOutputSlot(a) : this.audionode, d = c.getAudioNodeInInputSlot ? c.getAudioNodeInInputSlot(d.target_slot) : c.audionode, b ? q.connect(a, d) : q.disconnect(a, d)));
  };
  q.createAudioNodeWrapper = function(c) {
    var a = c.prototype.onPropertyChanged;
    c.prototype.onPropertyChanged = function(b, d) {
      a && a.call(this, b, d);
      this.audionode && void 0 !== this.audionode[b] && (void 0 !== this.audionode[b].value ? this.audionode[b].value = d : this.audionode[b] = d);
    };
    c.prototype.onConnectionsChange = q.onConnectionsChange;
  };
  q.cached_audios = {};
  q.loadSound = function(c, a, b) {
    function d(a) {
      console.log("Audio loading sample error:", a);
      b && b(a);
    }
    if (q.cached_audios[c] && -1 == c.indexOf("blob:")) {
      a && a(q.cached_audios[c]);
    } else {
      q.onProcessAudioURL && (c = q.onProcessAudioURL(c));
      var f = new XMLHttpRequest;
      f.open("GET", c, !0);
      f.responseType = "arraybuffer";
      var h = q.getAudioContext();
      f.onload = function() {
        console.log("AudioSource loaded");
        h.decodeAudioData(f.response, function(b) {
          console.log("AudioSource decoded");
          q.cached_audios[c] = b;
          a && a(b);
        }, d);
      };
      f.send();
      return f;
    }
  };
  c.desc = "Plays an audio file";
  c["@src"] = {widget:"resource"};
  c.supported_extensions = ["wav", "ogg", "mp3"];
  c.prototype.onAdded = function(c) {
    if (c.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  c.prototype.onStart = function() {
    this._audiobuffer && this.properties.autoplay && this.playBuffer(this._audiobuffer);
  };
  c.prototype.onStop = function() {
    this.stopAllSounds();
  };
  c.prototype.onPause = function() {
    this.pauseAllSounds();
  };
  c.prototype.onUnpause = function() {
    this.unpauseAllSounds();
  };
  c.prototype.onRemoved = function() {
    this.stopAllSounds();
    this._dropped_url && URL.revokeObjectURL(this._url);
  };
  c.prototype.stopAllSounds = function() {
    for (var c = 0; c < this._audionodes.length; ++c) {
      this._audionodes[c].started && (this._audionodes[c].started = !1, this._audionodes[c].stop());
    }
    this._audionodes.length = 0;
  };
  c.prototype.pauseAllSounds = function() {
    q.getAudioContext().suspend();
  };
  c.prototype.unpauseAllSounds = function() {
    q.getAudioContext().resume();
  };
  c.prototype.onExecute = function() {
    if (this.inputs) {
      for (var c = 0; c < this.inputs.length; ++c) {
        var a = this.inputs[c];
        if (null != a.link) {
          var b = this.getInputData(c);
          if (void 0 !== b) {
            if ("gain" == a.name) {
              this.audionode.gain.value = b;
            } else {
              if ("src" == a.name) {
                this.setProperty("src", b);
              } else {
                if ("playbackRate" == a.name) {
                  for (this.properties.playbackRate = b, a = 0; a < this._audionodes.length; ++a) {
                    this._audionodes[a].playbackRate.value = b;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (this.outputs) {
      for (c = 0; c < this.outputs.length; ++c) {
        "buffer" == this.outputs[c].name && this._audiobuffer && this.setOutputData(c, this._audiobuffer);
      }
    }
  };
  c.prototype.onAction = function(c) {
    this._audiobuffer && ("Play" == c ? this.playBuffer(this._audiobuffer) : "Stop" == c && this.stopAllSounds());
  };
  c.prototype.onPropertyChanged = function(c, a) {
    if ("src" == c) {
      this.loadSound(a);
    } else {
      if ("gain" == c) {
        this.audionode.gain.value = a;
      } else {
        if ("playbackRate" == c) {
          for (c = 0; c < this._audionodes.length; ++c) {
            this._audionodes[c].playbackRate.value = a;
          }
        }
      }
    }
  };
  c.prototype.playBuffer = function(c) {
    var a = this, b = q.getAudioContext().createBufferSource();
    this._last_sourcenode = b;
    b.graphnode = this;
    b.buffer = c;
    b.loop = this.properties.loop;
    b.playbackRate.value = this.properties.playbackRate;
    this._audionodes.push(b);
    b.connect(this.audionode);
    this._audionodes.push(b);
    this.trigger("start");
    b.onended = function() {
      a.trigger("ended");
      var d = a._audionodes.indexOf(b);
      -1 != d && a._audionodes.splice(d, 1);
    };
    b.started || (b.started = !0, b.start());
    return b;
  };
  c.prototype.loadSound = function(c) {
    var a = this;
    this._request && (this._request.abort(), this._request = null);
    this._audiobuffer = null;
    this._loading_audio = !1;
    c && (this._request = q.loadSound(c, function(b) {
      this.boxcolor = k.NODE_DEFAULT_BOXCOLOR;
      a._audiobuffer = b;
      a._loading_audio = !1;
      if (a.graph && a.graph.status === LGraph.STATUS_RUNNING) {
        a.onStart();
      }
    }), this._loading_audio = !0, this.boxcolor = "#AA4");
  };
  c.prototype.onConnectionsChange = q.onConnectionsChange;
  c.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["src", "string"], ["Play", k.ACTION], ["Stop", k.ACTION]];
  };
  c.prototype.onGetOutputs = function() {
    return [["buffer", "audiobuffer"], ["start", k.EVENT], ["ended", k.EVENT]];
  };
  c.prototype.onDropFile = function(c) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    c = URL.createObjectURL(c);
    this.properties.src = c;
    this.loadSound(c);
    this._dropped_url = c;
  };
  c.title = "Source";
  c.desc = "Plays audio";
  k.registerNodeType("audio/source", c);
  g.prototype.onAdded = function(c) {
    if (c.status === LGraph.STATUS_RUNNING) {
      this.onStart();
    }
  };
  g.prototype.onStart = function() {
    null != this._media_stream || this._waiting_confirmation || this.openStream();
  };
  g.prototype.onStop = function() {
    this.audionode.gain.value = 0;
  };
  g.prototype.onPause = function() {
    this.audionode.gain.value = 0;
  };
  g.prototype.onUnpause = function() {
    this.audionode.gain.value = this.properties.gain;
  };
  g.prototype.onRemoved = function() {
    this.audionode.gain.value = 0;
    this.audiosource_node && (this.audiosource_node.disconnect(this.audionode), this.audiosource_node = null);
    if (this._media_stream) {
      var c = this._media_stream.getTracks();
      c.length && c[0].stop();
    }
  };
  g.prototype.openStream = function() {
    if (navigator.mediaDevices) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!0, video:!1}).then(this.streamReady.bind(this)).catch(function(a) {
        console.log("Media rejected", a);
        c._media_stream = !1;
        c.boxcolor = "red";
      });
      var c = this;
    } else {
      console.log("getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
    }
  };
  g.prototype.streamReady = function(c) {
    this._media_stream = c;
    this.audiosource_node && this.audiosource_node.disconnect(this.audionode);
    this.audiosource_node = q.getAudioContext().createMediaStreamSource(c);
    this.audiosource_node.graphnode = this;
    this.audiosource_node.connect(this.audionode);
    this.boxcolor = "white";
  };
  g.prototype.onExecute = function() {
    null != this._media_stream || this._waiting_confirmation || this.openStream();
    if (this.inputs) {
      for (var c = 0; c < this.inputs.length; ++c) {
        var a = this.inputs[c];
        if (null != a.link) {
          var b = this.getInputData(c);
          void 0 !== b && "gain" == a.name && (this.audionode.gain.value = this.properties.gain = b);
        }
      }
    }
  };
  g.prototype.onAction = function(c) {
    "Play" == c ? this.audionode.gain.value = this.properties.gain : "Stop" == c && (this.audionode.gain.value = 0);
  };
  g.prototype.onPropertyChanged = function(c, a) {
    "gain" == c && (this.audionode.gain.value = a);
  };
  g.prototype.onConnectionsChange = q.onConnectionsChange;
  g.prototype.onGetInputs = function() {
    return [["playbackRate", "number"], ["Play", k.ACTION], ["Stop", k.ACTION]];
  };
  g.title = "MediaSource";
  g.desc = "Plays microphone";
  k.registerNodeType("audio/media_source", g);
  n.prototype.onPropertyChanged = function(c, a) {
    this.audionode[c] = a;
  };
  n.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var c = this.audionode.frequencyBinCount;
      this._freq_bin && this._freq_bin.length == c || (this._freq_bin = new Uint8Array(c));
      this.audionode.getByteFrequencyData(this._freq_bin);
      this.setOutputData(0, this._freq_bin);
    }
    this.isOutputConnected(1) && (c = this.audionode.frequencyBinCount, this._time_bin && this._time_bin.length == c || (this._time_bin = new Uint8Array(c)), this.audionode.getByteTimeDomainData(this._time_bin), this.setOutputData(1, this._time_bin));
    for (c = 1; c < this.inputs.length; ++c) {
      var a = this.inputs[c];
      if (null != a.link) {
        var b = this.getInputData(c);
        void 0 !== b && (this.audionode[a.name].value = b);
      }
    }
  };
  n.prototype.onGetInputs = function() {
    return [["minDecibels", "number"], ["maxDecibels", "number"], ["smoothingTimeConstant", "number"]];
  };
  n.prototype.onGetOutputs = function() {
    return [["freqs", "array"], ["samples", "array"]];
  };
  n.title = "Analyser";
  n.desc = "Audio Analyser";
  k.registerNodeType("audio/analyser", n);
  m.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var c = 1; c < this.inputs.length; ++c) {
        var a = this.inputs[c], b = this.getInputData(c);
        void 0 !== b && (this.audionode[a.name].value = b);
      }
    }
  };
  q.createAudioNodeWrapper(m);
  m.title = "Gain";
  m.desc = "Audio gain";
  k.registerNodeType("audio/gain", m);
  q.createAudioNodeWrapper(u);
  u.prototype.onRemove = function() {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
  };
  u.prototype.onPropertyChanged = function(c, a) {
    "impulse_src" == c ? this.loadImpulse(a) : "normalize" == c && (this.audionode.normalize = a);
  };
  u.prototype.onDropFile = function(c) {
    this._dropped_url && URL.revokeObjectURL(this._dropped_url);
    this._dropped_url = URL.createObjectURL(c);
    this.properties.impulse_src = this._dropped_url;
    this.loadImpulse(this._dropped_url);
  };
  u.prototype.loadImpulse = function(c) {
    var a = this;
    this._request && (this._request.abort(), this._request = null);
    this._impulse_buffer = null;
    this._loading_impulse = !1;
    c && (this._request = q.loadSound(c, function(b) {
      a._impulse_buffer = b;
      a.audionode.buffer = b;
      console.log("Impulse signal set");
      a._loading_impulse = !1;
    }), this._loading_impulse = !0);
  };
  u.title = "Convolver";
  u.desc = "Convolves the signal (used for reverb)";
  k.registerNodeType("audio/convolver", u);
  q.createAudioNodeWrapper(l);
  l.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var c = 1; c < this.inputs.length; ++c) {
        var a = this.inputs[c];
        if (null != a.link) {
          var b = this.getInputData(c);
          void 0 !== b && (this.audionode[a.name].value = b);
        }
      }
    }
  };
  l.prototype.onGetInputs = function() {
    return [["threshold", "number"], ["knee", "number"], ["ratio", "number"], ["reduction", "number"], ["attack", "number"], ["release", "number"]];
  };
  l.title = "DynamicsCompressor";
  l.desc = "Dynamics Compressor";
  k.registerNodeType("audio/dynamicsCompressor", l);
  G.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      var c = this.getInputData(1);
      void 0 !== c && (this.audionode.curve = c);
    }
  };
  G.prototype.setWaveShape = function(c) {
    this.audionode.curve = c;
  };
  q.createAudioNodeWrapper(G);
  A.prototype.getAudioNodeInInputSlot = function(c) {
    if (0 == c) {
      return this.audionode1;
    }
    if (2 == c) {
      return this.audionode2;
    }
  };
  A.prototype.onPropertyChanged = function(c, a) {
    "gain1" == c ? this.audionode1.gain.value = a : "gain2" == c && (this.audionode2.gain.value = a);
  };
  A.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var c = 1; c < this.inputs.length; ++c) {
        var a = this.inputs[c];
        null != a.link && "audio" != a.type && (a = this.getInputData(c), void 0 !== a && (1 == c ? this.audionode1.gain.value = a : 3 == c && (this.audionode2.gain.value = a)));
      }
    }
  };
  q.createAudioNodeWrapper(A);
  A.title = "Mixer";
  A.desc = "Audio mixer";
  k.registerNodeType("audio/mixer", A);
  D.prototype.onExecute = function() {
    var c = q.getAudioContext().currentTime, a = this.audionode.gain, b = this.getInputData(1), d = this.getInputOrProperty("A"), f = this.getInputOrProperty("D"), h = this.getInputOrProperty("S"), e = this.getInputOrProperty("R");
    !this.gate && b ? (a.cancelScheduledValues(0), a.setValueAtTime(0, c), a.linearRampToValueAtTime(1, c + d), a.linearRampToValueAtTime(h, c + d + f)) : this.gate && !b && (a.cancelScheduledValues(0), a.setValueAtTime(a.value, c), a.linearRampToValueAtTime(0, c + e));
    this.gate = b;
  };
  D.prototype.onGetInputs = function() {
    return [["A", "number"], ["D", "number"], ["S", "number"], ["R", "number"]];
  };
  q.createAudioNodeWrapper(D);
  D.title = "ADSR";
  D.desc = "Audio envelope";
  k.registerNodeType("audio/adsr", D);
  q.createAudioNodeWrapper(B);
  B.prototype.onExecute = function() {
    var c = this.getInputData(1);
    void 0 !== c && (this.audionode.delayTime.value = c);
  };
  B.title = "Delay";
  B.desc = "Audio delay";
  k.registerNodeType("audio/delay", B);
  F.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var c = 1; c < this.inputs.length; ++c) {
        var a = this.inputs[c];
        if (null != a.link) {
          var b = this.getInputData(c);
          void 0 !== b && (this.audionode[a.name].value = b);
        }
      }
    }
  };
  F.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["Q", "number"]];
  };
  q.createAudioNodeWrapper(F);
  F.title = "BiquadFilter";
  F.desc = "Audio filter";
  k.registerNodeType("audio/biquadfilter", F);
  e.prototype.onStart = function() {
    if (!this.audionode.started) {
      this.audionode.started = !0;
      try {
        this.audionode.start();
      } catch (t) {
      }
    }
  };
  e.prototype.onStop = function() {
    this.audionode.started && (this.audionode.started = !1, this.audionode.stop());
  };
  e.prototype.onPause = function() {
    this.onStop();
  };
  e.prototype.onUnpause = function() {
    this.onStart();
  };
  e.prototype.onExecute = function() {
    if (this.inputs && this.inputs.length) {
      for (var c = 0; c < this.inputs.length; ++c) {
        var a = this.inputs[c];
        if (null != a.link) {
          var b = this.getInputData(c);
          void 0 !== b && (this.audionode[a.name].value = b);
        }
      }
    }
  };
  e.prototype.onGetInputs = function() {
    return [["frequency", "number"], ["detune", "number"], ["type", "string"]];
  };
  q.createAudioNodeWrapper(e);
  e.title = "Oscillator";
  e.desc = "Oscillator";
  k.registerNodeType("audio/oscillator", e);
  z.prototype.onExecute = function() {
    this._last_buffer = this.getInputData(0);
    var c = this.getInputData(1);
    void 0 !== c && (this.properties.mark = c);
    this.setDirtyCanvas(!0, !1);
  };
  z.prototype.onDrawForeground = function(c) {
    if (this._last_buffer) {
      var a = this._last_buffer, b = a.length / this.size[0], d = this.size[1];
      c.fillStyle = "black";
      c.fillRect(0, 0, this.size[0], this.size[1]);
      c.strokeStyle = "white";
      c.beginPath();
      var f = 0;
      if (this.properties.continuous) {
        c.moveTo(f, d);
        for (var h = 0; h < a.length; h += b) {
          c.lineTo(f, d - a[h | 0] / 255 * d), f++;
        }
      } else {
        for (h = 0; h < a.length; h += b) {
          c.moveTo(f + 0.5, d), c.lineTo(f + 0.5, d - a[h | 0] / 255 * d), f++;
        }
      }
      c.stroke();
      0 <= this.properties.mark && (a = q.getAudioContext().sampleRate / a.length, f = this.properties.mark / a * 2 / b, f >= this.size[0] && (f = this.size[0] - 1), c.strokeStyle = "red", c.beginPath(), c.moveTo(f, d), c.lineTo(f, 0), c.stroke());
    }
  };
  z.title = "Visualization";
  z.desc = "Audio Visualization";
  k.registerNodeType("audio/visualization", z);
  H.prototype.onExecute = function() {
    if (this._freqs = this.getInputData(0)) {
      var c = this.properties.band, a = this.getInputData(1);
      void 0 !== a && (c = a);
      a = q.getAudioContext().sampleRate / this._freqs.length;
      a = c / a * 2;
      a >= this._freqs.length ? a = this._freqs[this._freqs.length - 1] : (c = a | 0, a -= c, a = this._freqs[c] * (1 - a) + this._freqs[c + 1] * a);
      this.setOutputData(0, a / 255 * this.properties.amplitude);
    }
  };
  H.prototype.onGetInputs = function() {
    return [["band", "number"]];
  };
  H.title = "Signal";
  H.desc = "extract the signal of some frequency";
  k.registerNodeType("audio/signal", H);
  x.prototype.onAdded = function(c) {
    c.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback);
  };
  x["@code"] = {widget:"code", type:"code"};
  x.prototype.onStart = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  x.prototype.onStop = function() {
    this.audionode.onaudioprocess = x._bypass_function;
  };
  x.prototype.onPause = function() {
    this.audionode.onaudioprocess = x._bypass_function;
  };
  x.prototype.onUnpause = function() {
    this.audionode.onaudioprocess = this._callback;
  };
  x.prototype.onExecute = function() {
  };
  x.prototype.onRemoved = function() {
    this.audionode.onaudioprocess = x._bypass_function;
  };
  x.prototype.processCode = function() {
    try {
      this._script = new (new Function("properties", this.properties.code))(this.properties), this._old_code = this.properties.code, this._callback = this._script.onaudioprocess;
    } catch (t) {
      console.error("Error in onaudioprocess code", t), this._callback = x._bypass_function, this.audionode.onaudioprocess = this._callback;
    }
  };
  x.prototype.onPropertyChanged = function(c, a) {
    "code" == c && (this.properties.code = a, this.processCode(), this.graph && this.graph.status == LGraph.STATUS_RUNNING && (this.audionode.onaudioprocess = this._callback));
  };
  x.default_function = function() {
    this.onaudioprocess = function(c) {
      var a = c.inputBuffer;
      c = c.outputBuffer;
      for (var b = 0; b < c.numberOfChannels; b++) {
        for (var d = a.getChannelData(b), f = c.getChannelData(b), h = 0; h < a.length; h++) {
          f[h] = d[h];
        }
      }
    };
  };
  q.createAudioNodeWrapper(x);
  x.title = "Script";
  x.desc = "apply script to signal";
  k.registerNodeType("audio/script", x);
  K.title = "Destination";
  K.desc = "Audio output";
  k.registerNodeType("audio/destination", K);
})(this);
(function(y) {
  function c() {
    this.addInput("A", "Number");
    this.addInput("B", "Number");
    this.addInput("C", "Number");
    this.addInput("D", "Number");
    this.values = [[], [], [], []];
    this.properties = {scale:2};
  }
  function g() {
    this.addOutput("frame", "image");
    this.properties = {url:""};
  }
  function n() {
    this.addInput("f", "number");
    this.addOutput("Color", "color");
    this.properties = {colorA:"#444444", colorB:"#44AAFF", colorC:"#44FFAA", colorD:"#FFFFFF"};
  }
  function m() {
    this.addInput("", "image,canvas");
    this.size = [200, 200];
  }
  function u() {
    this.addInputs([["img1", "image"], ["img2", "image"], ["fade", "number"]]);
    this.addOutput("", "image");
    this.properties = {fade:0.5, width:512, height:512};
  }
  function l() {
    this.addInput("", "image");
    this.addOutput("", "image");
    this.properties = {width:256, height:256, x:0, y:0, scale:1.0};
    this.size = [50, 20];
  }
  function G() {
    this.addInput("clear", e.ACTION);
    this.addOutput("", "canvas");
    this.properties = {width:512, height:512, autoclear:!0};
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
  }
  function A() {
    this.addInput("canvas", "canvas");
    this.addInput("img", "image,canvas");
    this.addInput("x", "number");
    this.addInput("y", "number");
    this.properties = {x:0, y:0, opacity:1};
  }
  function D() {
    this.addInput("canvas", "canvas");
    this.addInput("x", "number");
    this.addInput("y", "number");
    this.addInput("w", "number");
    this.addInput("h", "number");
    this.properties = {x:0, y:0, w:10, h:10, color:"white", opacity:1};
  }
  function B() {
    this.addInput("t", "number");
    this.addOutputs([["frame", "image"], ["t", "number"], ["d", "number"]]);
    this.properties = {url:"", use_proxy:!0};
  }
  function F() {
    this.addOutput("Webcam", "image");
    this.properties = {filterFacingMode:!1, facingMode:"user"};
    this.boxcolor = "black";
    this.frame = 0;
  }
  var e = y.LiteGraph;
  c.title = "Plot";
  c.desc = "Plots data over time";
  c.colors = ["#FFF", "#F99", "#9F9", "#99F"];
  c.prototype.onExecute = function(c) {
    if (!this.flags.collapsed) {
      c = this.size;
      for (var e = 0; 4 > e; ++e) {
        var g = this.getInputData(e);
        if (null != g) {
          var l = this.values[e];
          l.push(g);
          l.length > c[0] && l.shift();
        }
      }
    }
  };
  c.prototype.onDrawBackground = function(e) {
    if (!this.flags.collapsed) {
      var g = this.size, l = 0.5 * g[1] / this.properties.scale, m = c.colors, k = 0.5 * g[1];
      e.fillStyle = "#000";
      e.fillRect(0, 0, g[0], g[1]);
      e.strokeStyle = "#555";
      e.beginPath();
      e.moveTo(0, k);
      e.lineTo(g[0], k);
      e.stroke();
      if (this.inputs) {
        for (var n = 0; 4 > n; ++n) {
          var z = this.values[n];
          if (this.inputs[n] && this.inputs[n].link) {
            e.strokeStyle = m[n];
            e.beginPath();
            var a = z[0] * l * -1 + k;
            e.moveTo(0, Math.clamp(a, 0, g[1]));
            for (var b = 1; b < z.length && b < g[0]; ++b) {
              a = z[b] * l * -1 + k, e.lineTo(b, Math.clamp(a, 0, g[1]));
            }
            e.stroke();
          }
        }
      }
    }
  };
  e.registerNodeType("graphics/plot", c);
  g.title = "Image";
  g.desc = "Image loader";
  g.widgets = [{name:"load", text:"Load", type:"button"}];
  g.supported_extensions = ["jpg", "jpeg", "png", "gif"];
  g.prototype.onAdded = function() {
    "" != this.properties.url && null == this.img && this.loadImage(this.properties.url);
  };
  g.prototype.onDrawBackground = function(c) {
    this.flags.collapsed || this.img && 5 < this.size[0] && 5 < this.size[1] && this.img.width && c.drawImage(this.img, 0, 0, this.size[0], this.size[1]);
  };
  g.prototype.onExecute = function() {
    this.img || (this.boxcolor = "#000");
    this.img && this.img.width ? this.setOutputData(0, this.img) : this.setOutputData(0, null);
    this.img && this.img.dirty && (this.img.dirty = !1);
  };
  g.prototype.onPropertyChanged = function(c, e) {
    this.properties[c] = e;
    "url" == c && "" != e && this.loadImage(e);
    return !0;
  };
  g.prototype.loadImage = function(c, g) {
    if ("" == c) {
      this.img = null;
    } else {
      this.img = document.createElement("img");
      "http" == c.substr(0, 4) && e.proxy && (c = e.proxy + c.substr(c.indexOf(":") + 3));
      this.img.src = c;
      this.boxcolor = "#F95";
      var l = this;
      this.img.onload = function() {
        g && g(this);
        console.log("Image loaded, size: " + l.img.width + "x" + l.img.height);
        this.dirty = !0;
        l.boxcolor = "#9F9";
        l.setDirtyCanvas(!0);
      };
      this.img.onerror = function() {
        console.log("error loading the image:" + c);
      };
    }
  };
  g.prototype.onWidget = function(c, e) {
    "load" == e.name && this.loadImage(this.properties.url);
  };
  g.prototype.onDropFile = function(c) {
    var e = this;
    this._url && URL.revokeObjectURL(this._url);
    this._url = URL.createObjectURL(c);
    this.properties.url = this._url;
    this.loadImage(this._url, function(c) {
      e.size[1] = c.height / c.width * e.size[0];
    });
  };
  e.registerNodeType("graphics/image", g);
  n.title = "Palette";
  n.desc = "Generates a color";
  n.prototype.onExecute = function() {
    var c = [];
    null != this.properties.colorA && c.push(hex2num(this.properties.colorA));
    null != this.properties.colorB && c.push(hex2num(this.properties.colorB));
    null != this.properties.colorC && c.push(hex2num(this.properties.colorC));
    null != this.properties.colorD && c.push(hex2num(this.properties.colorD));
    var e = this.getInputData(0);
    null == e && (e = 0.5);
    1.0 < e ? e = 1.0 : 0.0 > e && (e = 0.0);
    if (0 != c.length) {
      var g = [0, 0, 0];
      if (0 == e) {
        g = c[0];
      } else {
        if (1 == e) {
          g = c[c.length - 1];
        } else {
          var l = (c.length - 1) * e;
          e = c[Math.floor(l)];
          c = c[Math.floor(l) + 1];
          l -= Math.floor(l);
          g[0] = e[0] * (1 - l) + c[0] * l;
          g[1] = e[1] * (1 - l) + c[1] * l;
          g[2] = e[2] * (1 - l) + c[2] * l;
        }
      }
      for (e = 0; e < g.length; e++) {
        g[e] /= 255;
      }
      this.boxcolor = colorToString(g);
      this.setOutputData(0, g);
    }
  };
  e.registerNodeType("color/palette", n);
  m.title = "Frame";
  m.desc = "Frame viewerew";
  m.widgets = [{name:"resize", text:"Resize box", type:"button"}, {name:"view", text:"View Image", type:"button"}];
  m.prototype.onDrawBackground = function(c) {
    this.frame && !this.flags.collapsed && c.drawImage(this.frame, 0, 0, this.size[0], this.size[1]);
  };
  m.prototype.onExecute = function() {
    this.frame = this.getInputData(0);
    this.setDirtyCanvas(!0);
  };
  m.prototype.onWidget = function(c, e) {
    "resize" == e.name && this.frame ? (c = this.frame.width, e = this.frame.height, c || null == this.frame.videoWidth || (c = this.frame.videoWidth, e = this.frame.videoHeight), c && e && (this.size = [c, e]), this.setDirtyCanvas(!0, !0)) : "view" == e.name && this.show();
  };
  m.prototype.show = function() {
    showElement && this.frame && showElement(this.frame);
  };
  e.registerNodeType("graphics/frame", m);
  u.title = "Image fade";
  u.desc = "Fades between images";
  u.widgets = [{name:"resizeA", text:"Resize to A", type:"button"}, {name:"resizeB", text:"Resize to B", type:"button"}];
  u.prototype.onAdded = function() {
    this.createCanvas();
    var c = this.canvas.getContext("2d");
    c.fillStyle = "#000";
    c.fillRect(0, 0, this.properties.width, this.properties.height);
  };
  u.prototype.createCanvas = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.properties.width;
    this.canvas.height = this.properties.height;
  };
  u.prototype.onExecute = function() {
    var c = this.canvas.getContext("2d");
    this.canvas.width = this.canvas.width;
    var e = this.getInputData(0);
    null != e && c.drawImage(e, 0, 0, this.canvas.width, this.canvas.height);
    e = this.getInputData(2);
    null == e ? e = this.properties.fade : this.properties.fade = e;
    c.globalAlpha = e;
    e = this.getInputData(1);
    null != e && c.drawImage(e, 0, 0, this.canvas.width, this.canvas.height);
    c.globalAlpha = 1.0;
    this.setOutputData(0, this.canvas);
    this.setDirtyCanvas(!0);
  };
  e.registerNodeType("graphics/imagefade", u);
  l.title = "Crop";
  l.desc = "Crop Image";
  l.prototype.onAdded = function() {
    this.createCanvas();
  };
  l.prototype.createCanvas = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.properties.width;
    this.canvas.height = this.properties.height;
  };
  l.prototype.onExecute = function() {
    var c = this.getInputData(0);
    c && (c.width ? (this.canvas.getContext("2d").drawImage(c, -this.properties.x, -this.properties.y, c.width * this.properties.scale, c.height * this.properties.scale), this.setOutputData(0, this.canvas)) : this.setOutputData(0, null));
  };
  l.prototype.onDrawBackground = function(c) {
    this.flags.collapsed || this.canvas && c.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, this.size[0], this.size[1]);
  };
  l.prototype.onPropertyChanged = function(c, e) {
    this.properties[c] = e;
    "scale" == c ? (this.properties[c] = parseFloat(e), 0 == this.properties[c] && (console.error("Error in scale"), this.properties[c] = 1.0)) : this.properties[c] = parseInt(e);
    this.createCanvas();
    return !0;
  };
  e.registerNodeType("graphics/cropImage", l);
  G.title = "Canvas";
  G.desc = "Canvas to render stuff";
  G.prototype.onExecute = function() {
    var c = this.canvas, e = this.properties.width | 0, g = this.properties.height | 0;
    c.width != e && (c.width = e);
    c.height != g && (c.height = g);
    this.properties.autoclear && this.ctx.clearRect(0, 0, c.width, c.height);
    this.setOutputData(0, c);
  };
  G.prototype.onAction = function(c, e) {
    "clear" == c && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };
  e.registerNodeType("graphics/canvas", G);
  A.title = "DrawImage";
  A.desc = "Draws image into a canvas";
  A.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (c) {
      var e = this.getInputOrProperty("img");
      if (e) {
        var g = this.getInputOrProperty("x"), l = this.getInputOrProperty("y");
        c.getContext("2d").drawImage(e, g, l);
      }
    }
  };
  e.registerNodeType("graphics/drawImage", A);
  D.title = "DrawRectangle";
  D.desc = "Draws rectangle in canvas";
  D.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (c) {
      var e = this.getInputOrProperty("x"), g = this.getInputOrProperty("y"), l = this.getInputOrProperty("w"), k = this.getInputOrProperty("h");
      c.getContext("2d").fillRect(e, g, l, k);
    }
  };
  e.registerNodeType("graphics/drawRectangle", D);
  B.title = "Video";
  B.desc = "Video playback";
  B.widgets = [{name:"play", text:"PLAY", type:"minibutton"}, {name:"stop", text:"STOP", type:"minibutton"}, {name:"demo", text:"Demo video", type:"button"}, {name:"mute", text:"Mute video", type:"button"}];
  B.prototype.onExecute = function() {
    if (this.properties.url && (this.properties.url != this._video_url && this.loadVideo(this.properties.url), this._video && 0 != this._video.width)) {
      var c = this.getInputData(0);
      c && 0 <= c && 1.0 >= c && (this._video.currentTime = c * this._video.duration, this._video.pause());
      this._video.dirty = !0;
      this.setOutputData(0, this._video);
      this.setOutputData(1, this._video.currentTime);
      this.setOutputData(2, this._video.duration);
      this.setDirtyCanvas(!0);
    }
  };
  B.prototype.onStart = function() {
    this.play();
  };
  B.prototype.onStop = function() {
    this.stop();
  };
  B.prototype.loadVideo = function(c) {
    this._video_url = c;
    var g = c.substr(0, 10).indexOf(":"), l = "";
    -1 != g && (l = c.substr(0, g));
    g = "";
    l && (g = c.substr(0, c.indexOf("/", l.length + 3)), g = g.substr(l.length + 3));
    this.properties.use_proxy && l && e.proxy && g != location.host && (c = e.proxy + c.substr(c.indexOf(":") + 3));
    this._video = document.createElement("video");
    this._video.src = c;
    this._video.type = "type=video/mp4";
    this._video.muted = !0;
    this._video.autoplay = !0;
    var m = this;
    this._video.addEventListener("loadedmetadata", function(c) {
      console.log("Duration: " + this.duration + " seconds");
      console.log("Size: " + this.videoWidth + "," + this.videoHeight);
      m.setDirtyCanvas(!0);
      this.width = this.videoWidth;
      this.height = this.videoHeight;
    });
    this._video.addEventListener("progress", function(c) {
      console.log("video loading...");
    });
    this._video.addEventListener("error", function(c) {
      console.error("Error loading video: " + this.src);
      if (this.error) {
        switch(this.error.code) {
          case this.error.MEDIA_ERR_ABORTED:
            console.error("You stopped the video.");
            break;
          case this.error.MEDIA_ERR_NETWORK:
            console.error("Network error - please try again later.");
            break;
          case this.error.MEDIA_ERR_DECODE:
            console.error("Video is broken..");
            break;
          case this.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            console.error("Sorry, your browser can't play this video.");
        }
      }
    });
    this._video.addEventListener("ended", function(c) {
      console.log("Video Ended.");
      this.play();
    });
  };
  B.prototype.onPropertyChanged = function(c, e) {
    this.properties[c] = e;
    "url" == c && "" != e && this.loadVideo(e);
    return !0;
  };
  B.prototype.play = function() {
    this._video && this._video.videoWidth && this._video.play();
  };
  B.prototype.playPause = function() {
    this._video && (this._video.paused ? this.play() : this.pause());
  };
  B.prototype.stop = function() {
    this._video && (this._video.pause(), this._video.currentTime = 0);
  };
  B.prototype.pause = function() {
    this._video && (console.log("Video paused"), this._video.pause());
  };
  B.prototype.onWidget = function(c, e) {
  };
  e.registerNodeType("graphics/video", B);
  F.title = "Webcam";
  F.desc = "Webcam image";
  F.is_webcam_open = !1;
  F.prototype.openStream = function() {
    if (navigator.mediaDevices.getUserMedia) {
      this._waiting_confirmation = !0;
      navigator.mediaDevices.getUserMedia({audio:!1, video:this.properties.filterFacingMode ? {facingMode:this.properties.facingMode} : !0}).then(this.streamReady.bind(this)).catch(function(e) {
        console.log("Webcam rejected", e);
        c._webcam_stream = !1;
        F.is_webcam_open = !1;
        c.boxcolor = "red";
        c.trigger("stream_error");
      });
      var c = this;
    } else {
      console.log("getUserMedia() is not supported in your browser, use chrome and enable WebRTC from about://flags");
    }
  };
  F.prototype.closeStream = function() {
    if (this._webcam_stream) {
      var c = this._webcam_stream.getTracks();
      if (c.length) {
        for (var e = 0; e < c.length; ++e) {
          c[e].stop();
        }
      }
      F.is_webcam_open = !1;
      this._video = this._webcam_stream = null;
      this.boxcolor = "black";
      this.trigger("stream_closed");
    }
  };
  F.prototype.onPropertyChanged = function(c, e) {
    "facingMode" == c && (this.properties.facingMode = e, this.closeStream(), this.openStream());
  };
  F.prototype.onRemoved = function() {
    this.closeStream();
  };
  F.prototype.streamReady = function(c) {
    this._webcam_stream = c;
    this.boxcolor = "green";
    var e = this._video;
    e || (e = document.createElement("video"), e.autoplay = !0, e.srcObject = c, this._video = e, e.onloadedmetadata = function(c) {
      console.log(c);
      F.is_webcam_open = !0;
    });
    this.trigger("stream_ready", e);
  };
  F.prototype.onExecute = function() {
    null != this._webcam_stream || this._waiting_confirmation || this.openStream();
    if (this._video && this._video.videoWidth) {
      this._video.frame = ++this.frame;
      this._video.width = this._video.videoWidth;
      this._video.height = this._video.videoHeight;
      this.setOutputData(0, this._video);
      for (var c = 1; c < this.outputs.length; ++c) {
        if (this.outputs[c]) {
          switch(this.outputs[c].name) {
            case "width":
              this.setOutputData(c, this._video.videoWidth);
              break;
            case "height":
              this.setOutputData(c, this._video.videoHeight);
          }
        }
      }
    }
  };
  F.prototype.getExtraMenuOptions = function(c) {
    var e = this;
    return [{content:e.properties.show ? "Hide Frame" : "Show Frame", callback:function() {
      e.properties.show = !e.properties.show;
    }}];
  };
  F.prototype.onDrawBackground = function(c) {
    this.flags.collapsed || 20 >= this.size[1] || !this.properties.show || !this._video || (c.save(), c.drawImage(this._video, 0, 0, this.size[0], this.size[1]), c.restore());
  };
  F.prototype.onGetOutputs = function() {
    return [["width", "number"], ["height", "number"], ["stream_ready", e.EVENT], ["stream_closed", e.EVENT], ["stream_error", e.EVENT]];
  };
  e.registerNodeType("graphics/webcam", F);
})(this);
(function(y) {
  function c() {
    return 100000 * Math.random() | 0;
  }
  function g() {
    this.addInput("obj", "");
    this.addInput("radius", "number");
    this.addOutput("out", "geometry");
    this.addOutput("points", "[vec3]");
    this.properties = {radius:1, num_points:4096, generate_normals:!0, regular:!1, mode:g.SPHERE, force_update:!1};
    this.points = new Float32Array(3 * this.properties.num_points);
    this.normals = new Float32Array(3 * this.properties.num_points);
    this.must_update = !0;
    this.version = 0;
    var a = this;
    this.addWidget("button", "update", null, function() {
      a.must_update = !0;
    });
    this.geometry = {vertices:null, _id:c()};
    this._last_radius = this._old_obj = null;
  }
  function n(a, c) {
    var b = a.length, d = 0, e = 0, g = b;
    if (0 == b) {
      return -1;
    }
    if (1 == b) {
      return 0;
    }
    for (; g >= d;) {
      e = 0.5 * (g + d) | 0;
      b = a[e];
      if (b == c) {
        break;
      }
      if (d == g - 1) {
        return d;
      }
      b < c ? d = e : g = e;
    }
    return e;
  }
  function m() {
    this.addInput("points", "geometry");
    this.addOutput("instances", "[mat4]");
    this.properties = {mode:1, autoupdate:!0};
    this.must_update = !0;
    this.matrices = [];
    this.first_time = !0;
  }
  function u() {
    this.addInput("in", "geometry,[mat4]");
    this.addInput("mat4", "mat4");
    this.addOutput("out", "geometry");
    this.properties = {};
    this.geometry = {type:"triangles", vertices:null, _id:c(), _version:0};
    this._last_version = this._last_geometry_id = -1;
    this._last_key = "";
    this.must_update = !0;
  }
  function l() {
    this.addInput("sides", "number");
    this.addInput("radius", "number");
    this.addOutput("out", "geometry");
    this.properties = {sides:6, radius:1, uvs:!1};
    this.geometry = {type:"line_loop", vertices:null, _id:c()};
    this.version = this.geometry_id = -1;
    this.must_update = !0;
    this.last_info = {sides:-1, radius:-1};
  }
  function G() {
    this.addInput("", "geometry");
    this.addOutput("", "geometry");
    this.properties = {top_cap:!0, bottom_cap:!0, offset:[0, 100, 0]};
    this._last_geo_version = this.version = -1;
    this._must_update = !0;
  }
  function A() {
    this.addInput("in", "geometry");
    this.addOutput("out", "geometry");
    this.properties = {code:"V[1] += 0.01 * Math.sin(I + T*0.001);", execute_every_frame:!1};
    this.geometry = null;
    this.version = this.geometry_id = -1;
    this.must_update = !0;
    this.func = this.vertices = null;
  }
  function D() {
    this.addInput("in", "geometry");
    this.addOutput("out", "geometry");
    this.properties = {min_dist:0.4, max_dist:0.5, max_connections:0, probability:1};
    this.version = this.geometry_id = -1;
    this.my_version = 1;
    this.must_update = !0;
  }
  function B() {
    this.addInput("mesh", "mesh");
    this.addOutput("out", "geometry");
    this.geometry = {};
    this.last_mesh = null;
  }
  function F() {
    this.addInput("in", "geometry");
    this.addOutput("mesh", "mesh");
    this.properties = {};
    this.version = -1;
    this.mesh = null;
  }
  function e() {
    this.addInput("mesh", "mesh");
    this.addInput("mat4", "mat4");
    this.addInput("tex", "texture");
    this.properties = {enabled:!0, primitive:GL.TRIANGLES, additive:!1, color:[1, 1, 1], opacity:1};
    this.color = vec4.create([1, 1, 1, 1]);
    this.model_matrix = mat4.create();
    this.uniforms = {u_color:this.color, u_model:this.model_matrix};
  }
  function z() {
    this.addInput("size", "number");
    this.addOutput("out", "mesh");
    this.properties = {type:1, size:1, subdivisions:32};
    this.version = 100000 * Math.random() | 0;
    this.last_info = {type:-1, size:-1, subdivisions:-1};
  }
  function H() {
    this.addInput("in", "geometry");
    this.addInput("mat4", "mat4");
    this.addInput("tex", "texture");
    this.properties = {enabled:!0, point_size:0.1, fixed_size:!1, additive:!0, color:[1, 1, 1], opacity:1};
    this.color = vec4.create([1, 1, 1, 1]);
    this.uniforms = {u_point_size:1, u_perspective:1, u_point_perspective:1, u_color:this.color};
    this.version = this.geometry_id = -1;
    this.mesh = null;
  }
  var x = y.LiteGraph, K = new Float32Array(16), k = new Float32Array(16), q = new Float32Array(16), t = new Float32Array(16), a = {u_view:K, u_projection:k, u_viewprojection:q, u_model:t};
  x.LGraphRender = {onRequestCameraMatrices:null};
  y.LGraphPoints3D = g;
  g.RECTANGLE = 1;
  g.CIRCLE = 2;
  g.CUBE = 10;
  g.SPHERE = 11;
  g.HEMISPHERE = 12;
  g.INSIDE_SPHERE = 13;
  g.OBJECT = 20;
  g.OBJECT_UNIFORMLY = 21;
  g.OBJECT_INSIDE = 22;
  g.MODE_VALUES = {rectangle:g.RECTANGLE, circle:g.CIRCLE, cube:g.CUBE, sphere:g.SPHERE, hemisphere:g.HEMISPHERE, inside_sphere:g.INSIDE_SPHERE, object:g.OBJECT, object_uniformly:g.OBJECT_UNIFORMLY, object_inside:g.OBJECT_INSIDE};
  g.widgets_info = {mode:{widget:"combo", values:g.MODE_VALUES}};
  g.title = "list of points";
  g.desc = "returns an array of points";
  g.prototype.onPropertyChanged = function(a, c) {
    this.must_update = !0;
  };
  g.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a != this._old_obj || a && a._version != this._old_obj_version) {
      this._old_obj = a, this.must_update = !0;
    }
    a = this.getInputData(1);
    null == a && (a = this.properties.radius);
    this._last_radius != a && (this._last_radius = a, this.must_update = !0);
    if (this.must_update || this.properties.force_update) {
      this.must_update = !1, this.updatePoints();
    }
    this.geometry.vertices = this.points;
    this.geometry.normals = this.normals;
    this.geometry._version = this.version;
    this.setOutputData(0, this.geometry);
  };
  g.prototype.updatePoints = function() {
    var a = this.properties.num_points | 0;
    1 > a && (a = 1);
    this.points && this.points.length == 3 * a || (this.points = new Float32Array(3 * a));
    this.properties.generate_normals ? this.normals && this.normals.length == this.points.length || (this.normals = new Float32Array(this.points.length)) : this.normals = null;
    var c = this._last_radius || this.properties.radius, f = this.properties.mode, e = this.getInputData(0);
    this._old_obj_version = e ? e._version : null;
    this.points = g.generatePoints(c, a, f, this.points, this.normals, this.properties.regular, e);
    this.version++;
  };
  g.generatePoints = function(a, c, f, e, k, l, m) {
    var b = 3 * c;
    e && e.length == b || (e = new Float32Array(b));
    var d = new Float32Array(3), h = new Float32Array([0, 1, 0]);
    if (l) {
      if (f == g.RECTANGLE) {
        b = Math.floor(Math.sqrt(c));
        for (c = 0; c < b; ++c) {
          for (f = 0; f < b; ++f) {
            l = 3 * c + 3 * f * b, e[l] = (c / b - 0.5) * a * 2, e[l + 1] = 0, e[l + 2] = (f / b - 0.5) * a * 2;
          }
        }
        e = new Float32Array(e.subarray(0, b * b * 3));
        if (k) {
          for (c = 0; c < k.length; c += 3) {
            k.set(h, c);
          }
        }
      } else {
        if (f == g.SPHERE) {
          b = Math.floor(Math.sqrt(c));
          for (c = 0; c < b; ++c) {
            for (f = 0; f < b; ++f) {
              l = 3 * c + 3 * f * b, polarToCartesian(d, c / b * 2 * Math.PI, 2 * (f / b - 0.5) * Math.PI, a), e[l] = d[0], e[l + 1] = d[1], e[l + 2] = d[2];
            }
          }
          e = new Float32Array(e.subarray(0, b * b * 3));
          k && g.generateSphericalNormals(e, k);
        } else {
          if (f == g.CIRCLE) {
            for (c = 0; c < b; c += 3) {
              d = c / b * Math.PI * 2, e[c] = Math.cos(d) * a, e[c + 1] = 0, e[c + 2] = Math.sin(d) * a;
            }
            if (k) {
              for (c = 0; c < k.length; c += 3) {
                k.set(h, c);
              }
            }
          }
        }
      }
    } else {
      if (f == g.RECTANGLE) {
        for (c = 0; c < b; c += 3) {
          e[c] = (Math.random() - 0.5) * a * 2, e[c + 1] = 0, e[c + 2] = (Math.random() - 0.5) * a * 2;
        }
        if (k) {
          for (c = 0; c < k.length; c += 3) {
            k.set(h, c);
          }
        }
      } else {
        if (f == g.CUBE) {
          for (c = 0; c < b; c += 3) {
            e[c] = (Math.random() - 0.5) * a * 2, e[c + 1] = (Math.random() - 0.5) * a * 2, e[c + 2] = (Math.random() - 0.5) * a * 2;
          }
          if (k) {
            for (c = 0; c < k.length; c += 3) {
              k.set(h, c);
            }
          }
        } else {
          f == g.SPHERE ? (g.generateSphere(e, b, a), k && g.generateSphericalNormals(e, k)) : f == g.HEMISPHERE ? (g.generateHemisphere(e, b, a), k && g.generateSphericalNormals(e, k)) : f == g.CIRCLE ? (g.generateInsideCircle(e, b, a), k && g.generateSphericalNormals(e, k)) : f == g.INSIDE_SPHERE ? (g.generateInsideSphere(e, b, a), k && g.generateSphericalNormals(e, k)) : f == g.OBJECT ? g.generateFromObject(e, k, b, m, !1) : f == g.OBJECT_UNIFORMLY ? g.generateFromObject(e, k, b, m, !0) : f == 
          g.OBJECT_INSIDE ? g.generateFromInsideObject(e, b, m) : console.warn("wrong mode in LGraphPoints3D");
        }
      }
    }
    return e;
  };
  g.generateSphericalNormals = function(a, c) {
    for (var b = new Float32Array(3), d = 0; d < c.length; d += 3) {
      b[0] = a[d], b[1] = a[d + 1], b[2] = a[d + 2], vec3.normalize(b, b), c.set(b, d);
    }
  };
  g.generateSphere = function(a, c, f) {
    for (var b = 0; b < c; b += 3) {
      var d = Math.random(), e = Math.random(), g = 1 - 2 * e, k = 2 * Math.sin(2 * Math.PI * d) * Math.sqrt(e * (1 - e));
      a[b] = 2 * Math.cos(2 * Math.PI * d) * Math.sqrt(e * (1 - e)) * f;
      a[b + 1] = g * f;
      a[b + 2] = k * f;
    }
  };
  g.generateHemisphere = function(a, c, f) {
    for (var b = 0; b < c; b += 3) {
      var d = Math.random(), e = Math.random(), g = e, k = Math.sin(2 * Math.PI * d) * Math.sqrt(1 - e * e);
      a[b] = Math.cos(2 * Math.PI * d) * Math.sqrt(1 - e * e) * f;
      a[b + 1] = g * f;
      a[b + 2] = k * f;
    }
  };
  g.generateInsideCircle = function(a, c, f) {
    for (var b = 0; b < c; b += 3) {
      var d = Math.random(), e = Math.random(), g = Math.sin(2 * Math.PI * d) * Math.sqrt(1 - e * e);
      a[b] = Math.cos(2 * Math.PI * d) * Math.sqrt(1 - e * e) * f;
      a[b + 1] = 0;
      a[b + 2] = g * f;
    }
  };
  g.generateInsideSphere = function(a, c, f) {
    for (var b = 0; b < c; b += 3) {
      var d = 2.0 * Math.random() * Math.PI, e = Math.acos(2.0 * Math.random() - 1.0), g = Math.cbrt(Math.random()) * f, k = Math.sin(d), l = Math.sin(e);
      e = Math.cos(e);
      a[b] = g * l * Math.cos(d);
      a[b + 1] = g * l * k;
      a[b + 2] = g * e;
    }
  };
  g.generateFromObject = function(a, c, f, e, g) {
    if (e) {
      var b = null, d = null, h = null, k = null;
      e.constructor === GL.Mesh && (b = e.vertexBuffers.vertices.data, d = e.vertexBuffers.normals ? e.vertexBuffers.normals.data : null, (h = e.indexBuffers.indices ? e.indexBuffers.indices.data : null) || (h = e.indexBuffers.triangles ? e.indexBuffers.triangles.data : null));
      if (!b) {
        return null;
      }
      e = h ? h.length / 3 : b.length / 9;
      var l = 0;
      if (g) {
        k = new Float32Array(e);
        for (var m = 0; m < e; ++m) {
          if (h) {
            var q = 3 * h[3 * m];
            var w = 3 * h[3 * m + 1];
            var u = 3 * h[3 * m + 2];
          } else {
            q = 9 * m, w = 9 * m + 3, u = 9 * m + 6;
          }
          q = b.subarray(q, q + 3);
          var t = b.subarray(w, w + 3), x = b.subarray(u, u + 3);
          w = vec3.distance(q, t);
          u = vec3.distance(t, x);
          q = vec3.distance(x, q);
          t = (w + u + q) / 2;
          l += Math.sqrt(t * (t - w) * (t - u) * (t - q));
          k[m] = l;
        }
        for (m = 0; m < e; ++m) {
          k[m] /= l;
        }
      }
      for (m = 0; m < f; m += 3) {
        w = Math.random();
        u = g ? n(k, w) : Math.floor(w * e);
        h ? (q = 3 * h[3 * u], w = 3 * h[3 * u + 1], u = 3 * h[3 * u + 2]) : (q = 9 * u, w = 9 * u + 3, u = 9 * u + 6);
        t = Math.random();
        l = Math.random();
        var y = Math.sqrt(t);
        t = 1 - y;
        x = y * (1 - l);
        l *= y;
        a[m] = t * b[q] + x * b[w] + l * b[u];
        a[m + 1] = t * b[q + 1] + x * b[w + 1] + l * b[u + 1];
        a[m + 2] = t * b[q + 2] + x * b[w + 2] + l * b[u + 2];
        c && d && (c[m] = t * d[q] + x * d[w] + l * d[u], c[m + 1] = t * d[q + 1] + x * d[w + 1] + l * d[u + 1], c[m + 2] = t * d[q + 2] + x * d[w + 2] + l * d[u + 2], w = c.subarray(m, m + 3), vec3.normalize(w, w));
      }
    }
  };
  g.generateFromInsideObject = function(a, c, f) {
    if (f && f.constructor === GL.Mesh) {
      var b = f.getBoundingBox();
      f.octree || (f.octree = new GL.Octree(f));
      f = f.octree;
      for (var d = vec3.create(), e = vec3.fromValues(1, 0, 0), g = vec3.create(), k = 0, l = 0; k < c && l < 10 * a.length;) {
        l += 1;
        var m = vec3.random(g);
        m[0] = (2 * m[0] - 1) * b[3] + b[0];
        m[1] = (2 * m[1] - 1) * b[4] + b[1];
        m[2] = (2 * m[2] - 1) * b[5] + b[2];
        d.set(m);
        var q = f.testRay(d, e, 0, 10000, !0, GL.Octree.ALL);
        q && 0 != q.length % 2 && (a.set(m, k), k += 3);
      }
    }
  };
  x.registerNodeType("geometry/points3D", g);
  m.NORMAL = 0;
  m.VERTICAL = 1;
  m.SPHERICAL = 2;
  m.RANDOM = 3;
  m.RANDOM_VERTICAL = 4;
  m.modes = {normal:0, vertical:1, spherical:2, random:3, random_vertical:4};
  m.widgets_info = {mode:{widget:"combo", values:m.modes}};
  m.title = "points to inst";
  m.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (!a) {
      this.setOutputData(0, null);
    } else {
      if (this.isOutputConnected(0)) {
        if ((a._version != this._version || a._id != this._geometry_id) && this.properties.autoupdate || this.first_time) {
          this.first_time = !1, this.updateInstances(a);
        }
        this.setOutputData(0, this.matrices);
      }
    }
  };
  m.prototype.updateInstances = function(a) {
    var b = a.vertices;
    if (!b) {
      return null;
    }
    var c = a.normals, e = this.matrices, g = b.length / 3;
    e.length != g && (e.length = g);
    g = mat4.create();
    var k = vec3.create();
    vec3.create();
    var l = vec3.fromValues(0, 1, 0), q = vec3.fromValues(0, 0, -1);
    vec3.fromValues(1, 0, 0);
    for (var n = quat.create(), u = vec3.create(), t = vec3.create(), x = vec3.create(), y = 0; y < b.length; y += 3) {
      var A = y / 3, z = e[A];
      z || (z = e[A] = mat4.create());
      z.set(g);
      A = b.subarray(y, y + 3);
      switch(this.properties.mode) {
        case m.NORMAL:
          mat4.setTranslation(z, A);
          if (c) {
            var B = c.subarray(y, y + 3);
            x.set(B);
            vec3.normalize(x, x);
            vec3.cross(t, q, x);
            vec3.normalize(t, t);
            vec3.cross(u, t, x);
            vec3.normalize(u, u);
            z.set(t, 0);
            z.set(x, 4);
            z.set(u, 8);
            mat4.setTranslation(z, A);
          }
          break;
        case m.VERTICAL:
          mat4.setTranslation(z, A);
          break;
        case m.SPHERICAL:
          u.set(A);
          vec3.normalize(u, u);
          vec3.cross(t, l, u);
          vec3.normalize(t, t);
          vec3.cross(x, u, t);
          vec3.normalize(x, x);
          z.set(t, 0);
          z.set(x, 4);
          z.set(u, 8);
          mat4.setTranslation(z, A);
          break;
        case m.RANDOM:
          k[0] = 2 * Math.random() - 1;
          k[1] = 2 * Math.random() - 1;
          k[2] = 2 * Math.random() - 1;
          vec3.normalize(k, k);
          quat.setAxisAngle(n, k, 2 * Math.random() * Math.PI);
          mat4.fromQuat(z, n);
          mat4.setTranslation(z, A);
          break;
        case m.RANDOM_VERTICAL:
          quat.setAxisAngle(n, l, 2 * Math.random() * Math.PI), mat4.fromQuat(z, n), mat4.setTranslation(z, A);
      }
    }
    this._version = a._version;
    this._geometry_id = a._id;
  };
  x.registerNodeType("geometry/points_to_instances", m);
  u.title = "Transform";
  u.prototype.onExecute = function() {
    var a = this.getInputData(0), c = this.getInputData(1);
    if (a) {
      if (a.constructor === Array) {
        if (0 != a.length && (this.outputs[0].type = "[mat4]", this.isOutputConnected(0))) {
          if (c) {
            this._output || (this._output = []);
            this._output.length != a.length && (this._output.length = a.length);
            for (var f = 0; f < a.length; ++f) {
              var e = this._output[f];
              e || (e = this._output[f] = mat4.create());
              mat4.multiply(e, a[f], c);
            }
            this.setOutputData(0, this._output);
          } else {
            this.setOutputData(0, a);
          }
        }
      } else {
        if (a.vertices && a.vertices.length && (this.outputs[0].type = "geometry", this.isOutputConnected(0))) {
          if (c) {
            f = typedArrayToArray(c).join(",");
            if (this.must_update || a._id != this._last_geometry_id || a._version != this._last_version || f != this._last_key) {
              this.updateGeometry(a, c), this._last_key = f, this._last_version = a._version, this._last_geometry_id = a._id, this.must_update = !1;
            }
            this.setOutputData(0, this.geometry);
          } else {
            this.setOutputData(0, a);
          }
        }
      }
    }
  };
  u.prototype.updateGeometry = function(a, c) {
    var b = a.vertices, d = this.geometry.vertices;
    d && d.length == b.length || (d = this.geometry.vertices = new Float32Array(b.length));
    for (var e = vec3.create(), g = 0, k = d.length; g < k; g += 3) {
      e[0] = b[g], e[1] = b[g + 1], e[2] = b[g + 2], mat4.multiplyVec3(e, c, e), d[g] = e[0], d[g + 1] = e[1], d[g + 2] = e[2];
    }
    if (a.normals) {
      for (this.geometry.normals && this.geometry.normals.length == a.normals.length || (this.geometry.normals = new Float32Array(a.normals.length)), b = this.geometry.normals, (c = mat4.invert(mat4.create(), c)) && mat4.transpose(c, c), d = a.normals, g = 0, k = b.length; g < k; g += 3) {
        e[0] = d[g], e[1] = d[g + 1], e[2] = d[g + 2], mat4.multiplyVec3(e, c, e), b[g] = e[0], b[g + 1] = e[1], b[g + 2] = e[2];
      }
    }
    this.geometry.type = a.type;
    this.geometry._version++;
  };
  x.registerNodeType("geometry/transform", u);
  l.title = "Polygon";
  l.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputOrProperty("sides"), c = this.getInputOrProperty("radius");
      a = Math.max(3, a) | 0;
      this.last_info.sides == a && this.last_info.radius == c || this.updateGeometry(a, c);
      this.setOutputData(0, this.geometry);
    }
  };
  l.prototype.updateGeometry = function(a, c) {
    var b = this.geometry.vertices;
    b && b.length == 3 * a || (b = this.geometry.vertices = new Float32Array(3 * a));
    var d = 2 * Math.PI / a;
    this.properties.uvs && (uvs = this.geometry.coords = new Float32Array(3 * a));
    for (var e = 0; e < a; ++e) {
      var g = d * -e, k = Math.sin(g) * c;
      b[3 * e] = Math.cos(g) * c;
      b[3 * e + 1] = 0;
      b[3 * e + 2] = k;
    }
    this.geometry._id = ++this.geometry_id;
    this.geometry._version = ++this.version;
    this.last_info.sides = a;
    this.last_info.radius = c;
  };
  x.registerNodeType("geometry/polygon", l);
  G.title = "extrude";
  G.prototype.onPropertyChanged = function(a, c) {
    this._must_update = !0;
  };
  G.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a && this.isOutputConnected(0)) {
      if (a.version != this._last_geo_version || this._must_update) {
        if (this._geo = this.extrudeGeometry(a, this._geo)) {
          this._geo.version = this.version++;
        }
        this._must_update = !1;
      }
      this.setOutputData(0, this._geo);
    }
  };
  G.prototype.extrudeGeometry = function(a) {
    var b = a.vertices, e = b.length / 3, g = vec3.create(), k = vec3.create(), l = vec3.create(), m = vec3.create(), q = new Float32Array(this.properties.offset);
    if ("line_loop" == a.type) {
      var n = new Float32Array(18 * e);
      e = a = 0;
      for (var u = b.length; e < u; e += 3) {
        g[0] = b[e], g[1] = b[e + 1], g[2] = b[e + 2], e + 3 < u ? (k[0] = b[e + 3], k[1] = b[e + 4], k[2] = b[e + 5]) : (k[0] = b[0], k[1] = b[1], k[2] = b[2]), vec3.add(l, g, q), vec3.add(m, k, q), n.set(g, a), a += 3, n.set(k, a), a += 3, n.set(l, a), a += 3, n.set(k, a), a += 3, n.set(m, a), a += 3, n.set(l, a), a += 3;
      }
    }
    return {_id:c(), type:"triangles", vertices:n};
  };
  x.registerNodeType("geometry/extrude", G);
  A.title = "geoeval";
  A.desc = "eval code";
  A.widgets_info = {code:{widget:"code"}};
  A.prototype.onConfigure = function(a) {
    this.compileCode();
  };
  A.prototype.compileCode = function() {
    if (this.properties.code) {
      try {
        this.func = new Function("V", "I", "T", this.properties.code), this.boxcolor = "#AFA", this.must_update = !0;
      } catch (b) {
        this.boxcolor = "red";
      }
    }
  };
  A.prototype.onPropertyChanged = function(a, c) {
    "code" == a && (this.properties.code = c, this.compileCode());
  };
  A.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      if (this.func) {
        if (this.geometry_id != a._id || this.version != a._version || this.must_update || this.properties.execute_every_frame) {
          this.must_update = !1;
          this.geometry_id = a._id;
          this.properties.execute_every_frame ? this.version++ : this.version = a._version;
          var c = this.func, e = getTime();
          this.geometry || (this.geometry = {});
          for (var g in a) {
            null != a[g] && (this.geometry[g] = a[g].constructor == Float32Array ? new Float32Array(a[g]) : a[g]);
          }
          this.geometry._id = a._id;
          this.geometry._version = this.properties.execute_every_frame ? this.version : a._version + 1;
          var k = vec3.create(), l = this.vertices;
          l && this.vertices.length == a.vertices.length ? l.set(a.vertices) : l = this.vertices = new Float32Array(a.vertices);
          for (g = 0; g < l.length; g += 3) {
            k[0] = l[g], k[1] = l[g + 1], k[2] = l[g + 2], c(k, g / 3, e), l[g] = k[0], l[g + 1] = k[1], l[g + 2] = k[2];
          }
          this.geometry.vertices = l;
        }
        this.setOutputData(0, this.geometry);
      } else {
        this.setOutputData(0, a);
      }
    }
  };
  x.registerNodeType("geometry/eval", A);
  D.title = "connect points";
  D.desc = "adds indices between near points";
  D.prototype.onPropertyChanged = function(a, c) {
    this.must_update = !0;
  };
  D.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      if (this.geometry_id != a._id || this.version != a._version || this.must_update) {
        this.must_update = !1;
        this.geometry_id = a._id;
        this.version = a._version;
        this.geometry = {};
        for (var d in a) {
          this.geometry[d] = a[d];
        }
        this.geometry._id = c();
        this.geometry._version = this.my_version++;
        a = a.vertices;
        var e = a.length, g = this.properties.min_dist, k = this.properties.max_dist, l = this.properties.probability, m = this.properties.max_connections, n = [];
        for (d = 0; d < e; d += 3) {
          for (var q = a[d], u = a[d + 1], t = a[d + 2], x = 0, y = d + 3; y < e; y += 3) {
            var z = a[y], A = a[y + 1], B = a[y + 2];
            z = Math.sqrt((q - z) * (q - z) + (u - A) * (u - A) + (t - B) * (t - B));
            if (!(z > k || z < g || 1 > l && l < Math.random()) && (n.push(d / 3, y / 3), x += 1, m && x > m)) {
              break;
            }
          }
        }
        this.geometry.indices = this.indices = new Uint32Array(n);
      }
      this.indices && this.indices.length ? (this.geometry.indices = this.indices, this.setOutputData(0, this.geometry)) : this.setOutputData(0, null);
    }
  };
  x.registerNodeType("geometry/connectPoints", D);
  "undefined" != typeof GL && (B.title = "to geometry", B.desc = "converts a mesh to geometry", B.prototype.onExecute = function() {
    var a = this.getInputData(0);
    if (a) {
      if (a != this.last_mesh) {
        this.last_mesh = a;
        for (i in a.vertexBuffers) {
          this.geometry[i] = a.vertexBuffers[i].data;
        }
        a.indexBuffers.triangles && (this.geometry.indices = a.indexBuffers.triangles.data);
        this.geometry._id = c();
        this.geometry._version = 0;
      }
      this.setOutputData(0, this.geometry);
      this.geometry && this.setOutputData(1, this.geometry.vertices);
    }
  }, x.registerNodeType("geometry/toGeometry", B), F.title = "Geo to Mesh", F.prototype.updateMesh = function(a) {
    this.mesh || (this.mesh = new GL.Mesh);
    for (var b in a) {
      if ("_" != b[0]) {
        var c = a[b], e = GL.Mesh.common_buffers[b];
        if (e || "indices" == b) {
          e = e ? e.spacing : 3;
          var g = this.mesh.vertexBuffers[b];
          g && g.data.length == c.length ? (g.data.set(c), g.upload(GL.DYNAMIC_DRAW)) : g = new GL.Buffer("indices" == b ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER, c, e, GL.DYNAMIC_DRAW);
          this.mesh.addBuffer(b, g);
        }
      }
    }
    if (this.mesh.vertexBuffers.normals && this.mesh.vertexBuffers.normals.data.length != this.mesh.vertexBuffers.vertices.data.length) {
      c = new Float32Array([0, 1, 0]);
      e = new Float32Array(this.mesh.vertexBuffers.vertices.data.length);
      for (b = 0; b < e.length; b += 3) {
        e.set(c, b);
      }
      g = new GL.Buffer(GL.ARRAY_BUFFER, e, 3);
      this.mesh.addBuffer("normals", g);
    }
    this.mesh.updateBoundingBox();
    this.geometry_id = this.mesh.id = a._id;
    this.version = this.mesh.version = a._version;
    return this.mesh;
  }, F.prototype.onExecute = function() {
    var a = this.getInputData(0);
    a && (this.version == a._version && this.geometry_id == a._id || this.updateMesh(a), this.setOutputData(0, this.mesh));
  }, x.registerNodeType("geometry/toMesh", F), e.title = "Render Mesh", e.desc = "renders a mesh flat", e.PRIMITIVE_VALUES = {points:GL.POINTS, lines:GL.LINES, line_loop:GL.LINE_LOOP, line_strip:GL.LINE_STRIP, triangles:GL.TRIANGLES, triangle_fan:GL.TRIANGLE_FAN, triangle_strip:GL.TRIANGLE_STRIP}, e.widgets_info = {primitive:{widget:"combo", values:e.PRIMITIVE_VALUES}, color:{widget:"color"}}, e.prototype.onExecute = function() {
    if (this.properties.enabled) {
      var b = this.getInputData(0);
      if (b) {
        if (x.LGraphRender.onRequestCameraMatrices) {
          x.LGraphRender.onRequestCameraMatrices(K, k, q);
          var c;
          this.getInputData(2) ? (c = gl.shaders.textured) || (c = gl.shaders.textured = new GL.Shader(H.vertex_shader_code, H.fragment_shader_code, {USE_TEXTURE:""})) : (c = gl.shaders.flat) || (c = gl.shaders.flat = new GL.Shader(H.vertex_shader_code, H.fragment_shader_code));
          this.color.set(this.properties.color);
          this.color[3] = this.properties.opacity;
          var e = this.model_matrix, g = this.getInputData(1);
          g ? e.set(g) : mat4.identity(e);
          this.uniforms.u_point_size = 1;
          e = this.properties.primitive;
          c.uniforms(a);
          c.uniforms(this.uniforms);
          1 <= this.properties.opacity ? gl.disable(gl.BLEND) : gl.enable(gl.BLEND);
          gl.enable(gl.DEPTH_TEST);
          this.properties.additive ? (gl.blendFunc(gl.SRC_ALPHA, gl.ONE), gl.depthMask(!1)) : gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          g = "indices";
          b.indexBuffers.triangles && (g = "triangles");
          c.draw(b, e, g);
          gl.disable(gl.BLEND);
          gl.depthMask(!0);
        } else {
          console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
        }
      }
    }
  }, x.registerNodeType("geometry/render_mesh", e), z.title = "Primitive", z.VALID = {CUBE:1, PLANE:2, CYLINDER:3, SPHERE:4, CIRCLE:5, HEMISPHERE:6, ICOSAHEDRON:7, CONE:8, QUAD:9}, z.widgets_info = {type:{widget:"combo", values:z.VALID}}, z.prototype.onExecute = function() {
    if (this.isOutputConnected(0)) {
      var a = this.getInputOrProperty("size");
      this.last_info.type == this.properties.type && this.last_info.size == a && this.last_info.subdivisions == this.properties.subdivisions || this.updateMesh(this.properties.type, a, this.properties.subdivisions);
      this.setOutputData(0, this._mesh);
    }
  }, z.prototype.updateMesh = function(a, c, e) {
    e = Math.max(0, e) | 0;
    switch(a) {
      case 1:
        this._mesh = GL.Mesh.cube({size:c, normals:!0, coords:!0});
        break;
      case 2:
        this._mesh = GL.Mesh.plane({size:c, xz:!0, detail:e, normals:!0, coords:!0});
        break;
      case 3:
        this._mesh = GL.Mesh.cylinder({size:c, subdivisions:e, normals:!0, coords:!0});
        break;
      case 4:
        this._mesh = GL.Mesh.sphere({size:c, "long":e, lat:e, normals:!0, coords:!0});
        break;
      case 5:
        this._mesh = GL.Mesh.circle({size:c, slices:e, normals:!0, coords:!0});
        break;
      case 6:
        this._mesh = GL.Mesh.sphere({size:c, "long":e, lat:e, normals:!0, coords:!0, hemi:!0});
        break;
      case 7:
        this._mesh = GL.Mesh.icosahedron({size:c, subdivisions:e});
        break;
      case 8:
        this._mesh = GL.Mesh.cone({radius:c, height:c, subdivisions:e});
        break;
      case 9:
        this._mesh = GL.Mesh.plane({size:c, xz:!1, detail:e, normals:!0, coords:!0});
    }
    this.last_info.type = a;
    this.last_info.size = c;
    this.last_info.subdivisions = e;
    this._mesh.version = this.version++;
  }, x.registerNodeType("geometry/mesh_primitive", z), H.title = "renderPoints", H.desc = "render points with a texture", H.widgets_info = {color:{widget:"color"}}, H.prototype.updateMesh = function(a) {
    this.buffer && this.buffer.data && this.buffer.data.length == a.vertices.length ? (this.buffer.data.set(a.vertices), this.buffer.upload(GL.DYNAMIC_DRAW)) : this.buffer = new GL.Buffer(GL.ARRAY_BUFFER, a.vertices, 3, GL.DYNAMIC_DRAW);
    this.mesh || (this.mesh = new GL.Mesh);
    this.mesh.addBuffer("vertices", this.buffer);
    this.geometry_id = this.mesh.id = a._id;
    this.version = this.mesh.version = a._version;
  }, H.prototype.onExecute = function() {
    if (this.properties.enabled) {
      var b = this.getInputData(0);
      if (b) {
        if (this.version == b._version && this.geometry_id == b._id || this.updateMesh(b), x.LGraphRender.onRequestCameraMatrices) {
          x.LGraphRender.onRequestCameraMatrices(K, k, q);
          this.getInputData(2) ? (b = gl.shaders.textured_points) || (b = gl.shaders.textured_points = new GL.Shader(H.vertex_shader_code, H.fragment_shader_code, {USE_TEXTURED_POINTS:""})) : (b = gl.shaders.points) || (b = gl.shaders.points = new GL.Shader(H.vertex_shader_code, H.fragment_shader_code, {USE_POINTS:""}));
          this.color.set(this.properties.color);
          this.color[3] = this.properties.opacity;
          var c = this.getInputData(1);
          c ? t.set(c) : mat4.identity(t);
          this.uniforms.u_point_size = this.properties.point_size;
          this.uniforms.u_point_perspective = this.properties.fixed_size ? 0 : 1;
          this.uniforms.u_perspective = gl.viewport_data[3] * k[5];
          b.uniforms(a);
          b.uniforms(this.uniforms);
          1 <= this.properties.opacity ? gl.disable(gl.BLEND) : gl.enable(gl.BLEND);
          gl.enable(gl.DEPTH_TEST);
          this.properties.additive ? (gl.blendFunc(gl.SRC_ALPHA, gl.ONE), gl.depthMask(!1)) : gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          b.draw(this.mesh, GL.POINTS);
          gl.disable(gl.BLEND);
          gl.depthMask(!0);
        } else {
          console.warn("cannot render geometry, LiteGraph.onRequestCameraMatrices is null, remember to fill this with a callback(view_matrix, projection_matrix,viewprojection_matrix) to use 3D rendering from the graph");
        }
      }
    }
  }, x.registerNodeType("geometry/render_points", H), H.vertex_shader_code = "\r\n\t\tprecision mediump float;\n\r\n\t\tattribute vec3 a_vertex;\n\r\n\t\tvarying vec3 v_vertex;\n\r\n\t\tattribute vec3 a_normal;\n\r\n\t\tvarying vec3 v_normal;\n\r\n\t\t#ifdef USE_COLOR\n\r\n\t\t\tattribute vec4 a_color;\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t#endif\n\r\n\t\tattribute vec2 a_coord;\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\t#ifdef USE_SIZE\n\r\n\t\t\tattribute float a_extra;\n\r\n\t\t#endif\n\r\n\t\t#ifdef USE_INSTANCING\n\r\n\t\t\tattribute mat4 u_model;\n\r\n\t\t#else\n\r\n\t\t\tuniform mat4 u_model;\n\r\n\t\t#endif\n\r\n\t\tuniform mat4 u_viewprojection;\n\r\n\t\tuniform float u_point_size;\n\r\n\t\tuniform float u_perspective;\n\r\n\t\tuniform float u_point_perspective;\n\r\n\t\tfloat computePointSize(float radius, float w)\n\r\n\t\t{\n\r\n\t\t\tif(radius < 0.0)\n\r\n\t\t\t\treturn -radius;\n\r\n\t\t\treturn u_perspective * radius / w;\n\r\n\t\t}\n\r\n\t\tvoid main() {\n\r\n\t\t\tv_coord = a_coord;\n\r\n\t\t\t#ifdef USE_COLOR\n\r\n\t\t\t\tv_color = a_color;\n\r\n\t\t\t#endif\n\r\n\t\t\tv_vertex = ( u_model * vec4( a_vertex, 1.0 )).xyz;\n\r\n\t\t\tv_normal = ( u_model * vec4( a_normal, 0.0 )).xyz;\n\r\n\t\t\tgl_Position = u_viewprojection * vec4(v_vertex,1.0);\n\r\n\t\t\tgl_PointSize = u_point_size;\n\r\n\t\t\t#ifdef USE_SIZE\n\r\n\t\t\t\tgl_PointSize = a_extra;\n\r\n\t\t\t#endif\n\r\n\t\t\tif(u_point_perspective != 0.0)\n\r\n\t\t\t\tgl_PointSize = computePointSize( gl_PointSize, gl_Position.w );\n\r\n\t\t}\r\n\t", 
  H.fragment_shader_code = "\r\n\t\tprecision mediump float;\n\r\n\t\tuniform vec4 u_color;\n\r\n\t\t#ifdef USE_COLOR\n\r\n\t\t\tvarying vec4 v_color;\n\r\n\t\t#endif\n\r\n\t\tvarying vec2 v_coord;\n\r\n\t\tuniform sampler2D u_texture;\n\r\n\t\tvoid main() {\n\r\n\t\t\tvec4 color = u_color;\n\r\n\t\t\t#ifdef USE_TEXTURED_POINTS\n\r\n\t\t\t\tcolor *= texture2D(u_texture, gl_PointCoord.xy);\n\r\n\t\t\t#else\n\r\n\t\t\t\t#ifdef USE_TEXTURE\n\r\n\t\t\t\t  color *= texture2D(u_texture, v_coord);\n\r\n\t\t\t\t  if(color.a < 0.1)\n\r\n\t\t\t\t\tdiscard;\n\r\n\t\t\t\t#endif\n\r\n\t\t\t\t#ifdef USE_POINTS\n\r\n\t\t\t\t\tfloat dist = length( gl_PointCoord.xy - vec2(0.5) );\n\r\n\t\t\t\t\tif( dist > 0.45 )\n\r\n\t\t\t\t\t\tdiscard;\n\r\n\t\t\t\t#endif\n\r\n\t\t\t#endif\n\r\n\t\t\t#ifdef USE_COLOR\n\r\n\t\t\t\tcolor *= v_color;\n\r\n\t\t\t#endif\n\r\n\t\t\tgl_FragColor = color;\n\r\n\t\t}\r\n\t");
})(this);
(function(y) {
  function c() {
    this.addInput("", "string");
    this.addOutput("table", "table");
    this.addOutput("rows", "number");
    this.addProperty("value", "");
    this.addProperty("separator", ",");
    this._table = null;
  }
  y = y.LiteGraph;
  y.wrapFunctionAsNode("string/toString", function(c) {
    if (c && c.constructor === Object) {
      try {
        return JSON.stringify(c);
      } catch (n) {
      }
    }
    return String(c);
  }, [""], "String");
  y.wrapFunctionAsNode("string/compare", function(c, n) {
    return c == n;
  }, ["string", "string"], "boolean");
  y.wrapFunctionAsNode("string/concatenate", function(c, n) {
    return void 0 === c ? n : void 0 === n ? c : c + n;
  }, ["string", "string"], "string");
  y.wrapFunctionAsNode("string/contains", function(c, n) {
    return void 0 === c || void 0 === n ? !1 : -1 != c.indexOf(n);
  }, ["string", "string"], "boolean");
  y.wrapFunctionAsNode("string/toUpperCase", function(c) {
    return null != c && c.constructor === String ? c.toUpperCase() : c;
  }, ["string"], "string");
  y.wrapFunctionAsNode("string/split", function(c, n) {
    null == n && (n = this.properties.separator);
    if (null == c) {
      return [];
    }
    if (c.constructor === String) {
      return c.split(n || " ");
    }
    if (c.constructor === Array) {
      for (var g = [], u = 0; u < c.length; ++u) {
        g[u] = c[u].split(n || " ");
      }
      return g;
    }
    return null;
  }, ["string,array", "string"], "array", {separator:","});
  y.wrapFunctionAsNode("string/toFixed", function(c) {
    return null != c && c.constructor === Number ? c.toFixed(this.properties.precision) : c;
  }, ["number"], "string", {precision:0});
  c.title = "toTable";
  c.desc = "Splits a string to table";
  c.prototype.onExecute = function() {
    var c = this.getInputData(0);
    if (c) {
      var n = this.properties.separator || ",";
      if (c != this._str || n != this._last_separator) {
        this._last_separator = n, this._str = c, this._table = c.split("\n").map(function(c) {
          return c.trim().split(n);
        });
      }
      this.setOutputData(0, this._table);
      this.setOutputData(1, this._table ? this._table.length : 0);
    }
  };
  y.registerNodeType("string/toTable", c);
})(this);
(function(y) {
  function c() {
    this.size = [60, 20];
    this.addInput("send", n.ACTION);
    this.addOutput("received", n.EVENT);
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.properties = {url:"", room:"lgraph", only_send_changes:!0};
    this._ws = null;
    this._last_sent_data = [];
    this._last_received_data = [];
  }
  function g() {
    this.room_widget = this.addWidget("text", "Room", "lgraph", this.setRoom.bind(this));
    this.addWidget("button", "Reconnect", null, this.connectSocket.bind(this));
    this.addInput("send", n.ACTION);
    this.addOutput("received", n.EVENT);
    this.addInput("in", 0);
    this.addOutput("out", 0);
    this.properties = {url:"tamats.com:55000", room:"lgraph", only_send_changes:!0};
    this._server = null;
    this.connectSocket();
    this._last_sent_data = [];
    this._last_received_data = [];
    "undefined" == typeof SillyClient && console.warn("remember to add SillyClient.js to your project: https://tamats.com/projects/sillyserver/src/sillyclient.js");
  }
  var n = y.LiteGraph;
  c.title = "WebSocket";
  c.desc = "Send data through a websocket";
  c.prototype.onPropertyChanged = function(c, g) {
    "url" == c && this.connectSocket();
  };
  c.prototype.onExecute = function() {
    !this._ws && this.properties.url && this.connectSocket();
    if (this._ws && this._ws.readyState == WebSocket.OPEN) {
      for (var c = this.properties.room, g = this.properties.only_send_changes, l = 1; l < this.inputs.length; ++l) {
        var n = this.getInputData(l);
        if (null != n) {
          try {
            var y = JSON.stringify({type:0, room:c, channel:l, data:n});
          } catch (D) {
            continue;
          }
          g && this._last_sent_data[l] == y || (this._last_sent_data[l] = y, this._ws.send(y));
        }
      }
      for (l = 1; l < this.outputs.length; ++l) {
        this.setOutputData(l, this._last_received_data[l]);
      }
      "#AFA" == this.boxcolor && (this.boxcolor = "#6C6");
    }
  };
  c.prototype.connectSocket = function() {
    var c = this, g = this.properties.url;
    "ws" != g.substr(0, 2) && (g = "ws://" + g);
    this._ws = new WebSocket(g);
    this._ws.onopen = function() {
      console.log("ready");
      c.boxcolor = "#6C6";
    };
    this._ws.onmessage = function(g) {
      c.boxcolor = "#AFA";
      g = JSON.parse(g.data);
      if (!g.room || g.room == c.properties.room) {
        if (1 == g.type) {
          if (g.data.object_class && n[g.data.object_class]) {
            var l = null;
            try {
              l = new n[g.data.object_class](g.data), c.triggerSlot(0, l);
            } catch (A) {
            }
          } else {
            c.triggerSlot(0, g.data);
          }
        } else {
          c._last_received_data[g.channel || 0] = g.data;
        }
      }
    };
    this._ws.onerror = function(g) {
      console.log("couldnt connect to websocket");
      c.boxcolor = "#E88";
    };
    this._ws.onclose = function(g) {
      console.log("connection closed");
      c.boxcolor = "#000";
    };
  };
  c.prototype.send = function(c) {
    this._ws && this._ws.readyState == WebSocket.OPEN && this._ws.send(JSON.stringify({type:1, msg:c}));
  };
  c.prototype.onAction = function(c, g) {
    this._ws && this._ws.readyState == WebSocket.OPEN && this._ws.send({type:1, room:this.properties.room, action:c, data:g});
  };
  c.prototype.onGetInputs = function() {
    return [["in", 0]];
  };
  c.prototype.onGetOutputs = function() {
    return [["out", 0]];
  };
  n.registerNodeType("network/websocket", c);
  g.title = "SillyClient";
  g.desc = "Connects to SillyServer to broadcast messages";
  g.prototype.onPropertyChanged = function(c, g) {
    "room" == c && (this.room_widget.value = g);
    this.connectSocket();
  };
  g.prototype.setRoom = function(c) {
    this.properties.room = c;
    this.room_widget.value = c;
    this.connectSocket();
  };
  g.prototype.onDrawForeground = function() {
    for (var c = 1; c < this.inputs.length; ++c) {
      var g = this.inputs[c];
      g.label = "in_" + c;
    }
    for (c = 1; c < this.outputs.length; ++c) {
      g = this.outputs[c], g.label = "out_" + c;
    }
  };
  g.prototype.onExecute = function() {
    if (this._server && this._server.is_connected) {
      for (var c = this.properties.only_send_changes, g = 1; g < this.inputs.length; ++g) {
        var l = this.getInputData(g), n = this._last_sent_data[g];
        if (null != l) {
          if (c) {
            var y = !0;
            if (l && l.length && n && n.length == l.length && l.constructor !== String) {
              for (var D = 0; D < l.length; ++D) {
                if (n[D] != l[D]) {
                  y = !1;
                  break;
                }
              }
            } else {
              this._last_sent_data[g] != l && (y = !1);
            }
            if (y) {
              continue;
            }
          }
          this._server.sendMessage({type:0, channel:g, data:l});
          if (l.length && l.constructor !== String) {
            if (this._last_sent_data[g]) {
              for (this._last_sent_data[g].length = l.length, D = 0; D < l.length; ++D) {
                this._last_sent_data[g][D] = l[D];
              }
            } else {
              this._last_sent_data[g] = l.constructor === Array ? l.concat() : new l.constructor(l);
            }
          } else {
            this._last_sent_data[g] = l;
          }
        }
      }
      for (g = 1; g < this.outputs.length; ++g) {
        this.setOutputData(g, this._last_received_data[g]);
      }
      "#AFA" == this.boxcolor && (this.boxcolor = "#6C6");
    }
  };
  g.prototype.connectSocket = function() {
    var c = this;
    if ("undefined" == typeof SillyClient) {
      this._error || console.error("SillyClient node cannot be used, you must include SillyServer.js"), this._error = !0;
    } else {
      if (this._server = new SillyClient, this._server.on_ready = function() {
        console.log("ready");
        c.boxcolor = "#6C6";
      }, this._server.on_message = function(g, l) {
        g = null;
        try {
          g = JSON.parse(l);
        } catch (G) {
          return;
        }
        if (1 == g.type) {
          if (g.data.object_class && n[g.data.object_class]) {
            l = null;
            try {
              l = new n[g.data.object_class](g.data), c.triggerSlot(0, l);
            } catch (G) {
              return;
            }
          } else {
            c.triggerSlot(0, g.data);
          }
        } else {
          c._last_received_data[g.channel || 0] = g.data;
        }
        c.boxcolor = "#AFA";
      }, this._server.on_error = function(g) {
        console.log("couldnt connect to websocket");
        c.boxcolor = "#E88";
      }, this._server.on_close = function(g) {
        console.log("connection closed");
        c.boxcolor = "#000";
      }, this.properties.url && this.properties.room) {
        try {
          this._server.connect(this.properties.url, this.properties.room);
        } catch (u) {
          console.error("SillyServer error: " + u);
          this._server = null;
          return;
        }
        this._final_url = this.properties.url + "/" + this.properties.room;
      }
    }
  };
  g.prototype.send = function(c) {
    this._server && this._server.is_connected && this._server.sendMessage({type:1, data:c});
  };
  g.prototype.onAction = function(c, g) {
    this._server && this._server.is_connected && this._server.sendMessage({type:1, action:c, data:g});
  };
  g.prototype.onGetInputs = function() {
    return [["in", 0]];
  };
  g.prototype.onGetOutputs = function() {
    return [["out", 0]];
  };
  n.registerNodeType("network/sillyclient", g);
})(this);

